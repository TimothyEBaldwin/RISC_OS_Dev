; Copyright 2012 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>
        $GetIO

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries
        GET     Hdr:Proc

        GET     hdr.StaticWS

        EXPORT  HAL_KbdScanSetup
        EXPORT  HAL_KbdScanFinish
        EXPORT  HAL_KbdScan
        EXPORT  HAL_KbdScanInterrupt
        IMPORT  HAL_IRQEnable

        AREA    |Asm$$Code|, CODE, READONLY, PIC

; This file contains the minimal PC keyboard control stuff required for the boot-time keyboard scan

IOData          *       IOCSERTX
IOStatus        *       IOMD_KBDCR
IOControl       *       IOMD_KBDCR
stat_RXF        *       IOMD_KBDCR_RxF
stat_TXE        *       IOMD_KBDCR_TxE
ctl_Enable      *       IOMD_KBDCR_Enable
ctl_EnableIRQ   *       0       ; not needed on IOMD


; PC keyboard codes we are interested in.
PCReset         *       &AA
PCSpecial       *       &E0
PCCTRLL         *       &14
PCCTRLR         *       &14     ; Preceded by &E0
PCSHIFTL        *       &12
PCSHIFTR        *       &59
PCR             *       &2D
PCT             *       &2C
PCDelete        *       &71     ; Preceded by &E0
PCBSpace        *       &66
PCEnd           *       &69     ; Preceded by &E0

KeyData
        DCB     PCCTRLL,  KbdFlag_Ctrl
        DCB     PCSHIFTL, KbdFlag_Shift
        DCB     PCSHIFTR, KbdFlag_Shift
        DCB     PCR,      KbdFlag_R
        DCB     PCT,      KbdFlag_T
        DCB     PCBSpace, KbdFlag_Delete
        DCB     0
        ALIGN

SpecialData
        DCB     PCCTRLR,  KbdFlag_Ctrl
        DCB     PCDelete, KbdFlag_Delete
        DCB     PCEnd,    KbdFlag_Copy
        DCB     0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HAL_KbdScanSetup ROUT
        EntryS
        MRS     r0, CPSR
        ORR     r0, r0, #I32_bit
        MSR     CPSR_c, r0

        LDR     r0, IOMD_Address
        MOV     r1, #ctl_Enable + ctl_EnableIRQ
        STRB    r1, [r0, #IOControl]
10
        LDRB    r1, [r0, #IOStatus]
        TST     r1, #stat_TXE
        MOVNE   r1, #&FF
        STRNEB  r1, [r0, #IOData]
        BEQ     %BT10

 [ MorrisSupport
        LDRB    r1, [r0, #IOMD_ID0]
        LDRB    r2, [r0, #IOMD_ID1]
        ORR     r1, r1, r2, LSL #8
        LDR     r2, =IOMD_Original
        TEQ     r1, r2
        BEQ     %FT30

        MOV     R1, #IOMD_MSECR_Enable          ;7500(FE), so initialise 2nd PS2 (mouse) port cos
        STRB    R1, [R0, #IOMD_MSECR]           ;keyboard may be connected there instead
20
        LDRB    R1, [R0, #IOMD_MSECR]
        TST     R1, #IOMD_MSECR_TxE             ;Is port ready to accept data
        MOVNE   R1, #&FF                        ;NE: port ready, so send 'reset' command
        STRNEB  R1, [R0, #IOMD_MSEDAT]          ;
        BEQ     %BT20                           ;EQ: loop til port ready

        ; Enable mouse RX interrupt
        MOV     r0, #22
        BL      HAL_IRQEnable

        MOV     R1, #2
        STRB    R1, Port2Present
30
 ]
        ADR     r1, KeyData
        STR     r1, KeyDataPtr

        ; Enable main keyboard RX interrupt
        MOV     r0, #15
        BL      HAL_IRQEnable

        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HAL_KbdScanFinish ROUT
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HAL_KbdScan ROUT
        ; HAL spec says that bits which are reported as being set must
        ; never be cleared later on. But with MorrisSupport keyboards can
        ; vanish after being detected; assume that it's not a serious issue
        ; if a keyboard vanishes before any keys have been pressed
        LDRB    r1, KbdPresentFlags
        LDR     r0, KbdFlags
        CMP     r1, #0
        ORRNE   r0, r0, #KbdFlag_Present
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HAL_KbdScanInterrupt ROUT
        Entry

        LDR     r2, IOMD_Address
 [ MorrisSupport
        LDRB    r1, Port2Present ;Check if 2nd PS2 port (in Morris) is available
        TEQ     r1, #0
        BEQ     %FT4

        TEQ     r0, #22                 ; Mouse IRQ?
        LDREQB  r2, [r2, #IOMD_MSEDAT]  ;EQ: 2nd port present and interrupting, get scan code
        MOVEQ   r1, #2                  ;EQ: indicate which port
        BEQ     %FT5                    ;EQ: process it
                                        ;NE: 2nd port not present or interrupting
                                        ;    drop through and check 1st port
4
 ]
        TEQ     r0, #15                 ; If not keyboard then
        EXIT    NE                      ;   exit.

        LDRB    r2, [r2, #IOData]       ; Get scan code.

 [ MorrisSupport
        MOV     r1, #1
5
        LDRB    r0, KbdPresentFlags

        TEQ     r2, #0                  ;Assume that zero is the end of a mouse AA 00 start up
        BICEQ   r0, r0, r1              ; sequence, so clear keyboard present indication.
        STREQB  r0, KbdPresentFlags
        BEQ     %FT90                   ; and exit
 ]

        ORR     r0, r0, r1              ;Not zero, mark keyboard present
        STRB    r0, KbdPresentFlags

        ADR     r1, SpecialData

        TEQ     r2, #PCSpecial          ; If special code then
        STREQ   r1, KeyDataPtr          ;   switch tables
        BEQ     %FT90                   ;   and exit.

        LDR     r0, KeyDataPtr          ; Get pointer to current table.

        TEQ     r0, r1                  ; Only use special table once, then
        ADREQ   r1, KeyData             ;   switch back to normal table.
        STREQ   r1, KeyDataPtr
        LDR     r3, KbdFlags
10
        LDRB    r1, [r0], #2            ; Get key code from table.
        TEQ     r1, #0                  ; If at end of table then
        BEQ     %FT80                   ;   ignore key.

        TEQ     r1, r2                  ; If not this key then
        BNE     %BT10                   ;   try the next.

        LDRB    r1, [r0, #-1]           ; Get flag.
        ORR     r3, r3, #KbdFlag_Present; Keyboard definitely present if we got a valid key
        ORR     r3, r3, r1
80
        STR     r3, KbdFlags
90
        MOV     r0, #-1                 ; IRQ handled
        EXIT

        END

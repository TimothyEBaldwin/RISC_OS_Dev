; Copyright 2012 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        $GetIO

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries
        GET     Hdr:Proc
        GET     Hdr:DevNos

        GET     hdr.StaticWS

        EXPORT  HAL_KbdScanSetup
        EXPORT  HAL_KbdScanFinish
        EXPORT  HAL_KbdScan
        EXPORT  HAL_KbdScanInterrupt
        IMPORT  HAL_IRQEnable
        IMPORT  HAL_IRQDisable
        IMPORT  HAL_IRQClear

        AREA    |Asm$$Code|, CODE, READONLY, PIC

; This file contains the minimal PC keyboard control stuff required for the boot-time keyboard scan

; PC command codes we send.
PCReset         *       &FF     ; Outgoing command

; PC keyboard codes we are interested in.
PCSpecial       *       &E0
PCCTRLL         *       &14
PCCTRLR         *       &14     ; Preceded by &E0
PCSHIFTL        *       &12
PCSHIFTR        *       &59
PCR             *       &2D
PCT             *       &2C
PCDelete        *       &71     ; Preceded by &E0
PCEnd           *       &69     ; Preceded by &E0

; How long we're prepared to wait for activity (cs)
TimeoutPost     *       75      ; Longest BAT time
TimeoutPress    *       50      ; If initial key down missed, wait 1 typematic delay
TimeoutMargin   *       75      ; Generous to a fault

KeyData
        DCB     PCCTRLL,  KbdFlag_Ctrl
        DCB     PCSHIFTL, KbdFlag_Shift
        DCB     PCSHIFTR, KbdFlag_Shift
        DCB     PCR,      KbdFlag_R
        DCB     PCT,      KbdFlag_T
        DCB     0
        ALIGN

SpecialData
        DCB     PCCTRLR,  KbdFlag_Ctrl
        DCB     PCDelete, KbdFlag_Delete
        DCB     PCEnd,    KbdFlag_Copy
        DCB     0
        ALIGN

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HAL_KbdScanSetup ROUT
        EntryS
        MRS     r0, CPSR
        ORR     r0, r0, #I32_bit
        MSR     CPSR_c, r0

        LDR     r0, IOMD_Address
        MOV     r1, #IOMD_KBDCR_Enable
        STRB    r1, [r0, #IOMD_KBDCR]
10
        LDRB    r1, [r0, #IOMD_KBDCR]
        TST     r1, #IOMD_KBDCR_TxE
        MOVNE   r1, #PCReset
        STRNEB  r1, [r0, #IOCSERTX]
        BEQ     %BT10

 [ MorrisSupport
        LDRB    r1, [r0, #IOMD_ID0]
        LDRB    r2, [r0, #IOMD_ID1]
        ORR     r1, r1, r2, LSL #8
        LDR     r2, =IOMD_Original
        TEQ     r1, r2
        BEQ     %FT30

        MOV     R1, #IOMD_MSECR_Enable          ; 7500(FE), so initialise 2nd PS2 (mouse) port cos
        STRB    R1, [R0, #IOMD_MSECR]           ; keyboard may be connected there instead
20
        LDRB    R1, [R0, #IOMD_MSECR]
        TST     R1, #IOMD_MSECR_TxE             ; Is port ready to accept data
        MOVNE   R1, #PCReset                    ; NE: port ready, so send 'reset' command
        STRNEB  R1, [R0, #IOMD_MSEDAT]          ;
        BEQ     %BT20                           ; EQ: loop til port ready

        ; Enable mouse RX interrupt
        MOV     r0, #IOMD_MouseRxFull_DevNo
        BL      HAL_IRQEnable

        MOV     R1, #2
        STRB    R1, KbdPort2Present
30
 ]
        ADR     r1, KeyData
        STR     r1, KbdKeyNumTable

        ; Enable main keyboard RX interrupt
        MOV     r0, #IOMD_SerialRx_DevNo
        BL      HAL_IRQEnable

        ; And your time starts now
        LDR     r1, =TimeoutPost + TimeoutPress + TimeoutMargin
        STR     r1, KbdCountDown
        MOV     r0, #IOMD_Timer0_DevNo
        BL      HAL_IRQEnable

        EXITS

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HAL_KbdScanFinish ROUT
        MOV     r0, #IOMD_Timer0_DevNo
        B       HAL_IRQDisable

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HAL_KbdScan ROUT
        ; HAL spec says that bits which are reported as being set must
        ; never be cleared later on. But with MorrisSupport keyboards can
        ; vanish after being detected; assume that it's not a serious issue
        ; if a keyboard vanishes before any keys have been pressed
        LDR     r2, KbdCountDown
        LDRB    r1, KbdPresentFlags
        LDR     r0, KbdFlags
        CMP     r1, #0
        ORRNE   r0, r0, #KbdFlag_Present
        CMP     r2, #0
        ORREQ   r0, r0, #KbdFlag_Done
        MOV     pc, lr

; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

HAL_KbdScanInterrupt ROUT
        Entry

        TEQ     r0, #IOMD_Timer0_DevNo
        BNE     %FT3
        BL      HAL_IRQClear
        LDR     r1, KbdCountDown
        SUBS    r1, r1, #1              ; Be a little more patient
        STRPL   r1, KbdCountDown
        B       %FT90
3
        LDR     r2, IOMD_Address
 [ MorrisSupport
        LDRB    r1, KbdPort2Present     ; Check if 2nd PS2 port (in Morris) is available
        TEQ     r1, #0
        BEQ     %FT4

        TEQ     r0, #IOMD_MouseRxFull_DevNo
        LDREQB  r2, [r2, #IOMD_MSEDAT]  ; EQ: 2nd port present and interrupting, get scan code
        MOVEQ   r1, #2                  ; EQ: indicate which port
        BEQ     %FT5                    ; EQ: process it
                                        ; NE: 2nd port not present or interrupting
                                        ;     drop through and check 1st port
4
 ]
        TEQ     r0, #IOMD_SerialRx_DevNo
        EXIT    NE                      ; If not keyboard then exit.

        LDRB    r2, [r2, #IOCSERRX]     ; Get scan code.

 [ MorrisSupport
        MOV     r1, #1
5
        LDRB    r0, KbdPresentFlags

        TEQ     r2, #0                  ; Assume that zero is the end of a mouse AA 00 start up
        BICEQ   r0, r0, r1              ; sequence, so clear keyboard present indication.
        STREQB  r0, KbdPresentFlags
        BEQ     %FT90                   ; and exit

        ORR     r0, r0, r1              ; Not zero, mark keyboard present
 |
        MOV     r0, #1                  ; Medusa keyboard, not a mouse
 ]
        STRB    r0, KbdPresentFlags

        ADR     r1, SpecialData

        TEQ     r2, #PCSpecial          ; If special code then
        STREQ   r1, KbdKeyNumTable      ;   switch tables
        BEQ     %FT90                   ;   and exit.

        LDR     r0, KbdKeyNumTable      ; Get pointer to current table.

        TEQ     r0, r1                  ; Only use special table once, then
        ADREQ   r1, KeyData             ;   switch back to normal table.
        STREQ   r1, KbdKeyNumTable
10
        LDRB    r1, [r0], #2            ; Get key code from table.
        TEQ     r1, #0                  ; If at end of table then
        BEQ     %FT90                   ;   ignore key.

        TEQ     r1, r2                  ; If not this key then
        BNE     %BT10                   ;   try the next.

        LDRB    r1, [r0, #-1]           ; Get flag.
        LDR     r3, KbdFlags
        ORR     r3, r3, #KbdFlag_Present :OR: KbdFlag_Done ; End the scan if we got a valid key
        ORR     r3, r3, r1
        STR     r3, KbdFlags
90
        MOV     r0, #-1                 ; IRQ handled
        EXIT

        END

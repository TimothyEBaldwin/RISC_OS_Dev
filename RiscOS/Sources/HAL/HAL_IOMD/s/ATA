; Copyright 2010 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:Machine.<Machine>
        GET     Hdr:ImageSize.<ImageSize>

        GET     Hdr:OSEntries
        GET     Hdr:HALEntries

        GET	hdr.StaticWS

        AREA    |Asm$$Code|, CODE, READONLY, PIC


        ;IMPORT  memcpy

        EXPORT  ATA_Init
        EXPORT  HAL_ATAControllerInfo
        EXPORT  HAL_ATASetModes
        EXPORT  HAL_ATACableID

ATA_Init
        Push    "v1,v2,lr"

        Pull    "v1,v2,pc"

HAL_ATAControllerInfo
        CMP     a1, #-1
        CMP     a1, #1
        MOVHS   a1, #0
        MOVHS   pc, lr

        Push    "a2,a3,v1-v5,lr"
        MOV     v5, a1                  ; v5 = Controller number

        SUB     sp, sp, #12*4           ; construct on stack
        MOV     v1, sp

        MOV     a1, #2_0010             ; no 32-bit PIO, no 48-bit DMA
        STR     a1, [v1], #4


        ; Read command block address
	LDR	a1, C710_Address
	ADD	a1, a1,	#0x00007c0

        STR     a1, [v1], #4

        ; Read control block address
	LDR	a1, C710_Address
	ADD	a1, a1, #0x0000fd0
        STR     a1, [v1], #4

        ; Read bus master address
        MOV     a1, #0

        STR     a1, [v1], #4

        TEQ     v5, #0
        MOV     a1, #9
        MOV     a2, #2_1            ; PIO modes 0
        MOV     a3, #0xff           ; No Multiword DMA modes
        MOV     a4, #0xff           ; No Ultra DMA modes
        STMIA   v1!, {a1-a4}

	MOV	a1, #0xffffffff
	MOV	a2, a1
	MOV	a3, a1
	MOV	a4, a1
        STMIA   v1!, {a1-a4}

        LDMIA   v1!, {a1,a3}            ; caller's buffer + length
        CMP     a3, #12*4
        MOVHI   a3, #12*4
        MOV     a2, sp

cplp    LDRB	v2,[a2],#1
	STRB	v2,[a1],#1
	SUBS	a3,a3,#1
	BNE	cplp
       ; BL      memcpy                  ; copy in as much as possible

        MOV     sp, v1

        MOV     a1, #12*4               ; say how much we gave them
        Pull    "v1-v5,pc"

        ALIGN

HAL_ATASetModes
        CMP     a1, #1
        MOVHS   pc, lr

        Push    "v1-v5,lr"

	MOV	v1, #0xffffff00
        ORRS    a2, a2, a2
	STRNE	v1, [a2,#4]
	ORRS    a3, a3, a3
	STRNE	v1, [a3,#4]

        Pull    "v1-v5,pc"

; Data timings are shared between PIO and multiword DMA, so need to select
; timings that meet both the PIO and DMA requirements.

;      Pulse time,recovery time (33MHz clocks)
PIO_Data_Table
        =       8,12    ; 240ns,360ns = 600ns cycle
        =       5,8     ; 150ns,240ns = 390ns cycle (standard=383ns)
        =       4,4     ; 120ns,120ns = 240ns cycle
        =       3,3     ; 90ns,90ns   = 180ns cycle
        =       3,1     ; 90ns,30ns   = 120ns cycle
        ALIGN

DMA_Data_Table
        =       8,8     ; 240ns,240ns = 480ns cycle
        =       3,2     ; 90ns,60ns   = 150ns cycle
        =       3,1     ; 90ns,30ns   = 120ns cycle
        ALIGN

; Register values for PIO modes (no clash with DMA, so use raw)
PIO_Reg_Table
        =       &0C     ; 240ns,360ns = 600ns cycle (ATA spec says 290ns
        =       &05     ; 240ns,150ns = 390ns cycle  pulse for modes 0-2
        =       &03     ; 240ns,90ns  = 330ns cycle  but controller can't
        =       &33     ; 90ns,90ns   = 180ns cycle  go that high)
        =       &31     ; 90ns,30ns   = 120ns cycle
        ALIGN

PIO_Addr_Table
        =       &03, &02, &01, &01, &01
        ALIGN

HAL_ATACableID
        MOV     a1, #0
        MOVHS   pc, lr


        END

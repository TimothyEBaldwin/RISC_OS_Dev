; Copyright (c) 1995, Expressive Software Projects
; All rights reserved.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in the
;       documentation and/or other materials provided with the distribution.
;     * Neither the name of Expressive Software Projects nor the names of its
;       contributors may be used to endorse or promote products derived from
;       this software without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
; DISCLAIMED. IN NO EVENT SHALL EXPRESSIVE SOFTWARE PROJECTS BE LIABLE FOR ANY
; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
; (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
; ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;
; JRF: these are defined in global headers
; XOS_AddCallBack		*	&20054
; XOS_RemoveCallBack	*	&2005F
; XOS_ServiceCall		*	&20030

module
	; Module header
	DCD	0				; Not an application
	DCD	initCode	- MODULE_START
	DCD	finalCode	- MODULE_START
	DCD	serviceCode	- MODULE_START
	DCD	title		- MODULE_START
	DCD	help		- MODULE_START
	DCD	commandTable	- MODULE_START
swiBaseNum
	DCD	swiBase				; SWI Base number
	DCD	swiHandler	- MODULE_START
	DCD	swiTable	- MODULE_START	; SWI Decode table
	DCD	0				; SWI Decode code
        DCD     0                               ; No messages file
        DCD     flagsWord       - MODULE_START

copyr
	= copyRightS
title
	= titleS,0
	ALIGN
help
	= "Shared Sound",9,Module_HelpVersion,variantS,0
	ALIGN

flagsWord
        DCD     1       ; 32-bit compatible

initCode
	STMDB	sp!,{r0-r11,ws,lr}

	BL	startMem               ; Get memory
	BVS	initMemError

	; r10 = private word
	; ws = memory pointer [r10]

	BL    initWorkspace          ; Initialise workspace

 [ doCBAI
	BL    InstallCBAI
 ]

	BL	installDefaultDriver   ; Preferably Sound_LinearHandler or ChannelHandler

	; notify TaskManager that the acknowledgements have changed
	LDR	r1,Service_TaskManagerAcknowledgementsVal
	MOV	r2,#0		; MUST be zero to notify of change
	SWI	XOS_ServiceCall ; ignore if it failed

	ADR	R0,send_service_sound_start
	MOV	R1,#0
	SWI	XOS_AddCallBack

	CLRV				; Clear V
	LDMIA	sp!,{r0-r11,ws,pc}

initMemError
	LDMIA	sp!,{r0-r11,ws,lr}
	ADR	r0,initMemErrMesg
	CMP	R0,#&80000000
	CMNVC	R0,#&80000000		; Set V
	MOV	PC,R14
initMemErrMesg

	DCD errn_InitMem
	= "Not enough memory for ",titleS,0
	ALIGN

send_service_sound_start
	STMFD	r13!,{r0-r8,r14}
	MOV	r1,#Service_Sound			; Service_Sound
	MOV	r0,#Service_Sound_SharedSoundAlive	; SharedSound starting
	SWI	XOS_ServiceCall				; Ignore any errors
	LDMFD	r13!,{r0-r8,PC}

 ; -------------------------------------------------

finalCode
	STMDB	sp!,{r0-r11,ws,lr}

	LDR	ws,[ws]          ; Get work area

	MOV	r1,#Service_Sound			; Service_Sound
	MOV	r0,#Service_Sound_SharedSoundDying	; SharedSound dying
	SWI	XOS_ServiceCall	 			; Ignore any errors

	ADR	r0,send_service_sound_start
	MOV	r1,#0
	SWI	XOS_RemoveCallBack


 [ doCBAI
	BL	RemoveCBAI
 ]
	BL	releaseDriver

	; notify TaskManager that the acknowledgements have changed
	LDR	r1,Service_TaskManagerAcknowledgementsVal
	MOV	r2,#0 ; MUST be zero to notify of change
	SWI	XOS_ServiceCall ; ignore if it failed

	ADR     r0,serviceCode_Sound_DelayedCallback
	MOV     r1,r12
	SWI     XOS_RemoveTickerEvent

	ADR     r0,serviceCode_Sound_Callback
	MOV     r1,r12
	SWI     XOS_RemoveCallBack

 [ doCallBack
	ADRL	r0,rateChangeCallBack
	LDR	r1,[ws,#work_privateWord]
	SWI     XOS_RemoveCallBack
 ]

	ADRL	r0,doHandlerCallBack
	LDR	r1,[ws,#work_privateWord]
	SWI     XOS_RemoveCallBack

	CLRV				; Clear V
	LDMIA	sp!,{r0-r11,ws,pc}
 ;
 ; -------------------------------------------------

	; Service numbers, incorporating Ursula service numbers
	ASSERT  Service_Sound < Service_TaskManagerAcknowledgements
	ASSERT  Service_TaskManagerAcknowledgements < Service_SoundDriver
UrsulaService
	DCD	0 ; flags
	DCD	serviceCode_UrsulaEntry - MODULE_START	; the entry point

	DCD	Service_Sound
Service_TaskManagerAcknowledgementsVal
	DCD	Service_TaskManagerAcknowledgements
Service_SoundDriverVal
	DCD	Service_SoundDriver
	DCD	0 ; table terminator
	DCD	UrsulaService 		- MODULE_START	; the table anchor

serviceCode
	; Sound driver call recognised
	; TaskManager acknowledgements recognised
	MOV     r0, r0
serviceCode_UrsulaEntry
        Push    "lr"

	TEQ	R1,#Service_Sound
	BEQ	serviceCode_Sound

	LDR	lr,Service_SoundDriverVal
	TEQ	r1,lr
	BEQ	serviceCode_SoundDriver

	LDR	lr,Service_TaskManagerAcknowledgementsVal
	TEQ	r1,lr
	BEQ	serviceCode_TaskManagerAcknowledgements

        Pull    "pc"

; SoundDMA has reinitialised, so we need to stick our
; LinearHandler in place
serviceCode_Sound
	STMFD   R13!,{R0-R3}
	LDR     ws,[ws]
	LDR     R14,[ws,# work_currentDriver]

; linear handler goes through level 0
; if it dies, we shutdown the current handler (for lin or log handlers)
; it it starts up, we start the current handler (for lin or log handlers)
	TEQ     R14,#2 ; linear handler
	TEQNE   R14,#1 ; log handler
	TEQEQ   R0,#Service_Sound_Level0Dying
	BEQ     serviceCode_Sound_Shutdown

	TEQ     R14,#2 ; linear handler
	TEQNE   R14,#1 ; log handler
	TEQ     R0,#Service_Sound_Level0Alive
	BEQ     serviceCode_Sound_Reinit

; log handler goes through level 1, but only after SoundChannels has
; registered itself
	TEQ     R0,#Service_Sound_Level1Dying
	TEQEQ   R14,#1 ; log handler
        BEQ     serviceCode_Sound_Shutdown

	TEQ     R0,#Service_Sound_Level1Alive
	TEQEQ   R14,#1 ; log handler

	LDMNEFD R13!,{R0-R3,PC}

serviceCode_Sound_Reinit
        TEQ     r14,#1 ; log handler
        BNE     %FT10  ; linear handler can go

; SoundChannels probably hasn't received the service yet, so we need to
; delay the callback for a bit - this probably won't be noticable and
; if it is, then that's tough - probably Level1 should say that it's now
; re-registered, but we'll just cope for now.
        MOV     r0,#40-1 ; 40 cs good enough ?
	ADR     r1,serviceCode_Sound_DelayedCallback
	MOV     r2,ws
	SWI     XOS_CallAfter

	LDMFD   R13!,{R0-R3,PC}

10
	ADR     r0,serviceCode_Sound_Callback
	MOV     r1,ws
	SWI     XOS_AddCallBack

	LDMFD   R13!,{R0-R3,PC}

serviceCode_Sound_Shutdown
   [ debug
	SWI     XOS_WriteS
	= "shutdown: releaseDriver",0
	SWI     XOS_NewLine
   ]
        BL      releaseDriver
   [ debug
	SWI     XOS_WriteS
	= "shutdown: returning",0
	SWI     XOS_NewLine
   ]
	LDMFD   R13!,{R0-R3,PC}

serviceCode_Sound_Callback ROUT
	STMFD   R13!,{R0-R3,R14}
   [ debug
	SWI     XOS_WriteS
	= "callback: installDefaultDriver",0
	ALIGN
	SWI     XOS_NewLine
   ]
	BL      installDefaultDriver
   [ debug
	SWI     XOS_WriteS
	= "callback: done",0
	ALIGN
	SWI     XOS_NewLine
   ]

; check the install type
	LDR     R14,[ws,# work_currentDriver]
	TEQ     R14,#1 ; log driver ?
        BNE     %FT90
   [ doLog
        LDR     R14,[ws,# work_Log_InitedFully]
        TEQ     R14,#1
        BEQ     %FT90
   ]

; SoundChannels probably hasn't received the service yet, so we need to
; delay the callback for a bit - this probably won't be noticable and
; if it is, then that's tough - probably Level1 should say that it's now
; re-registered, but we'll just cope for now.
        MOV     r0,#40-1 ; 40 cs good enough ?
	ADR     r1,serviceCode_Sound_DelayedCallback
	MOV     r2,ws
	SWI     XOS_CallAfter

90
	LDMFD   R13!,{R0-R3,PC}

serviceCode_Sound_DelayedCallback
	STMFD   R13!,{R0-R3,R14}
   [ debug
	SWI     XOS_WriteS
	= "delayedcallback: set callback",0
	ALIGN
	SWI     XOS_NewLine
   ]
	ADR     r0,serviceCode_Sound_Callback
	MOV     r1,ws
	SWI     XOS_AddCallBack

	LDMFD   R13!,{R0-R3,PC}

 ; Ensure that we place messages in the acknowledgements window
serviceCode_TaskManagerAcknowledgements

	STMDB	sp!,{r0-r3}
	TEQ	r2,#0
	LDMEQIA	sp!,{r0-r3,pc}
	MOV	r3,r2
	MOV	r0,#&1000;TaskManager_AckGroup_System ; &1000

	ADRL	r1,title

	ADR	r2,acknowledgement
	MOV	lr,pc
	MOV	pc,r3
	LDMIA sp!,{r0-r3,pc}

; the message to appear in the window
acknowledgement

	= ackS,0
	ALIGN

serviceCode_SoundDriver
	STMDB	sp!,{r0-r11,ws}      ; lr already stacked

	LDR	ws,[ws]          ; Get work area

	CMP	r0,#Service_SoundDriver_Start
	BEQ	serviceCode_SoundDriverStart

	CMP	r0,#Service_SoundDriver_End
	BEQ	serviceCode_SoundDriverEnd

	LDMIA	sp!,{r0-r11,ws,pc}

serviceCode_SoundDriverStart
	; install into Sound Driver

	BL	get_SoundDriverStart_R0
	;ADR   r0,SoundDriverStart
	MOV	r1,ws

	; Change here from RJW; we may well be in IRQ mode here, so
	; can't call SWIs directly. Instead jump to SVC mode and
	; protect SVC_R14 first.
	STMFD	R13!,{R8,R9}

      [ NoARMG
	TEQ	PC,PC
	MRSEQ	R9,CPSR		; If in 32-bit mode, R9 = CPSR
	MOVNE	R9,PC		; If in 26-bit mode, R9 = PC+PSR
	ORR	R8,R9,#3	; Preserves 32-bitness
	MSREQ	CPSR_c,R8
	TEQNEP	R8,#0
	MOV	R0,R0
      |
        ; Binary is only for ARMs with no 26-bit mode so simplify to remove warnings
        MRS     R9,CPSR
        ORR     R8,R9,#3        ; to SVC32 mode
        MSR     CPSR_c,R8
      ]
	Push    "R14"

	SWI	XOS_AddCallBack

        Pull    "R14"
      [ NoARMG
	TEQ	PC,PC
	MSREQ	CPSR_c,R9
	TEQNEP	R9,#0
	MOV	R0,R0
      |
        ; Binary is only for ARMs with no 26-bit mode so simplify to remove warnings
        MSR     CPSR_c,R9       ; back to original mode
      ]
	LDMFD	R13!,{R8,R9}

	LDMIA	sp!,{r0-r11,ws,pc}

 ; ----

serviceCode_SoundDriverEnd
	;  Remove from Sound Driver

	BL	SoundDriverRemove

	LDMIA sp!,{r0-r11,ws,pc}

	; -----------------  * Comands

commandTable

	DCD 0   ; No more commands

 ; -----------------  SWI'S

swiTable

	= swiNameS,0
	= "InstallHandler",0
	= "RemoveHandler",0
	= "HandlerInfo",0
	= "HandlerVolume",0
	= "HandlerSampleType",0
	= "HandlerPause",0
	= "SampleRate",0
	= "InstallDriver",0
	= "RemoveDriver",0
	= "DriverInfo",0
	= "DriverVolume",0
	= "DriverMixer",0
	= "CheckDriver",0
	= "ControlWord",0
	= "HandlerType",0
 [ debug1
	= "Test",0
	= "Info",0
 ]
	DCB 0
	ALIGN

swiHandler
	MOV	r10,ws
	LDR	ws,[ws]    ; ws = pointer to RMA data block
	CMP	r11,#(EndOfJumpTable - jumpTable)/4
	ADDCC	pc,pc,r11,LSL #2
	B	UnknownSWIerror
jumpTable
	B	swiInstallHandler          ;  OK
	B	swiRemoveHandler           ;  OK
	B	swiHandlerInfo             ;  OK
	B	swiHandlerVolume           ;  OK
	B	swiHandlerSampleType       ;  not in this version
	B	swiHandlerPause            ;  not in this version
	B	swiSampleRate              ;  OK
	B	swiInstallDriver           ;  OK
	B	swiRemoveDriver            ;  OK
	B	swiDriverInfo              ;  OK
	B	swiDriverVolume            ;  OK
	B	swiDriverMixer             ;  OK
	B	driverCheck                ;
	B	swiControlWord             ;
	B	swiHandlerType             ;
 [ debug1
	B	swiTest                    ;  For debugging only
	B	swiInfo                    ;  For debugging only
 ]

EndOfJumpTable

UnknownSWIerror
	ADR	r0,errMesg
	CMP	R0,#&80000000
	CMNVC	R0,#&80000000		; Set V
	MOV	PC,R14
errMesg

	DCD	&1E6
	= "Unknown SharedSound SWI",0
	ALIGN

	END

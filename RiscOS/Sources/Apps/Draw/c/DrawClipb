/* Copyright 2019 RISC OS Open Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* -> DrawClipb.c
 *
 * Clipboard handling
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Global/FileTypes.h"
#include "Global/Sprite.h"
#include "Interface/HighFSI.h"

#include "event.h"
#include "flex.h"
#include "msgs.h"
#include "os.h"
#include "werr.h"
#include "wimp.h"
#include "wimpt.h"
#include "xferrecv.h"
#include "help.h"
#include "drawmod.h"
#include "jpeg.h"
#include "swis.h"

#include "ftrace.h"
#include "guard.h"

#include "Draw.h"
#include "DrawDispl.h"
#include "DrawEdit.h"
#include "DrawEnter.h"
#include "DrawFileIO.h"
#include "DrawGrid.h"
#include "DrawMenu.h"
#include "DrawMenuD.h"
#include "DrawObject.h"
#include "DrawSelect.h"
#include "DrawTextC.h"
#include "DrawClipb.h"

/*Globals: current clipboard data if we have ownership*/
char *clipdata = NULL;
int cliplength = 0;
static BOOL draw_owns_clipboard = FALSE;

static BOOL draw_clipboard_openup(const char *name, int *handle)

{ os_regset  blk;

  blk.r[0] = 0x87; /*OpenOut, Ignore file$path, give err if a dir.!*/
  blk.r[1] = (int)name;

  if (wimpt_complain(os_find(&blk))) return FALSE;
  if (blk.r[0] == 0) { Error(FALSE, "FileO1"); return FALSE; }
  /*Incase the fileswitch bug returns a 0 handle*/
  *handle = blk.r[0];
  return TRUE;
}

static BOOL draw_clipboard_close(const char *name, int *handle, int filetype)

{ os_regset  blk;

  blk.r[0] = 0; blk.r[1] = *handle;
  if (wimpt_complain (os_find (&blk))) return FALSE;

  os_filestr osf;
  memset(&osf,0,sizeof(os_filestr));

  /*Set filetype*/
  osf.action = OSFile_SetType;
  osf.name = (char *)name;
  osf.loadaddr = filetype;
  if (wimpt_complain(os_file(&osf))) return FALSE;

  return TRUE;
}

static BOOL draw_clipboard_write_bytes(int handle, const char *buffer, int buffer_length)

{ os_regset blk;

  blk.r[0] = OSGBPB_WriteAtPTR;
  blk.r[1] = handle;
  blk.r[2] = (int)buffer;
  blk.r[3] = buffer_length;
  while (blk.r[3] > 0) { /*ensure we transfer all data if possible*/
    if (wimpt_complain(os_swix(OS_GBPB,&blk))) return FALSE;
  }

  return TRUE;
}

static BOOL draw_clipboard_extract_sprites(draw_objptr ptr, char **sprite_buffer, sprite_area *hdr, int *length)

{
  switch (ptr.objhdrp->tag) {
  case draw_OBJSPRITE:
    if (sprite_buffer) {
      if (FLEX_EXTEND((flex_ptr)sprite_buffer, hdr->freeoff + ptr.spritep->sprite.next - 4) == 0) {
        FLEX_FREE((flex_ptr)sprite_buffer);
        wimpt_complain(draw_make_oserror("DrawNR"));
        return FALSE;
      }

      memcpy(*sprite_buffer + hdr->freeoff - 4, &ptr.spritep->sprite, ptr.spritep->sprite.next);
      hdr->freeoff += ptr.spritep->sprite.next;
      hdr->number++;
    }
    if (length) *length += ptr.spritep->sprite.next;
    break;

  case draw_OBJTRFMSPRITE:
    if (sprite_buffer) {
      if (FLEX_EXTEND((flex_ptr)sprite_buffer, hdr->freeoff + ptr.trfmspritep->sprite.next - 4) == 0) {
        FLEX_FREE((flex_ptr)sprite_buffer);
        wimpt_complain(draw_make_oserror("DrawNR"));
        return FALSE;
      }

      memcpy(*sprite_buffer + hdr->freeoff - 4, &ptr.trfmspritep->sprite, ptr.trfmspritep->sprite.next);
      hdr->freeoff += ptr.trfmspritep->sprite.next;
      hdr->number++;
    }
    if (length) *length += ptr.trfmspritep->sprite.next;
    break;

  case draw_OBJGROUP:
    {
      int i;
      int start = sizeof(draw_groustr);
      int limit = ptr.objhdrp->size;
      draw_objptr objptr;

      for (i = start; i < limit; i += objptr.objhdrp->size) {
        objptr.bytep = ptr.bytep + i;
        draw_clipboard_extract_sprites(objptr, sprite_buffer, hdr, length);
      }
      break;
    }
  }

  return TRUE;
}

static BOOL draw_clipboard_write_spritefile(int handle, char *buffer, int buffer_length)

{ /*Iterate the selection and create a sprite area*/
  /*there may be 1+ sprites to export*/

  char *sprite_buffer = NULL; /*Buffer to hold our output*/
  BOOL result;
  sprite_area hdr;
  draw_objptr ptr;

  hdr.size    = 0;
  hdr.number  = 0;
  hdr.sproff  = SpriteAreaCBsize;
  hdr.freeoff = SpriteAreaCBsize;

  if (FLEX_ALLOC((flex_ptr)&sprite_buffer, SpriteAreaCBsize) == 0) {
    wimpt_complain(draw_make_oserror("DrawNR"));
    return FALSE;
  }

  for (ptr.bytep = buffer + sizeof(draw_fileheader);
       ptr.bytep < buffer + buffer_length;
       ptr.bytep += ptr.objhdrp->size) {
    if (!draw_clipboard_extract_sprites(ptr, &sprite_buffer, &hdr, 0)) {
      FLEX_FREE((flex_ptr)&sprite_buffer);
      return FALSE;
    }
  }

  /*Fill in the sprite header minus the first word (area length) as we're writing a file*/
  memcpy(sprite_buffer, &hdr.number, SpriteAreaCBsize - 4);

  result = draw_clipboard_write_bytes(handle, sprite_buffer, hdr.freeoff - 4);

  FLEX_FREE((flex_ptr)&sprite_buffer);

  return result;
}

static BOOL draw_clipboard_extract_text(draw_objptr ptr, char **text_buffer, int *text_length,
                                        int filehandle, BOOL *success)
{ switch (ptr.objhdrp->tag) {
  case draw_OBJTEXT:
    {
      int fragment_length = 1 + strlen(ptr.textp->text);
      if (text_buffer != NULL) {
        if (FLEX_EXTEND((flex_ptr)text_buffer, *text_length+fragment_length) == 0) {
          FLEX_FREE((flex_ptr)text_buffer);
          wimpt_complain(draw_make_oserror("DrawNR"));
          return FALSE;
        }

        memcpy(*text_buffer + *text_length, ptr.textp->text, fragment_length - 1);
        *(*text_buffer + *text_length + fragment_length - 1) = '\n';
      }
      if (text_length) {
        (*text_length) += fragment_length;
      }
      if (filehandle) {
        BOOL result = draw_clipboard_write_bytes(filehandle, ptr.textp->text, fragment_length);
        if (success) *success = result;
      }
    }
    break;

  case draw_OBJTRFMTEXT:
    {
      int fragment_length = 1 + strlen(ptr.trfmtextp->text);
      if (text_buffer != NULL) {
        if (FLEX_EXTEND((flex_ptr)text_buffer, *text_length + fragment_length) == 0) {
          FLEX_FREE((flex_ptr)text_buffer);
          wimpt_complain(draw_make_oserror("DrawNR"));
          return FALSE;
        }

        memcpy(*text_buffer + *text_length, ptr.trfmtextp->text, fragment_length - 1);
        *(*text_buffer + *text_length + fragment_length - 1) = '\n';
      }
      if (text_length) {
        (*text_length) += fragment_length;
      }
      if (filehandle) {
        BOOL result = draw_clipboard_write_bytes(filehandle, ptr.textp->text, fragment_length);
        if (success) *success = result;
      }
    }
    break;

  case draw_OBJTEXTAREA:
    {
      /*Skip the columns...*/
      draw_objptr textcol;
      for (textcol.bytep = ptr.bytep + sizeof(draw_objhdr);
           textcol.bytep < clipdata + cliplength && textcol.objhdrp->tag != 0;
           textcol.bytep += textcol.objhdrp->size) {
      }

      /*We are now pointing to the text area itself*/
      char *textptr = textcol.textareaendp->text;
      int fragment_length = 1 + strlen(textptr);

      if (text_buffer != NULL) {
        if (FLEX_EXTEND((flex_ptr)text_buffer, *text_length + fragment_length) == 0) {
          FLEX_FREE((flex_ptr)text_buffer);
          wimpt_complain(draw_make_oserror("DrawNR"));
          return FALSE;
        }

        memcpy(*text_buffer + *text_length, textptr, fragment_length - 1);
        *(*text_buffer + *text_length + fragment_length - 1) = '\n';
      }
      if (text_length) {
        (*text_length) += fragment_length;
      }
      if (filehandle) {
        BOOL result = draw_clipboard_write_bytes(filehandle, textptr, fragment_length);
        if (success) *success = result;
      }
    }
    break;

  case draw_OBJGROUP:
    /*Enter group and extract as well*/
    {
      int i;
      int start = sizeof(draw_groustr);
      int limit = ptr.objhdrp->size;
      draw_objptr objptr;
      for (i = start; i < limit; i += objptr.objhdrp->size) {
        objptr.bytep = ptr.bytep + i;
        draw_clipboard_extract_text(objptr, text_buffer, text_length, filehandle, success);
      }
    }
    break;
  }

  return TRUE;
}

static BOOL draw_clipboard_extract_jpeg(draw_objptr ptr, char **jpegptr, int *length, int filehandle, BOOL *success)

{ if (length != NULL) *length = 0;
  switch (ptr.objhdrp->tag) {
  case draw_OBJJPEG:
    {
      if (length != NULL) *length = ptr.jpegp->len;
      if (filehandle != 0) {
        BOOL result = draw_clipboard_write_bytes(filehandle, (char *)&ptr.jpegp->image, ptr.jpegp->len);
        if (success) *success = result;
      }
      if (jpegptr) *jpegptr = (char *)&ptr.jpegp->image;
    }
    return TRUE;

  case draw_OBJGROUP:
    /*Enter group and extract as well*/
    {
      int i;
      int start = sizeof(draw_groustr);
      int limit = ptr.objhdrp->size;
      draw_objptr objptr;
      for (i = start; i < limit; i += objptr.objhdrp->size) {
        objptr.bytep = ptr.bytep + i;
        if (draw_clipboard_extract_jpeg(objptr, jpegptr, length, filehandle, success))
          return TRUE; /*Bail out early if we've found a JPEG*/
      }
    }
  }
  return FALSE; /*No image found*/
}

static void draw_clipboard_export_ramxfer(wimp_eventstr *ev, int filetype, char *buffer, int buffer_length)

{ /*Determine the data buffer to send and then do it*/
  char *export_buffer = NULL;
  int export_length = 0;
  int export_offset = 0;
  BOOL export_needs_free = FALSE, abort = FALSE;

  switch (filetype) {
    case FileType_Draw:
      export_buffer = buffer;
      export_length = buffer_length;
      break;

    case FileType_Text:
      /*Generate a text file for export*/
      {
        draw_objptr ptr;
        if (FLEX_ALLOC((flex_ptr)&export_buffer, 4) == 0) {
          wimpt_complain(draw_make_oserror("DrawNR"));
          return;
        }

        for (ptr.bytep = buffer + sizeof(draw_fileheader);
             ptr.bytep < buffer + buffer_length;
             ptr.bytep += ptr.objhdrp->size) {
          if (!draw_clipboard_extract_text(ptr, &export_buffer, &export_length, 0, 0)) {
            FLEX_FREE((flex_ptr)&export_buffer);
            return;
          }
        }
        export_needs_free = TRUE;
      }
      break;

    case FileType_JPEG:
      /*Get the jpeg info and export*/
      {
        draw_objptr ptr;
        for (ptr.bytep = buffer + sizeof(draw_fileheader);
             ptr.bytep < buffer + buffer_length;
             ptr.bytep += ptr.objhdrp->size) {
          if (draw_clipboard_extract_jpeg(ptr, &export_buffer, &export_length, 0, 0))
            break;
        }
      }
      break;

    case FileType_Sprite:
      /*Make a sprite file for export*/
      {
        sprite_area hdr;
        draw_objptr ptr;

        hdr.size    = 0;
        hdr.number  = 0;
        hdr.sproff  = SpriteAreaCBsize;
        hdr.freeoff = SpriteAreaCBsize;

        export_length = SpriteAreaCBsize - 4; /* Header without the size entry */

        if (FLEX_ALLOC((flex_ptr)&export_buffer, SpriteAreaCBsize) == 0) {
          wimpt_complain(draw_make_oserror("DrawNR"));
          return;
        }

        for (ptr.bytep = buffer + sizeof(draw_fileheader);
             ptr.bytep < buffer + buffer_length;
             ptr.bytep += ptr.objhdrp->size) {
          if (!draw_clipboard_extract_sprites(ptr, &export_buffer, &hdr, &export_length)) {
            FLEX_FREE((flex_ptr)&export_buffer);
            return;
          }
        }

        /*Fill in the sprite header*/
        memcpy(export_buffer, &hdr.number, SpriteAreaCBsize - 4);
        export_needs_free = TRUE;
      }
      break;

    default:
      return; /*Shouldn't ever happen...*/
  }

  /*Run the export...*/
  while (export_offset <= export_length && !abort) {
    /*Send the requested amount of data (or less if necessary)*/
    BOOL messaged = FALSE;
    wimp_msgstr msg;
    int xfer_amount = ev->data.msg.data.ramfetch.nbytes;

    if (xfer_amount > (export_length-export_offset))
      xfer_amount=export_length-export_offset; /*Not too much though*/

    if (xfer_amount) wimp_transferblock(wimpt_task(), export_buffer + export_offset,
                                        ev->data.msg.hdr.task, ev->data.msg.data.ramfetch.addr,
                                        xfer_amount);

    memset(&msg,0,sizeof(wimp_msgstr));

    msg.hdr.size = sizeof(wimp_msghdr) + sizeof(wimp_msgramtransmit);
    msg.hdr.your_ref = ev->data.msg.hdr.my_ref;
    msg.hdr.action = wimp_MRAMTRANSMIT;
    msg.data.ramtransmit.addr = ev->data.msg.data.ramfetch.addr;
    msg.data.ramtransmit.nbyteswritten = xfer_amount;
    export_offset += xfer_amount;
    wimp_sendmessage(wimp_ESENDWANTACK, &msg, ev->data.msg.hdr.task);

    if (xfer_amount == 0) abort = TRUE;

    while (!messaged && !abort) {
      wimpt_poll(event_getmask(),ev);
      switch (ev->e) {
        case wimp_EACK:
          /*Bounced message; abort*/
          abort = TRUE;
          break;

        case wimp_ESENDWANTACK:
        case wimp_ESEND:
          /*We can send more stuff?*/
          if (ev->data.msg.hdr.action != wimp_MRAMFETCH)
            abort = TRUE;
          else
            messaged = TRUE;
          break;
      }
    }
  }

  /*Tidy up*/
  if (export_needs_free) {
    FLEX_FREE((flex_ptr)&export_buffer);
  }
}

void draw_clipboard_release(void)

{ /*Another task has claimed the clipboard*/
  draw_owns_clipboard = FALSE;
  if (clipdata != NULL) {
    FLEX_FREE((flex_ptr)&clipdata);
    clipdata   = NULL;
    cliplength = 0;
  }
}

void draw_clipboard_claim(int claimtype)

{ /*Claimtype is as per the Wimp Message*/
  if (!draw_owns_clipboard) {
    wimp_msgstr msg;

    memset(&msg, 0, sizeof(wimp_msgstr));
    msg.hdr.size   = 24;
    msg.hdr.action = wimp_MCLAIMENTITY;
    msg.data.claimentity.flags = claimtype;
    wimp_sendmessage(wimp_ESEND, &msg, 0);

    if ((claimtype & wimp_MCLAIMENTITY_flags_clipboard) != 0) {
      draw_owns_clipboard = TRUE;
    }
  }
}

static int draw_clipboard_send_datarequest(wimp_eventstr *e)

{ /*Request from other tasks*/
  wimp_msgstr msg;
  int *types;

  memset(&msg, 0, sizeof(wimp_msgstr));
  msg.hdr.size   = 20 + (5 * sizeof(int)) + sizeof(wimp_msghdr);
  msg.hdr.action = wimp_MDATAREQUEST;
  msg.data.datarequest.w = 0;
  msg.data.datarequest.h = &clipdata;
  msg.data.datarequest.x = 0;
  msg.data.datarequest.y = 0;
  msg.data.datarequest.flags = wimp_MDATAREQUEST_flags_clipboard;

  types = msg.data.datarequest.types;
  types[0] = FileType_Draw;
  types[1] = FileType_Sprite;
  types[2] = FileType_JPEG;
  types[3] = FileType_Text;
  types[4] = wimp_MDATAREQUEST_types_end;

  wimp_sendmessage(wimp_ESENDWANTACK, &msg, 0);

  /*We either get back a datasave or a bounce*/
  while (1) {
    wimpt_poll(event_getmask(), e);
    switch (e->e) {
    case wimp_EACK:
      if (e->data.msg.hdr.action == wimp_MDATAREQUEST) {
        /*Bounced message - no data on clipboard to paste*/
        return 0;
      }
      break;

    case wimp_ESEND:
    case wimp_ESENDWANTACK:
      if (e->data.msg.hdr.action==wimp_MDATASAVE) {
        /*Check the filetypes supported*/
        switch (e->data.msg.data.datasave.type) {
          case FileType_Draw:
          case FileType_Sprite:
          case FileType_JPEG:
          case FileType_Text:
            return 1;

          default:
            return 0;
        }
      }
      break;
    }
  }

  return 0;
}

int draw_clipboard_check_paste(void)

{ wimp_eventstr e;

  /*See if there's anything on the clipboard for pasting*/
  if (draw_owns_clipboard) return 1; /*Quick check*/

  return draw_clipboard_send_datarequest(&e);
}

void draw_clipboard_paste(diagrec *diag, viewrec *vuue)

{ /*Paste clipboard data into document*/
  wimp_mousestr mouse;
  draw_objcoord org, mouseD;
  wimp_wstate   r;
  wimp_eventstr e;

  /*Get destination pointer location*/
  wimp_get_point_info(&mouse);
  wimp_get_wind_state(vuue->w, &r);
  draw_displ_scalefactor = vuue->zoomfactor;

  draw_make_origin(&org, &r.o.box, &r.o.x);
  draw_point_scale(&mouseD, (draw_objcoord *)&mouse.x, &org);

  /*Gravitate to grid position*/
  draw_grid_snap_if_locked(vuue, &mouseD);

  /*Get location to paste*/
  /*We either just do an internal copy, or pull from external clipboard task*/
  if (draw_owns_clipboard) {
    /*Internal action*/
    if (draw_selection->owner == diag) {
      draw_select_delete(draw_selection->owner);
    }

    draw_file_loadfile(diag, vuue, msgs_lookup("FileSe"), FileType_Draw, cliplength, via_CLIPBOARD_INT, &mouseD);
    return;
  }

  /*Request from external clipboard task*/
  /*Request data from clipboard...*/
  if (0 == draw_clipboard_send_datarequest(&e)) return; /*Message was bounced, oddly*/

  /*Success. Delete any existing selection (as it gets replaced) if we're pasting into the same diagram*/
  if (draw_selection->owner == diag) {
    draw_select_delete(draw_selection->owner);
  }

  /*Now e contains the datasave reply, pass to Draw's normal data import function*/
  draw_load_file(diag, vuue, &mouseD, FALSE);
}

void draw_clipboard_claimed(wimp_eventstr *e)

{ /*Claimed...*/
  if (e->data.msg.hdr.task == wimpt_task()) return; /*Was us!*/

  draw_clipboard_release();
}

static int draw_clip_length(char *buffer, int buffer_length, int filetype)

{ /*Determine actual export data length for a given filetype and data block*/
  switch (filetype) {
    case FileType_Draw:
      return buffer_length;

    case FileType_Sprite:
      {
        draw_objptr ptr;
        int length = sizeof(sprite_area);
        for (ptr.bytep = buffer + sizeof(draw_fileheader);
             ptr.bytep < buffer + buffer_length;
             ptr.bytep += ptr.objhdrp->size) {
          draw_clipboard_extract_sprites(ptr, 0, 0, &length);
        }
        return length;
      }

    case FileType_JPEG:
      {
        draw_objptr ptr;
        int length = 0;
        for (ptr.bytep = buffer + sizeof(draw_fileheader);
             ptr.bytep < buffer + buffer_length;
             ptr.bytep += ptr.objhdrp->size) {
           if (draw_clipboard_extract_jpeg(ptr, 0, &length, 0, 0) == 1)
             return length;
        }
      }
      return 0;

    case FileType_Text:
      {
        draw_objptr ptr;
        int length = 0;
        for (ptr.bytep = buffer + sizeof(draw_fileheader);
             ptr.bytep < buffer + buffer_length;
             ptr.bytep += ptr.objhdrp->size) {
          draw_clipboard_extract_text(ptr, 0, &length, 0, 0);
        }
        return length;
      }
  }

  return 0; /*Unidentified export*/
}

static void draw_clipboard_export_file(wimp_eventstr *ev, char *buffer, int buffer_length)

{ /*Export data to file and then issue DATALOAD*/
  int handle;
  BOOL success = FALSE;
  wimp_msgstr msg;

  if (!draw_clipboard_openup(ev->data.msg.data.datasaveok.name, &handle))
    return; /*Error already reported; bail out*/

  /*Spool data*/
  switch (ev->data.msg.data.datasaveok.type) {
    case FileType_Draw:
      /*Write bytes and done*/
      success = draw_clipboard_write_bytes(handle, buffer, buffer_length);
      break;

    case FileType_Sprite:
      success = draw_clipboard_write_spritefile(handle, buffer, buffer_length);
      break;

    case FileType_JPEG:
      {
        draw_objptr ptr;

        for (ptr.bytep = buffer + sizeof(draw_fileheader);
             ptr.bytep < buffer + buffer_length;
             ptr.bytep += ptr.objhdrp->size) {
          if (draw_clipboard_extract_jpeg(ptr, 0, 0, handle, &success))
            break;
        }
      }
      break;

    case FileType_Text:
      {
        draw_objptr ptr;

        for (ptr.bytep = buffer + sizeof(draw_fileheader);
             ptr.bytep < buffer + buffer_length;
             ptr.bytep += ptr.objhdrp->size) {
          draw_clipboard_extract_text(ptr, 0, 0, handle, &success);
        }
      }
      break;
  }

  if (success) {
    success = draw_clipboard_close(ev->data.msg.data.datasaveok.name, &handle, ev->data.msg.data.datasaveok.type);
  }
  if (!success) return; /*Failed to write data*/

  /*Issue dataload*/
  memset(&msg, 0, sizeof(wimp_msgstr));
  msg.hdr.action = wimp_MDATALOAD;
  msg.hdr.size     = 256;
  msg.hdr.your_ref = ev->data.msg.hdr.my_ref;
  msg.data.dataload.w = ev->data.msg.data.datasaveok.w; /*Target window*/
  msg.data.dataload.i = ev->data.msg.data.datasaveok.i; /*Target icon*/
  msg.data.dataload.x = ev->data.msg.data.datasaveok.x; /*Target coords in target window work area*/
  msg.data.dataload.y = ev->data.msg.data.datasaveok.y;
  msg.data.dataload.size = buffer_length;
  msg.data.dataload.type = ev->data.msg.data.datasaveok.type; /*Type of file*/
  strcpy(msg.data.dataload.name, ev->data.msg.data.dataload.name);

  wimp_sendmessage(wimp_ESENDWANTACK, &msg, ev->data.msg.hdr.task); /*Return to destination task*/
}

void draw_clipboard_rx_datarequest(wimp_eventstr *e)

{ int mask;
  draw_objptr ptr;
  wimp_msgstr msg;

  /*Can we service this?*/
  if (!draw_owns_clipboard) return; /*We don't have anything to shout about*/
  if (e->data.msg.data.datarequest.flags != wimp_MDATAREQUEST_flags_clipboard)
    return; /*Unknown flags, bail out*/

  /*See what filetypes we support in the current selection block*/
  mask = _tm_draw;
  ptr.bytep = clipdata + sizeof(draw_fileheader);
  draw_file_typemask(ptr, &mask);

  /*Send a datasave with a matching mask*/
  memset(&msg,0,sizeof(wimp_msgstr));
  msg.hdr.size = sizeof(wimp_msghdr) + 44;
  msg.hdr.your_ref = e->data.msg.hdr.my_ref;
  msg.hdr.action = wimp_MDATASAVE;

  msg.data.datasave.w = e->data.msg.data.datarequest.w;
  msg.data.datasave.i = (int)e->data.msg.data.datarequest.h;
  msg.data.datasave.x = e->data.msg.data.datarequest.x;
  msg.data.datasave.y = e->data.msg.data.datarequest.y;

  /*See what type we can negotiate.  List is in sender's message*/
  int i;
  int negotiated_type = 0;
  int *listptr = &e->data.msg.data.datarequest.types[0]; /*Else we we get out of bounds warnings*/
  for (i = 0;
       i < (256 - 24 - sizeof(wimp_msghdr)) / sizeof(int) &&
       *(listptr + i) != wimp_MDATAREQUEST_types_end &&
       negotiated_type == 0;
       i++) {
    switch (*(listptr+i)) {
      case FileType_Draw:
        negotiated_type = FileType_Draw;
        break;

      case FileType_Sprite:
        if ((mask & _tm_sprite) != 0) {
          negotiated_type = FileType_Sprite;
        }
        break;

      case FileType_JPEG:
        if ((mask & _tm_jpeg) != 0) {
          negotiated_type = FileType_JPEG;
        }
        break;

      case FileType_Text:
        if ((mask & _tm_text) != 0) {
          negotiated_type = FileType_Text;
        }
        break;
    }
  }

  if (negotiated_type == 0) {
    return; /*Nothing agreed, clear out*/
  }

  /*Determine length of data we'll be exporting now we know the file type (may*/
  /*be shorter than this if we export a subselection)*/
  msg.data.datasave.estsize = draw_clip_length(clipdata, cliplength, negotiated_type);
  msg.data.datasave.type = negotiated_type;
  strcpy(msg.data.datasave.leaf, msgs_lookup("FileSe"));

  wimp_sendmessage(wimp_ESENDWANTACK, &msg, e->data.msg.hdr.task);

  /*See if we get a reply...*/
  wimp_eventstr ev;
  BOOL complete = FALSE;
  while (!complete) {
    wimpt_poll(event_getmask(), &ev);

    switch (ev.e) {
    case wimp_EACK:
      if (ev.data.msg.hdr.action == wimp_MDATASAVE) {
        /*Bounced message - no data on clipboard to paste, just bail out*/
        return;
      }
      break;

    case wimp_ESEND:
    case wimp_ESENDWANTACK:
      complete = TRUE;
      switch (ev.data.msg.hdr.action) {
        case wimp_MDATASAVEOK: /*File xfer*/
          draw_clipboard_export_file(&ev, clipdata, cliplength);
          break;

        case wimp_MRAMFETCH: /*Memory xfer*/
          draw_clipboard_export_ramxfer(&ev,negotiated_type,clipdata,cliplength);
          break;
      }
      break;
    }
  }
}

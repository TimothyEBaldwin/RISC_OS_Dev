/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* ScrModes.c */

/*
 * ScreenModes module main code.
 */

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>
#include <stdbool.h>

#include "kernel.h"
#include "swis.h"
#include "Global/RISCOS.h"
#include "Global/GraphicsV.h"
#include "Global/Services.h"
#include "Global/VduExt.h"
#include "Global/VIDCList.h"
#include "Interface/ScrModes.h"

#include "EDIDModes.h"

/* Locally defined but actually global values */
#include "ScrModesv.h"
#include "errors.h"
#include "monitors.h"
#include "modex.h"

/* By default we only use DMT timings; we will check for additional support later */
static int timing_support = EDID_USE_DMT;

/* If the below flag is set, we can derive monitor definitions from the
 * DMT set using the 3-byte lookup table (defaulted to 'unset')
 */
//#define DERIVE_CVT3_FROM_DMT

#ifndef DODEBUG
#define DODEBUG 0
#endif

/* switch to define whether EDID is computed, or whether only traditional *
 * loadmodefile activity happens. EDID activity enabled by a ReadEDID     *
 * command, and disabled by a LoadModeFile command                        */
static bool EDIDEnabled;

/* Uncomment the next line and set the value to force a particular timing calculation type */
//#define FORCE_TIMINGS EDID_USE_CVTRB


/* Uncomment the below to force calculated values (ie. don't prefer DMT) */
//#define FORCE_CALCULATED_VALUES

/*
 * Tweak to force the keyword table to be stored in the code area, by
 * making it all into a single char array including embedded NULs to
 * terminate individual entries.  We trust the compiler to spot the
 * multiple (2) source instances of this string constant and arrange to
 * use a single copy of it.
 */
#define keywordset     \
    "x_res\0         " \
    "y_res\0         " \
    "h_timings\0     " \
    "v_timings\0     " \
    "pixel_rate\0    " \
    "sync_pol\0      " \
    "external_clock\0" \
    "mode_name\0     " \
    "file_format\0   " \
    "monitor_title\0 " \
    "dpms_state\0    " \
    "lcd_support\0   " \
    "interlaced\0    " \
    "output_format\0 " \
    "startmode\0     " \
    "endmode"
#define MAXKEYWORDLEN 14
#define keyword(n) (keywordset + ((n) * (MAXKEYWORDLEN+1)))

#define HSync_Positive 0
#define HSync_Negative SyncPol_InvertHSync
#define VSync_Positive 0
#define VSync_Negative SyncPol_InvertVSync

/* HSync & VSync polarities for use by display_monitor_timings */
#define PP HSync_Positive+VSync_Positive
#define PN HSync_Positive+VSync_Negative
#define NP HSync_Negative+VSync_Positive
#define NN HSync_Negative+VSync_Negative

/* These timings are taken from the Display Monitor Timings v1.0 r11 Spec */

static const ModeDefinition display_monitor_timings[] = {
    /* 640 x 350 @ 85Hz STD n/a, CVT n/a */
    "640 x 350",    640, 350,   64,  96, 0,  640, 0, 32,
                                 3,  60, 0,  350, 0, 32,
                    31500, -1,  PN,   0, 85,   0,
    /* 640 x 400 @ 85Hz STD n/a, CVT n/a */
    "640 x 400",    540, 400,   64,  96, 0,  640, 0, 32,
                                 3,  41, 0,  400, 0,  1,
                    31500, -1,  NP,   0, 85,   0,
    /* 720 x 400 @ 85Hz STD n/a, CVT n/a */
    "720 x 400",    720, 400,   72, 108, 0,  720, 0, 36,
                                 3,  42, 0,  400, 0,  1,
                    35500, -1,  NP,   0, 85,   0,
    /* 640 x 480 @ 60Hz, STD (31, 40)h, CVT n/a */
    "640 x 480",    640, 480,   96,  40, 8,  640, 8,  8,
                                 2,  25, 8,  480, 8,  2,
                    25175, -1,  NN,   0, 60,   0,
    /* 640 x 480 @ 72Hz, STD (31, 4C), CVT n/a */
    "640 x 480",    640, 480,   40, 120, 8,  640, 8, 16,
                                 3,  20, 8,  480, 8,  1,
                    31500, -1,  NN,   0, 72,   0,
    /* 640 x 480 @ 75Hz, STD (31, 4F), non-CVT com */
    "640 x 480",    640, 480,   64, 120, 0,  640, 0, 16,
                                 3,  16, 0,  480, 0,  1,
                    31500, -1,  NN,   0, 75,   0,
    /* 640 x 480 @ 85Hz, STD (31, 59), non-CVT compliant */
    "640 x 480",    640, 480,   56,  80, 0,  640, 0, 56,
                                 3,  25, 0,  480, 0,  1,
                    36000, -1,  NN,   0, 85,   0,
    /* 800 x 600 @ 56Hz, STD n/a, CVT n/a */
    "800 x 600",    800, 600,   72, 128, 0,  800, 0, 24,
                                 2,  22, 0,  600, 0,  1,
                    36000, -1,  PP,   0, 56,   0,
    /* 800 x 600 @ 60Hz, STD (45, 50), CVT n/a */
    "800 x 600",    800, 600,  128,  88, 0,  800, 0, 40,
                                 4,  23, 0,  600, 0,  1,
                    40000, -1,  PP,   0, 60,   0,
    /* 800 x 600 @ 72Hz, STD (45, 4C), CVT n/a */
    "800 x 600",    800, 600,  120,  64, 0,  800, 0, 56,
                                 6,  23, 0,  600, 0, 37,
                    50000, -1,  PP,   0, 72,   0,
    /* 800 x 600 @ 75Hz, STD (45, 4F), CVT n/a */
    "800 x 600",    800, 600,   80, 160, 0,  800, 0, 16,
                                 3,  21, 0,  600, 0,  1,
                    49500, -1,  PP,   0, 75,   0,
    /* 800 x 600 @ 85Hz, STD (45, 59), CVT n/a */
    "800 x 600",    800, 600,   64, 152, 0,  800, 0, 32,
                                 3,  27, 0,  600, 0,  1,
                    56250, -1,  PP,   0, 85,   0,
    /* 800 x 600 @ 120Hz CVT (RB), STD n/a, CVT n/a */
    "800 x 600",    800, 600,   32,  80, 0,  800, 0, 48,
                                 4,  29, 0,  600, 0,  3,
                    73250, -1,  PN,   0, 120,  0,
    /* 848 x 480 @ 60Hz, STD n/a, CVT n/a */
    "848 x 480",    848, 480,  112, 112, 0,  848, 0, 16,
                                 8,  23, 0,  480, 0,  6,
                    33750, -1,  PP,   0, 60,   0,
    /* 1024 x 768 @ 43Hz (I), STD n/a, CVT n/a */
    "1024 x 768",  1024, 768,  176,  56, 0, 1024, 0,  8,
                                 4,  20, 0,  384, 0,  0,
                    44900, -1,  PP,   1, 43,   0,
    /* 1024 x 768 @ 60Hz, STD (61, 40), CVT n/a */
    "1024 x 768",  1024, 768,  136, 160, 0, 1024, 0, 24,
                                 6,  29, 0,  768, 0,  3,
                    65000, -1,  NN,   0, 60,   0,
    /* 1024 x 768 @ 70Hz, STD (61, 4A), CVT n/a */
    "1024 x 768",  1024, 768,  136, 144, 0, 1024, 0, 24,
                                 6,  29, 0,  768, 0,  3,
                    75000, -1,  NN,   0, 70,   0,
    /* 1024 x 768 @ 75Hz, STD (61, 4F), CVT n/a */
    "1024 x 768",  1024, 768,   96, 176, 0, 1024, 0, 16,
                                 3,  28, 0,  768, 0,  1,
                    78750, -1,  PP,   0, 75,   0,
    /* 1024 x 768 @ 85Hz, STD (61, 59), CVT n/a */
    "1024 x 768",  1024, 768,   96, 208, 0, 1024, 0, 48,
                                 3,  36, 0,  768, 0,  1,
                    94500, -1,  PP,   0, 85,   0,
    /* 1024 x 768 @ 120Hz CVT (RB), STD n/a, CVT n/a */
    "1024 x 768",  1024, 768,   32,  80, 0, 1024, 0, 48,
                                 4,  38, 0,  768, 0,  3,
                   115500, -1,  PN,   0, 120,  0,
    /* 1152 x 864 @ 75Hz, STD (71, 4F), CVT n/a */
    "1152 x 864",  1152, 864,  128, 256, 0, 1152, 0, 64,
                                 3,  32, 0,  864, 0,  1,
                   108000, -1,  PP,   0, 75,   0,
    /* 1280 x 768 @ 60Hz, STD n/a, CVT-RB (7f, 1c, 21) */
    "1280 x 768",  1280, 768,   32,  80, 0, 1280, 0, 48,
                                 7,  12, 0,  768, 0,  3,
                    68250, -1,  PN,   0, 60,   0,
    /* 1280 x 768 @ 60Hz, STD n/a, CVT (7f, 1c, 28) */
    "1280 x 768",  1280, 768,  128, 192, 0, 1280, 0, 64,
                                 7,  20, 0,  768, 0,  3,
                    79500, -1,  NP,   0, 60,   0,
    /* 1280 x 768 @ 75Hz, STD n/a, CVT (7f, 1c, 44) */
    "1280 x 768",  1280, 768,  128, 208, 0, 1280, 0, 80,
                                 7,  27, 0,  768, 0,  3,
                   102250, -1,  NP,   0, 75,   0,
    /* 1280 x 768 @ 85Hz, STD n/a, CVT (7F, 1c, 62) */
    "1280 x 768",  1280, 768,  136, 216, 0, 1280, 0, 80,
                                 7,  31, 0,  768, 0,  3,
                   117500, -1,  NP,   0, 85,   0,
    /* 1280 x 768 @ 120Hz RB, STD n/a, CVT n/a (non-interlaced) */
    "1280 x 768",  1280, 768,   32,  80, 0, 1280, 0, 48,
                                 7,  35, 0,  768, 0,  3,
                   140250, -1,  PN,   0, 120,  0,
    /* 1280 x 800 @ 60Hz, STD n/a, CVT-RB (8f, 18, 21) */
    "1280 x 800",  1280, 800,   32,  80, 0, 1280, 0, 48,
                                 6,  14, 0,  800, 0,  3,
                    71000, -1,  PN,   0, 60,   0,
    /* 1280 x 800 @ 60Hz, STD (81, 00), CVT (8f, 18, 28) */
    "1280 x 800",  1280, 800,  128, 200, 0, 1280, 0, 72,
                                 6,  22, 0,  800, 0,  3,
                    83500, -1,  NP,   0, 60,   0,
    /* 1280 x 800 @ 75Hz, STD (81, 0f), CVT (8f, 18, 44) */
    "1280 x 800",  1280, 800,  128, 208, 0, 1280, 0, 80,
                                 6,  29, 0,  800, 0,  3,
                   106500, -1,  NP,   0, 75,   0,
    /* 1280 x 800 @ 85Hz, STD (81, 19), CVT (8f, 18, 62) */
    "1280 x 800",  1280, 800,  136, 216, 0, 1280, 0, 80,
                                 6,  34, 0,  800, 0,  3,
                   122500, -1,  NP,   0, 85,   0,
    /* 1280 x 800 @ 120Hz RB, STD n/a, CVT n/a (non-interlaced) */
    "1280 x 800",  1280, 800,   32,  80, 0, 1280, 0, 48,
                                 6,  38, 0,  800, 0,  3,
                   146250, -1,  PN,   0, 120,  0,
    /* 1280 x 960 @ 60Hz, STD (81, 40), CVT n/a */
    "1280 x 960",  1280, 960,  112, 312, 0, 1280, 0, 96,
                                 3,  36, 0,  960, 0,  1,
                   108000, -1,  PP,   0, 60,   0,
    /* 1280 x 960 @ 85Hz, STD (81, 59), CVT n/a */
    "1280 x 960",  1280, 960,  160, 224, 0, 1280, 0, 64,
                                 3,  47, 0,  960, 0,  1,
                   148500, -1,  PP,   0, 85,   0,
    /* 1280 x 960 @ 120Hz RB, STD n/a, CVT n/a */
    "1280 x 960",  1280, 960,   32,  80, 0, 1280, 0, 48,
                                 4,  50, 0,  960, 0,  3,
                   175500, -1,  PN,   0, 120,  0,
    /* 1280 x 1024 @ 60Hz, STD n/a, CVT n/a */
    "1280 x 1024", 1280, 1024, 112, 248, 0, 1280, 0, 48,
                                 3,  38, 0, 1024, 0,  1,
                   108000, -1,  PP,   0, 60,   0,
    /* 1280 x 1024 @ 75Hz, STD (81, 8f), CFT n/a */
    "1280 x 1024", 1280, 1024, 144, 248, 0, 1280, 0, 16,
                                 3,  38, 0, 1024, 0,  1,
                   135000, -1,  PP,   0, 75,   0,
    /* 1280 x 1024 @ 85Hz, STD (81, 99), CVT n/a */
    "1280 x 1024", 1280, 1024, 160, 224, 0, 1280, 0, 64,
                                 3,  44, 0, 1024, 0,  1,
                   157500, -1,  PP,   0, 85,   0,
    /* 1280 x 1024 @ 120Hz (RB), STD n/a, CVT n/a */
    "1280 x 1024", 1280, 1024,  32,  80, 0, 1280, 0, 48,
                                 7,  50, 0, 1024, 0,  3,
                   187250, -1,  PN,   0, 120, 0,
    /* 1360 x 768 @ 60Hz, STD n/a, CVT n/a */
    "1360 x 768",  1360,  768, 112, 256, 0, 1360, 0, 64,
                                 6,  18, 0,  768, 0,  3,
                    85500, -1,  PP,   0, 60, 0,
    /* 1360 x 768 @ 120Hz (RB), STD n/a, CVT n/a */
    "1360 x 768",  1360,  768,  32,  80, 0, 1360, 0, 48,
                                 5,  37, 0,  768, 0,  3,
                   148250, -1,  PN,   0, 120, 0,
    /* 1400 x 1050 @ 60Hz CVT (RB), STD n/a, CVT (0c, 20, 21) */
    "1400 x 1050", 1400, 1050,  32,  80, 0, 1400, 0, 48,
                                 4,  23, 0, 1050, 0,  3,
                   101000, -1,  PN,   0, 60, 0,
    /* 1400 x 1050 @ 60Hz, STD (90, 40), CVT (0c, 20, 28) */
    "1400 x 1050", 1400, 1050, 144, 232, 0, 1400, 0, 88,
                                 4,  32, 0, 1050, 0, 3,
                   121750, -1,  NP,   0, 60, 0,
    /* 1400 x 1050 @ 75Hz, STD (90, 4f), CVT (0c, 20, 44) */
    "1400 x 1050", 1400, 1050, 144, 248, 0, 1400, 0, 104,
                                 4,  42, 0, 1050, 0, 3,
                   156000, -1,  NP,   0, 75, 0,
    /* 1400 x 1050 @ 85Hz, STD (90, 59), CVT (0c, 20, 62) */
    "1400 x 1050", 1400, 1050, 152, 256, 0, 1400, 0, 104,
                                 4,  48, 0, 1050, 0, 3,
                   179500, -1,  NP,   0, 85, 0,
    /* 1400 x 1050 @ 120Hz CVT (RB), STD n/a, CVT n/a */
    "1400 x 1050", 1400, 1050,  32,  80, 0, 1400, 0, 48,
                                 4,  55, 0, 1050, 0, 3,
                   208000, -1,  PN,   0, 120, 0,
    /* 1440 x 900 @ 60Hz CVT (RB), STD n/a, CVT (c1, 18, 21) */
    "1440 x 900",  1440,  900,  32,  80, 0, 1440, 0, 48,
                                 6,  17, 0,  900, 0, 3,
                   88750, -1,   PN,   0, 60, 0,
    /* 1440 x 900 @ 60Hz, STD (95,00), CVT (C1, 18, 28) */
    "1440 x 900",  1440,  900, 152, 232, 0, 1440, 0, 80,
                                 6,  25, 0,  900, 0, 3,
                  106500, -1,   NP,   0, 60, 0,
    /* 1440 x 900 @ 75Hz, STD (95,0f), CVT (C1, 18, 44) */
    "1440 x 900",  1440,  900, 152, 248, 0, 1440, 0, 96,
                                 6,  33, 0,  900, 0, 3,
                  136750, -1,   NP,   0, 75, 0,
    /* 1440 x 900 @ 85Hz, STD (95,19), CVT (C1, 18, 68) */
    "1440 x 900",  1440,  900, 152, 256, 0, 1440, 0, 104,
                                 6,  39, 0,  900, 0, 3,
                  157000, -1,   NP,   0, 85, 0,
    /* 1440 x 900 @ 120Hz RB, STD n/a, CVT n/a, */
    "1440 x 900",  1440,  900,  32,  80, 0, 1440, 0, 48,
                                 6,  44, 0,  900, 0, 3,
                  182750, -1,   PN,   0, 120, 0,
    /* 1600 x 1200 @ 60Hz, STD (a9, 40), CVT n/a */
    "1600 x 1200", 1600, 1200, 192, 304, 0, 1600, 0, 64,
                                 3,  46, 0, 1200, 0, 1,
                  162000, -1,   PP,   0, 60, 0,
    /* 1600 x 1200 @ 65Hz, STD (a9,45), CVT n/a */
    "1600 x 1200", 1600, 1200, 192, 304, 0, 1600, 0, 64,
                                 3,  46, 0, 1200, 0, 1,
                  175500, -1,   PP,   0, 65, 0,
    /* 1600 x 1200 @ 70Hz, STD (a9,4a), CVT n/a */
    "1600 x 1200", 1600, 1200, 192, 304, 0, 1600, 0, 64,
                                 3,  46, 0, 1200, 0, 1,
                  189000, -1,   PP,   0, 70, 0,
    /* 1600 x 1200 @ 75Hz, STD (a9,4f), CVT n/a */
    "1600 x 1200", 1600, 1200, 192, 304, 0, 1600, 0, 64,
                                 3,  46, 0, 1200, 0, 1,
                  202500, -1,   PP,   0, 75, 0,
    /* 1600 x 1200 @ 85Hz, STD (a9,59), CVT n/a */
    "1600 x 1200", 1600, 1200, 192, 304, 0, 1600, 0, 64,
                                 3,  46, 0, 1200, 0, 1,
                  229500, -1,   PP,   0, 85, 0,
    /* 1600 x 1200 @ 120Hz, STD n/a, CVT n/a */
    "1600 x 1200", 1600, 1200,  32,  80, 0, 1600, 0, 48,
                                 4,  64, 0, 1200, 0, 3,
                  268250, -1,   PN,   0, 120, 0,
    /* 1680 x 1050 @ 60Hz CVT (RB), STD n/a, CVT (0c, 28, 21) */
    "1680 x 1050", 1680, 1050,  32,  80, 0, 1680, 0, 48,
                                 6,  21, 0, 1050, 0, 3,
                  119000, -1,   PN,   0, 60, 0,
    /* 1680 x 1050 @ 60Hz, STD (b3, 00), CVT (0c, 28, 28) */
    "1680 x 1050", 1680, 1050, 176, 280, 0, 1680, 0, 104,
                                 6,  30, 0, 1050, 0, 3,
                  146250, -1,   NP,   0, 60, 0,
    /* 1680 x 1050 @ 75Hz, STD (b3, 0f), CVT (0c, 28, 44) */
    "1680 x 1050", 1680, 1050, 176, 296, 0, 1680, 0, 120,
                                 6,  40, 0, 1050, 0, 3,
                  187000, -1,   NP,   0, 75, 0,
    /* 1680 x 1050 @ 85Hz, STD (b3, 19), CVT (0c, 2c, 68) */
    "1680 x 1050", 1680, 1050, 176, 304, 0, 1680, 0, 128,
                                 6,  46, 0, 1050, 0, 3,
                  214750, -1,   NP,   0, 85, 0,
    /* 1680 x 1050 @ 120Hz CVT-RN. STD n/a, CVT n/a */
    "1680 x 1050", 1680, 1050,  32,  80, 0, 1680, 0, 48,
                                 6,  53, 0, 1050, 0, 3,
                  245500, -1,   PN,   0, 120, 0,
    /* 1792 x 1344 @ 60Hz, STD (c1, 40), CVT n/a */
    "1792 x 1344", 1792, 1344, 200, 328, 0, 1792, 0, 128,
                                 3,  46, 0, 1344, 0, 1,
                  204750, -1,   NP,   0, 60, 0,
    /* 1792 x 1344 @ 75Hz, STD (c1, 4f), CVT n/a */
    "1792 x 1344", 1792, 1344, 216, 352, 0, 1792, 0, 96,
                                 3,  69, 0, 1344, 0, 1,
                  261000, -1,   NP,   0, 75, 0,
    /* 1792 x 1344 @ 120Hz CVT-RB, STD n/a, CVT n/a */
    "1792 x 1344", 1792, 1344,  32,  80, 0, 1792, 0, 48,
                                 4,  72, 0, 1344, 0, 3,
                  333250, -1,   PN,   0, 120, 0,
    /* 1856 x 1392 @ 60Hz, STD (c9, 40), CVT n/a */
    "1856 x 1392", 1856, 1392, 224, 352, 0, 1856, 0, 96,
                                 3,  43, 0, 1392, 0, 1,
                  218250, -1,   NP,   0, 60, 0,
    /* 1856 x 1392 @ 75Hz, STD (c9, 4f), CVT n/a */
    "1856 x 1392", 1856, 1392, 224, 352, 0, 1856, 0, 128,
                                 3, 104, 0, 1392, 0, 1,
                  288000, -1,   NP,   0, 75, 0,
    /* 1856 x 1392 @ 120Hz CVT-RB, STD n/a, CVT n/a */
    "1856 x 1392", 1856, 1392,  32,  80, 0, 1856, 0, 48,
                                 4,  75, 0, 1392, 0, 3,
                  356500, -1,   PN,   0, 120, 0,
    /* 1920 x 1200 @ 60Hz RB, STD n/a, CVT (57,28,21) */
    "1920 x 1200", 1920, 1200,  32,  80, 0, 1920, 0, 48,
                                 6,  26, 0, 1200, 0, 3,
                  154000, -1,   PN,   0, 60, 0,
    /* 1920 x 1200 @ 60Hz, STD (d1, 00), CVT (57, 28, 28) */
    "1920 x 1200", 1920, 1200, 200, 336, 0, 1920, 0, 136,
                                 6,  36, 0, 1200, 0, 3,
                  193250, -1,   NP,   0, 60, 0,
    /* 1920 x 1200 @ 75Hz, STD (d1, 0f), CVT (57, 28, 44) */
    "1920 x 1200", 1920, 1200, 208, 344, 0, 1920, 0, 136,
                                 6,  46, 0, 1200, 0, 3,
                  245250, -1,   NP,   0, 75, 0,
    /* 1920 x 1200 @ 85Hz, STD (d1, 19), CVT (57, 28, 62) */
    "1920 x 1200", 1920, 1200, 208, 352, 0, 1920, 0, 144,
                                 6,  53, 0, 1200, 0, 3,
                  281250, -1,   NP,   0, 85, 0,
    /* 1920 x 1200 @ 120Hz CVT-RB, STD n/a, CVT n/a */
    "1920 x 1200", 1920, 1200,  32,  80, 0, 1920, 0, 48,
                                 6,  62, 0, 1200, 0, 3,
                  317000, -1,   PN,   0, 120, 0,
    /* 1920 x 1440 @ 60Hz, STD (d1, 40), CVT n/a */
    "1920 x 1440", 1920, 1440, 208, 344, 0, 1920, 0, 128,
                                 3,  56, 0, 1440, 0, 1,
                  234000, -1,   NP,   0, 60, 0,
    /* 1920 x 1440 @ 75Hz, STD (d1, 4f), CVT n/a */
    "1920 x 1440", 1920, 1440, 224, 352, 0, 1920, 0, 144,
                                 3,  56, 0, 1440, 0, 1,
                  297000, -1,   NP,   0, 75, 0,
    /* 1920 x 1440 @ 120Hz RB, STD n/a, CVT n/a */
    "1920 x 1440", 1920, 1440,  32,  80, 0, 1920, 0, 48,
                                 4,  78, 0, 1440, 0, 3,
                  380500, -1,   PN,   0, 120, 0,
    /* 2560 x 1600 CVT-RB, STD n/a, CVT (1f, 38, 21) */
    "2560 x 1600", 2560, 1600,  32,  80, 0, 2560, 0, 48,
                                 6,  37, 0, 1600, 0, 3,
                  268500, -1,   PN,   0, 60, 0,
    /* 2560 x 1600 @ 60Hz, STD n/a, CVT (1f, 38, 28) */
    "2560 x 1600", 2560, 1600, 280, 472, 0, 2560, 0, 192,
                                 6,  49, 0, 1600, 0, 3,
                  348500, -1,   NP,   0, 60, 0,
    /* 2560 x 1600 @ 75Hz, STD n/a, CVT (1f, 38, 44) */
    "2560 x 1600", 2560, 1600, 280, 488, 0, 2560, 0, 208,
                                 6,  63, 0, 1600, 0, 3,
                  443250, -1,   NP,   0, 75, 0,
    /* 2560 x 1600 @ 85Hz, STD n/a, CVT (1f, 38, 62) */
    "2560 x 1600", 2560, 1600, 280, 488, 0, 2560, 0, 208,
                                 6,  73, 0, 1600, 0, 3,
                  505250, -1,   NP,   0, 85, 0,
    /* 2560 x 1600 @ 120Hz RB, STD n/a, CVT n/a */
    "2560 x 1600", 2560, 1600,  32,  80, 0, 2560, 0, 48,
                                 6,  85, 0, 1600, 0, 3,
                  552750, -1,   PN,   0, 120, 0
};

/*
 * established timings maps the established timings bitfield onto
 * standard timings defined by the Display Monitor Timings Spec
 * Where there is no timing (0 - yes this /is/ a value on the table
 * but it's not used by the bitfield fortunately) then we use the
 * calculation method preferred by the display.
 */

/*    b7    b6    b5    b4    b3    b2    b1    b0 */
static const char established_timings[] = {
    0x00, 0x00, 0x04, 0x00, 0x05, 0x06, 0x08, 0x09,
    0x0a, 0x0b, 0x00, 0x0f, 0x10, 0x11, 0x12, 0x24
    /* N.B. third byte not checked */
};

static const char established_timings3[] = {
    0x01, 0x02, 0x03, 0x07, 0x0e, 0x0c, 0x13, 0x15,
    0x16, 0x17, 0x18, 0x19, 0x20, 0x21, 0x23, 0x25,
    0x27, 0x2e, 0x2f, 0x30, 0x31, 0x29, 0x2a, 0x2b,
    0x2c, 0x39, 0x3a, 0x3b, 0x3c, 0x33, 0x34, 0x35,
    0x36, 0x37, 0x3e, 0x3f, 0x41, 0x42, 0x44, 0x45,
    0x46, 0x47, 0x49, 0x4a, 0x00, 0x00, 0x00, 0x00
    /* N.B. 7th byte not checked */
};

/*
 * Established timings for 720x400 @ 70Hz
 * Derived from:
 *
 * http://www.javiervalcarce.eu/html/vga-signal-format-timming-specs-en.html
 * http://www.epanorama.net/documents/pc/vga_timing.html
 *
 */

static const ModeDefinition established_timing_7 =
{
    /* 720 x 400 @ 70Hz */
    "720 x 400",    720,  400, 108,  54, 0,  720, 0, 18,
                                 2,  34, 0,  400, 0, 13,
                   28322, -1,   NP,   0, 70, 0
};

/* List of standard timings - ie modes who have a defined 2-byte code in the DMT document.
 *
 * NB The third parameter is DMT NUMBER, not ARRAY NUMBER. This is usually
 * array value -1. This is to make cross-checks against the DMT spec easier.
 * We have used 4x3 columns to prevent the source file getting too long.
 * The list should be 0-terminated.
 */
static const STDTiming std_timings[] = {
#ifndef FORCE_CALCULATED_VALUES /* (Removes the table for debugging) */
    0x31, 0x19, 0x2,   0x31, 0x40, 0x4,   0x31, 0x4c, 0x5,   0x31, 0x4f, 0x6,
    0x31, 0x59, 0x7,   0x45, 0x40, 0x9,   0x45, 0x4c, 0xa,   0x45, 0x4f, 0xb,
    0x45, 0x59, 0xc,   0x61, 0x40, 0x10,  0x61, 0x4a, 0x11,  0x61, 0x4f, 0x12,
    0x61, 0x59, 0x13,  0x71, 0x4f, 0x15,  0x81, 0x00, 0x1c,  0x81, 0x0f, 0x1d,
    0x81, 0x19, 0x1e,  0x81, 0x40, 0x20,  0x81, 0x59, 0x21,  0x81, 0x80, 0x23,
    0x81, 0x8f, 0x24,  0x81, 0x99, 0x25,  0x90, 0x40, 0x2a,  0x90, 0x4f, 0x2b,
    0x90, 0x59, 0x2c,  0x95, 0x00, 0x2f,  0x90, 0x0f, 0x30,  0x95, 0x19, 0x31,
    0xa9, 0x40, 0x33,  0xa9, 0x45, 0x34,  0xa9, 0x4a, 0x35,  0xa9, 0x4f, 0x36,
    0xa9, 0x59, 0x37,  0xb3, 0x00, 0x3a,  0xb3, 0x0f, 0x3b,  0xb3, 0x19, 0x3c,
    0xc1, 0x40, 0x3e,  0xc1, 0x4f, 0x3f,  0xc9, 0x40, 0x41,  0xc9, 0x4f, 0x42,
    0xd1, 0x00, 0x45,  0xd1, 0x0f, 0x46,  0xd1, 0x19, 0x47,  0xd1, 0x40, 0x49,
    0xd1, 0x4f, 0x4a,
#endif
    0x00, 0x00, 0
};


/* List of 3-byte CVT timings - ie modes who have a defined 3-byte code in the DMT document.
 *
 * NB The third parameter is DMT NUMBER, not ARRAY NUMBER. This is usually
 * array value -1. This is to make cross-checks against the DMT spec easier.
 * We have used 4x3 columns to prevent the source file getting too long.
 * The list should be 0-terminated.
 */
#ifdef DERIVE_CVT3_FROM_DMT
static const CVTTiming cvt_timings[] = {
#ifndef FORCE_CALCULATED_VALUES /* (Removes the table for debugging) */
    0x7f, 0x1c, 0x21, 0x16,  0x7f, 0x1c, 0x28, 0x17,  0x7f, 0x1c, 0x44, 0x18,
    0x7f, 0x1c, 0x62, 0x19,  0x8f, 0x18, 0x21, 0x1b,  0x8f, 0x18, 0x28, 0x1c,
    0x8f, 0x18, 0x44, 0x1d,  0x8f, 0x18, 0x62, 0x1e,  0x0c, 0x20, 0x21, 0x29,
    0x0c, 0x20, 0x28, 0x2a,  0x0c, 0x20, 0x44, 0x2b,  0x0c, 0x20, 0x62, 0x2c,
    0xc1, 0x18, 0x21, 0x2e,  0xc1, 0x18, 0x28, 0x2f,  0xc1, 0x18, 0x44, 0x30,
    0xc1, 0x18, 0x68, 0x31,  0x0c, 0x28, 0x21, 0x39,  0x0c, 0x28, 0x28, 0x3a,
    0x0c, 0x28, 0x44, 0x3b,  0x0c, 0x28, 0x68, 0x3c,  0x57, 0x28, 0x21, 0x44,
    0x57, 0x28, 0x28, 0x45,  0x57, 0x28, 0x44, 0x46,  0x57, 0x28, 0x62, 0x47,
    0x1f, 0x38, 0x21, 0x4c,  0x1f, 0x38, 0x28, 0x4d,  0x1f, 0x38, 0x44, 0x4e,
    0x1f, 0x38, 0x62, 0x4f,
#endif
    0x00, 0x00, 0x00, 0
};
#endif

/*
 * Must keep this consistent with keywordset above: order has to match
 * exactly.
 */
enum keycode
{
    /* First in the set are those keywords which may be encountered
     * when reading an individual mode definition (i.e. between
     * "startmode", and "endmode").  These values are kept together in
     * the enumeration to make it easier to form a bitmap of seen
     * keywords in parse_mode() below.  At the moment, every keyword
     * must be seen exactly once in each definition.
     */
    k_x_res = 0,
    k_y_res,
    k_h_timings,
    k_v_timings,
    k_pixel_rate,
    k_sync_pol,
    k_external_clock,
    k_mode_name,
#define last_mode_key k_mode_name  /* last in *enumeration* - order in file not fixed! */

    k_file_format,
    k_monitor_title,
    k_dpms_state,
    k_lcd_support,
    k_interlaced,
    k_output_format,
    k_startmode,
    k_endmode,

    /* Now specials which do not correspond to actual file keywords */
    k_nokey,                       /* identifer not recog. as keyword */
    k_eof                          /* end of file */
};

#if DODEBUG
static int dodebug = 1;
#define debug if (!dodebug) {} else
#else
#define debug if (1) {} else
#endif

/*
 * Pointer to (root block of) current monitor definition structure.
 * This becomes valid (non NULL) on successful completion of a
 * *loadmodefile command.  The memory space it consumes is thereafter
 * released on either (a) shutdown of the module or (b) successful
 * completion of another *loadmodefile command.
 */
static MonitorDescriptionRef current_monitor = NULL; /* not defined to start with */

static ModeSelectorRef preferred_mode = NULL; /* The preferred mode */
static int preferred_sync_type = 0; /* The sync type for the preferred mode
                                       NB only service_monitorleadtranslation
                                       uses this value */

/*
 * Keep a copy of the current monitor type at the time of the first
 * successful *LoadModeFile, to restore on exit.
 */
static int old_monitortype = -1;       /* -1 means we haven't loaded a file yet */

/*
 * Construct an error block from the given ScreenModes module-specific
 * error code and the list of up to 3 arguments.  To ensure easy
 * internationalisability, this is done using text from our Messages
 * file, via MessageTrans_Lookup.  Note that all errors from this
 * module cause the whole process to stop (i.e. there should only be
 * one error generated for any *loadmodefile command) so don't worry
 * about efficiency; e.g. we could keep the file open and the handle
 * lying around, but there really isn't any point.
 */
static _kernel_oserror *error (int error, const char *arg0, const char *arg1, const char *arg2)
{
    /* Where the final returned message is constructed */
    static _kernel_oserror theerror;
    /* Handle for MessageTrans. */
    int file_data[4];
    _kernel_swi_regs r;
    _kernel_oserror *res;
    char token[8];

    /* Open the Messages file */
    r.r[0] = (int)file_data;
    r.r[1] = (int)Module_MessagesFile;
    r.r[2] = 0;
    if ((res = _kernel_swi (MessageTrans_OpenFile, &r, &r)) != NULL) {
        return res;
    }

    sprintf (token, "E%02d", error);

    r.r[0] = (int)file_data;
    r.r[1] = (int)token;
    r.r[2] = (int)theerror.errmess;
    r.r[3] = 252;
    r.r[4] = (int)arg0;                 /* for %0 */
    r.r[5] = (int)arg1;                 /* for %1 */
    r.r[6] = (int)arg2;                 /* for %2 */
    r.r[7] = 0;                         /* not expecting %3, so don't substitute */
    res = _kernel_swi (MessageTrans_Lookup, &r, &r);
    /* Always close the messages file, ignoring possible but most unlikely errors */
    r.r[0] = (int)file_data;
    (void)_kernel_swi (MessageTrans_CloseFile, &r, &r);
    /* Check for error from the lookup */
    if (res) {
        return res;                     /* lookup failed */
    }
    /* Construct the rest of the error block, i.e. the error number */
    theerror.errnum = ERROR_BASE + error;
    return &theerror;
}

static void free_monitordescription (MonitorDescriptionRef description)
{
    ModeDescriptionRef md;
    md = description->modelist;
    while (md)
    {
        ModeDescriptionRef td = md;
        md = md->next;
        free (td);
    }
    if (description->audio_formats)
    {
        free (description->audio_formats);
    }
    free (description);
}

static void release_currentmonitor (void)
{
    if (current_monitor)
    {
        debug printf ("releasing previous monitor description\n");
        free_monitordescription (current_monitor);
    }
}

static int matchtext (char *text, const char *ref)
{
    while (tolower (*text) == *ref)
    {
        if (*text == '\0') {
            return 1;
        }
        ++text; ++ref;
    }
    return 0;
}

#define using_stdio 1

#if using_stdio
static FILE *thefile;
#else                                   /* in-memory file */
static struct { char *base, *next, *lim; } thefile;
#endif
static const char *thefilename;         /* only valid during processing */
static int lineno;

static _kernel_oserror *open_modefile (const char *filename)
{
    _kernel_oserror *res;
#if using_stdio
    FILE *f = fopen (filename, "r");
    if (f != NULL) {
        res = NULL;                     /* all OK */
    }
    else
    {
        res = _kernel_last_oserror ();
        if (res == NULL)
        {
            _kernel_swi_regs regs;
            /* Couldn't open file but only C library knows why: let's find out. */
            regs.r[0] = 0x4f;           /* go try opening it */
            regs.r[1] = (int) filename;  regs.r[2] = 0;
            res = _kernel_swi (OS_Find, &regs, &regs);
            if (res == NULL)
            {
                /*
                 * Hmmm, fopen failed but we *can* open it: give up!
                 * First re-close this file handle.
                 */
                int fh = regs.r[0];
                regs.r[0] = 0;  regs.r[1] = fh;
                (void) _kernel_swi (OS_Find, &regs, &regs);
                res = error (ERR_OPENFAIL, filename, 0, 0);
            }
        }
    }
    thefile = f;
#else
#error only stdio supported for now!
#endif
    lineno = 1;
    thefilename = filename;
    return res;
}

static int nextc (void)
{
    int c;
#if using_stdio
    c = getc (thefile);
#else
    if (thefile.ptr < thefile.lim) {
        c = *thefile.ptr++;
    }
    else {
        c = EOF;
    }
#endif
    if (c == '\n') {
        ++lineno;
    }
    return c;
}

static void pushback (int c)
{
    if (c != EOF)
    {
#if using_stdio
        ungetc (c, thefile);
#else
        if (thefile.ptr > thefile.base && thefile.ptr[-1] == c)
        {
            --thefile.ptr;
        }
#endif
        if (c == '\n') {
            --lineno;
        }
    }
}

static void close_modefile (void)
{
#if using_stdio
    fclose (thefile);
#else
    free (thefile.base);
#endif
}

static _kernel_oserror *synerr0 (int code)
{
    char linebuff[10+1];
    sprintf (linebuff, "%u", lineno);
    return error (code, thefilename, linebuff, 0);
}

static _kernel_oserror *synerrC (int errcode, int thechar)
{
    char linebuff[10+1], charbuff[1+1];
    sprintf (linebuff, "%u", lineno);
    charbuff[0] = thechar; charbuff[1] = '\0';
    return error (errcode, thefilename, linebuff, charbuff);
}

static _kernel_oserror *synerrK (int errcode, enum keycode keycode)
{
    char linebuff[10+1];
    sprintf (linebuff, "%u", lineno);
    return error (errcode, thefilename, linebuff, keyword(keycode));
}

/*
 * Semantic errors are not directly associated with a single line, so
 * no line number is shown.  The distinction between syntatic errors
 * and semantic ones is a little fine at times...
 */
static _kernel_oserror *semerr0 (int code)
{
    return error (code, thefilename, 0, 0);
}

static _kernel_oserror *semerrS (int code, char *thestring)
{
    return error (code, thefilename, thestring, 0);
}

static int skip_space (void)
{
    int c;
    while ((c = nextc()) != '\n' && isspace (c))
        ;
    return c;
}

static int skip_comment_or_blank (void)
{
    int c;
    while ((c = skip_space ()) == '\n' || c == '#')
    {
        if (c == '#')
        {
            /* Comment - extends to end of line */
            /* TMD 25-Nov-93 - Fix bug MED-01177
               Wasn't checking for EOF here, so if comment line
               ended in EOF, it looped indefinitely
             */
            do
                c = nextc ();
            while (c != '\n' && c != EOF);
        }
    }
    return c;
}


static enum keycode read_keyword (void)
{
    char buff[MAXKEYWORDLEN+1+1];
    int i, c;
    enum keycode k;

    c = skip_comment_or_blank ();
    i = 0;
    if (c == EOF) {
        return k_eof;
    }
    while (isalpha (c) || c == '_')
    {
        if (i < MAXKEYWORDLEN+1)        /* allow one extra char, to catch junk at end */
        {
            buff[i++] = c;
        }
        c = nextc ();
    }
    pushback (c);                       /* backstep over terminating char */
    buff[i] = '\0';                     /* terminate it */
    k = (enum keycode) 0;
    while (k < k_nokey && !matchtext (buff, keyword(k)))
        k = (enum keycode) (k + 1);
    return k;
}

static _kernel_oserror *skip_char (int ch)
{
    int c;
    while ((c = nextc ()) != '\n' && isspace (c))
        ;
    if (c == ch) {
        return NULL;
    }
    if (c == EOF) {
        return synerr0 (ERR_EOF);
    }
    pushback (c);                       /* in case of '\n', to get lineno right */
    return synerrC (ERR_EXPCHAR, ch);
}

static _kernel_oserror *check_eol (int eofok)
{
    int c = skip_space ();
    if (c == '\n' || (eofok && c == EOF)) {
        return NULL;
    }
    if (c == EOF) {
        return synerr0 (ERR_EOF);
    }
    return synerr0 (ERR_EXTRAINPUT);
}

/*
 * Read text (starting with the next non-space character) up to the
 * end of the current line. EOF is not acceptable to terminate it.
 * Trailing spaces are removed.  Text longer than the available buffer
 * size is (for now) just truncated.
 *
 * TMD 13-Dec-93: Allow zero length lines if blankerror=-1,
 * because blank mode names are now OK.
 */
static _kernel_oserror *read_text (char *buff, int size, int blankerror)
{
    int c, i, excess;
    i = 0;  excess = 0;
    /* Skip leading white-space */
    c = skip_space ();
    if (c == '\n' && blankerror != -1)  /* blank field - complain if necessary */
    {
        pushback (c);                   /* to get line number correct! */
        return synerr0 (blankerror);
    }
    while (c != EOF && c != '\n')
    {
        if (i < size-1) {
            buff[i++] = c;
        }
        else
        {
            /* Should we complain, or issue a warning? Do nowt for now. */
            if (!isspace(c))
            {
                ++excess;
                debug
                    if (excess == 1) {
                        printf ("excess chars ignored on text at line %d\n", lineno);
                    }
            }
        }
        c = nextc ();
    }
    if (c == EOF) {
        return synerr0 (ERR_EOF);       /* EOF not allowed */
    }
    /* Remove trailing white-space */
    while (i > 0 && isspace (buff[i-1]))
        --i;
    /* Terminate the string */
    buff[i] = '\0';
    return NULL;
}

static _kernel_oserror *read_u32 (uint32_t *var)
{
    int c;
    uint32_t acc;
    c = skip_space ();
    if (!isdigit (c)) {
        return synerr0 (ERR_EXPNUM);
    }
    acc = c - '0';
    while (isdigit (c = nextc()))
    {
        int digit = c - '0';
        if (acc > UINT32_MAX/10 ||
            (acc == UINT32_MAX/10 && digit > UINT32_MAX%10)) {
            return synerr0 (ERR_VALUEOVF);
            }
        acc = acc * 10 + digit;
    }
    pushback (c);                       /* leave terminating char waiting to be read */
    *var = acc;
    return NULL;
}

static _kernel_oserror *read_one_u32 (uint32_t *var, uint32_t fault_zero)
{
    _kernel_oserror *res = read_u32 (var);
    if (res) {
        return res;
    }
    if (fault_zero && *var == 0) {
        return synerr0 (ERR_INVALIDPAR);
    }
    return check_eol (0);
}

static _kernel_oserror *check_keyword (enum keycode code, int colon)
{
    enum keycode kc;
    kc = read_keyword ();
    if (kc == k_eof)                    /* we never explicitly look for k_eof */ {
        return synerr0 (ERR_EOF);
    }
    if (kc != code) {
        return synerrK (ERR_EXPKEY, code);
    }
    if (colon) {
        return skip_char (':');
    }
    else {
        return NULL;
    }
}

static _kernel_oserror *parse_mode (ModeDefinition *mode)
{
    uint32_t keyseen;

    keyseen = 0;
    mode->interlaced = 0; /* Assume mode is not interlaced, unless we see the keyword */
    mode->external_clock = -1;
    for (;;)
    {
        enum keycode kc = read_keyword ();
        uint32_t param, missed, ok_to_miss;
        _kernel_oserror *res;
        if (kc <= last_mode_key)
        {
            if (keyseen & (1 << kc)) {
                return synerrK (ERR_REPKEY, kc);
            }
            res = skip_char (':');
            if (res) {
                return res;
            }
            keyseen |= 1 << kc;
        }
        switch (kc)
        {
          case k_eof:
            return synerr0 (ERR_EOF);

          case k_endmode:
            /* Work out which, if any, of the entries have not been supplied */
            assert (last_mode_key <= 31);
            missed = ((1u << (last_mode_key + 1)) - 1) & ~keyseen;

            /*
             * In format 1, we normally insist that x_res = hdisp and
             * y_res = vdisp so x_res and y_res are in fact optional.
             * However if the mode is interlaced, then x_res and y_res are compulsory.
             * We insist that all other keywords do occur.
             */
            ok_to_miss = mode->interlaced ? 0 : (1 << k_x_res) | (1 << k_y_res);
            ok_to_miss |= (1 << k_interlaced) | (1 << k_external_clock);
            if (missed & ~ok_to_miss)
            {
                /*
                 * If some other keyword(s) not seen, complain.  If
                 * mode_name is one of them, must identify by line
                 * number so treat it as a syntactic error, else as
                 * semantic, providing debugging info in terms of the
                 * mode name.
                 */
                if (missed & (1 << k_mode_name)) {
                    return synerr0 (ERR_NOMODENAME);
                }
                else {
                    return semerrS (ERR_INCOMPLETE, mode->name);
                }
            }
            /* If xres and/or yres missing, use the xdisp and/or ydisp values */
            if (!(keyseen & (1 << k_x_res))) {
              mode->xres = mode->hpar[FR_DISP];
            }
            if (!(keyseen & (1 << k_y_res))) {
              mode->yres = mode->vpar[FR_DISP];
            }

            /* xres must equal xdisp, and yres must equal ydisp (or ydisp*2 for interlaced modes) */
            if (mode->xres != mode->hpar[FR_DISP] || mode->yres != mode->vpar[FR_DISP] * (mode->interlaced+1)) {
                return semerrS (ERR_INCONSISTENT, mode->name);
            }
            return check_eol (1);

          case k_nokey:
            return synerr0 (ERR_UNKNOWNPAR);

          default:
            /* Known keyword but out of place */
            return synerrK (ERR_WRONGCONTEXT, kc);

          case k_x_res:
            res = read_one_u32 (&mode->xres, 1);
            if (res) {
                return res;
            }
            break;

          case k_y_res:
            res = read_one_u32 (&mode->yres, 1);
            if (res) {
                return res;
            }
            break;

          case k_pixel_rate:
            res = read_one_u32 (&mode->pixel_khz, 1);
            if (res) {
                return res;
            }
            break;

          case k_sync_pol:
            res = read_one_u32 (&param, 0);
            if (res) {
                return res;
            }
            if (param > 3) { /* must fit in (currently) 2 bits */
                return synerr0 (ERR_VALUEOVF);
            }
            mode->syncpol = param;
            break;

          case k_interlaced:
            mode->interlaced = 1; /* It is an interlaced mode */
            res = check_eol (0);
            if (res) {
                return res;
            }
            break;

          case k_external_clock:
            res = read_one_u32 (&mode->external_clock, 0);
            if (res) {
                return res;
            }
            break;

          case k_mode_name:
            /* TMD 13-Dec-93: We must allow blank mode names now -
             * they mean a mode is not shown in DisplayManager menu.
             * Passing in -1 as the error number for read_text means don't
             * fault blank lines.
             */
            res = read_text (mode->name, sizeof(mode->name), -1);
            if (res) {
                return res;
            }
            break;

          case k_h_timings:
          case k_v_timings:
            {
                int pn;
                uint16_t *par = kc == k_h_timings ? mode->hpar : mode->vpar;
                for (pn = 0; pn < FR__COUNT; ++pn)
                {
                    uint32_t param;
                    res = read_u32 (&param);
                    if (res) {
                        return res;
                    }
                    if (param >= 0x10000) {    /* must fit in 16 bits (unsigned) */
                        return synerr0 (ERR_VALUEOVF);
                    }
                    par[pn] = param;
                    /* Check for following comma or end of line */
                    if (pn < FR__COUNT-1) {
                        res = skip_char (',');
                    }
                }
                if (par[FR_DISP] == 0) {
                    return synerr0 (ERR_INVALIDPAR);
                }

                res = check_eol (0);
                if (res) {
                    return res;
                }
            }
            break;
        }
    }
}

static void compute_modedescription (ModeDescriptionRef md)
{
    uint32_t vtot, htot;
    int pn;
    ModeDefinition *mp = &md->definition; /* for terseness! */
    for (htot = 0, vtot = 0, pn = 0; pn < FR__COUNT; ++pn)
    {
        htot += mp->hpar[pn];
        vtot += mp->vpar[pn];
    }
    md->line_hz = mp->pixel_khz * 1000 / htot;  /* compute line frequency in Hz */
    md->frame_mhz = md->line_hz * 1000 / vtot; /* frame frequency in milliHz, high-prec */
    if (mp->interlaced) {
      md->frame_mhz /= 2; /* if interlaced, one frame is 2 fields */
    }
    md->frame_hz = (md->frame_mhz + 500) / 1000; /* & low-prec for user integer Hz matching */
}

static _kernel_oserror *parse_modelist (MonitorDescriptionRef monitor, enum keycode kc)
{
    for (;;)
    {
        if (kc == k_startmode)
        {
            ModeDescriptionRef mp;
#if 0
            ModeDescriptionRef rp;
#endif
            _kernel_oserror *res;
            res = check_eol (0);
            if (res) {
                return res;
            }
            mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
            if (mp == NULL) {
                return error (ERR_NOSPACE, 0, 0, 0);
            }
            /*
             * Chain the new (as yet un-filled-in) mode on as the head
             * of the existing list, so the space will get released
             * properly on error.
             */
            mp->next = monitor->modelist;
            monitor->modelist = mp;
            /* Go parse the definition, filling in the record fields */
            res = parse_mode (&mp->definition);
            if (res) {
                return res;                     /* failed */
            }
            /* fill in defaults */
            if (mp->definition.external_clock == -1) {
                mp->definition.external_clock = monitor->external_clock;
            }
            /* derive frame and line rates */
            compute_modedescription (mp);
#if 0
            /* Check for uniqueness of mode name */
            rp = mp->next;
            while (rp)
            {
                if (strcmp (rp->definition.name, mp->definition.name) == 0) {
                    return semerrS (ERR_DUPMODENAME, mp->definition.name);
                }
                rp = rp->next;
            }
#endif
        }
        else if (kc == k_eof)
        {
            /* OK provided there is at least one mode! */
            if (monitor->modelist != NULL) {
                return NULL;            /* ALL DONE */
            }
            return semerr0 (ERR_NOMODES);
        }
        else
        {
            return synerrK (ERR_EXPKEY, k_startmode);
        }
        kc = read_keyword ();               /* read next startmode, hopefully */
    }
}

static _kernel_oserror *parse_modefile (MonitorDescriptionRef *description)
{
    uint32_t ffmt;
    _kernel_oserror *res;
    MonitorDescriptionRef md;
    enum keycode kc = k_nokey;

    res = check_keyword (k_file_format, 1);
    if (res) {
        return res;
    }
    res = read_one_u32 (&ffmt, 0);
    if (res) {
        return res;
    }
    if (ffmt != 1) {
        return synerr0 (ERR_UNKNOWNFMT);
    }

    res = check_keyword (k_monitor_title, 1);
    if (res) {
        return res;
    }
    /* OK, commit to reading a monitor description - go allocate space */
    md = (MonitorDescriptionRef) malloc (sizeof(MonitorDescription));
    if (md == NULL) {
        return error (ERR_NOSPACE, 0, 0, 0);
    }
    /*
     * From here on, need to release memory on error, so do most of
     * the rest as a subroutine.
     */
    memset(md, 0, sizeof(MonitorDescription));
    md->modelist = NULL;                                       /* to start with */
    res = read_text (md->name, sizeof(md->name), ERR_BLANKMONTITLE);

    /*
     * Now check for optional DPMS_state keyword
     */
    if (res == NULL) {
        md->dpms_state = -1;                                   /* indicates field not present */
        kc = read_keyword ();
        if (kc == k_dpms_state)
        {
            res = skip_char (':');
            if (res == NULL)
            {
                res = read_one_u32 (&md->dpms_state, 0);       /* read DPMS_state value */
            }
            if (res == NULL)
            {
                kc = read_keyword ();                          /* then read next keyword */
            }
        }
    }

    /*
     * Now check for optional LCD_support keyword
     */
    if (res == NULL) {
        md->lcd_support = 0;                                   /* Indicates CRT as default */
        if (kc == k_lcd_support)
        {
            debug printf("Got the lcdsupport keyword\n");
            res = skip_char (':');
            if (res == NULL) {
                res = read_one_u32 (&md->lcd_support, 0);      /* read LCD_support value */
                if (md->lcd_support != 0) {
                  md->dpms_state = -1;                         /* LCD and DPMS are mutually exclusive */
                }
                debug printf("Read the value as %d\n",md->lcd_support);
            }
            if (res == NULL) {
              kc = read_keyword ();                            /* then read next keyword */
            }
        }
    }

    /*
     * Now check for optional output_format keyword
     */
    if (res == NULL) {
        md->output_format = -1;                                /* indicates field not present */
        if (kc == k_output_format)
        {
            res = skip_char (':');
            if (res == NULL) {
                res = read_one_u32 (&md->output_format, 0);    /* read output_format value */
            }
            if (res == NULL) {
                kc = read_keyword ();                          /* then read next keyword */
            }
        }
    }

    /*
     * Now check for optional external_clock keyword
     */
    if (res == NULL) {
        md->external_clock = -1;                               /* indicates field not present */
        if (kc == k_external_clock)
        {
            res = skip_char (':');
            if (res == NULL) {
                res = read_one_u32 (&md->external_clock, 0);   /* read external_clock value */
            }
            if (res == NULL) {
                kc = read_keyword ();                          /* then read next keyword */
            }
        }
    }

    if (res == NULL) {
        debug printf("Going to read the modes now...\n");
        res = parse_modelist (md, kc);                         /* pass in read keyword token */
    }

    if (res) {
        free_monitordescription (md);
        md = NULL;
    }
    *description = md;
    return res;
}

/*
 * For efficiency in handling the Service_ModeExtension service call,
 * we keep the list of supported modes in order.  The keys used for
 * comparison of modes are (in order of use):
 *   (1) increasing x resolution
 *   (2) increasing y resolution
 *   (3) decreasing frame rate
 *   (4) increasing peak datarate at a given depth, i.e. pixelrate
 */
static int modes_inorder (ModeDescriptionRef m1, ModeDescriptionRef m2)
{
    if (m1->definition.xres < m2->definition.xres) {
        return 1;
    }
    if (m1->definition.xres > m2->definition.xres) {
        return 0;
    }
    if (m1->definition.yres < m2->definition.yres) {
        return 1;
    }
    if (m1->definition.yres > m2->definition.yres) {
        return 0;
    }
    if (m1->frame_mhz > m2->frame_mhz) {
        return 1;
    }
    if (m1->frame_mhz < m2->frame_mhz) {
        return 0;
    }
    if (m1->definition.pixel_khz < m2->definition.pixel_khz) {
        return 1;
    }
    if (m1->definition.pixel_khz > m2->definition.pixel_khz) {
        return 0;
    }
    return 1;                           /* arbitrary here - modes seem the same! */
}

static void sort_modelist (ModeDescriptionRef *list)
{
    ModeDescriptionRef prev, this, next;
    int swapped;
    do
    {
        prev = NULL;                    /* marks being at start of list */
        this = *list;                   /* not NULL */
        next = this->next;              /* might be NULL, for 1-entry list */
        swapped = 0;
        while (next) {
            if (!modes_inorder (this, next)) {
                ModeDescriptionRef t;
                /* Move whatever is pointing at this to point at next */
                if (prev == NULL) {
                    *list = next;       /* swap at start of list */
                }
                else {
                    prev->next = next;
                }
                /* The new successor to this record is what was after the next one */
                this->next = next->next;
                /* The new successor to what was the next record is now this record */
                next->next = this;
                /* Swap our local this and next pointers */
                t = this;  this = next;  next = t;
                swapped = 1;
            }
            /* Step all the pointers on by one in the (perhaps re-ordered) list */
            prev = this;
            this = next;
            next = next->next;
        }
    } while (swapped);
}

static _kernel_oserror *set_monitortype (int monitortype)
{
    _kernel_swi_regs regs;
    regs.r[0] = 3;
    regs.r[1] = monitortype;
    return _kernel_swi (OS_ScreenMode, &regs, &regs);
}

static int read_monitortype (void)
{
    _kernel_swi_regs regs;
    _kernel_oserror *res;
    regs.r[0] = 1;
    res = _kernel_swi (OS_ReadSysInfo, &regs, &regs);
    if (res) {
      return -1;
    }
    else {
      return regs.r[1];
    }
}

static _kernel_oserror *restore_monitortype (void)
{
    int temp = old_monitortype;
    if (temp != -1) {
        old_monitortype = -1;
        return set_monitortype (temp);
    }
    else {
        return NULL;
    }
}

#if DODEBUG
static void show_monitor (MonitorDescriptionRef monitor)
{
    ModeDescriptionRef mode;
    printf ("Monitor title: \"%s\"\n", monitor->name);
    for (mode = monitor->modelist; mode; mode = mode->next)
    {
        ModeDefinition *dp = &mode->definition;
        uint32_t pixrate = dp->pixel_khz;
        uint32_t pixels = dp->xres * dp->yres;
        int log2bpp;
        printf ("  Mode name \"%s\"\n", mode->definition.name);
        printf ("  Resolution %u x %u\n", dp->xres, dp->yres);
        printf ("  Line rate %u.%03u kHz, Frame rate %d.%03d Hz\n",
                mode->line_hz / 1000, mode->line_hz % 1000,
                mode->frame_mhz / 1000, mode->frame_mhz % 1000);
        printf ("  Pixel rate %u kHz, Sync type %u\n", dp->pixel_khz, dp->syncpol);
        printf ("  Line timings\n"
                "    sync %u b-porch %u l-border %u display %u r-border %u f-porch %u\n",
                dp->hpar[FR_SYNC], dp->hpar[FR_BPCH], dp->hpar[FR_BDR1],
                dp->hpar[FR_DISP], dp->hpar[FR_BDR2], dp->hpar[FR_FPCH]);
        printf ("  Frame timings\n"
                "    sync %u b-porch %u t-border %u display %u b-border %u f-porch %u\n",
                dp->vpar[FR_SYNC], dp->vpar[FR_BPCH], dp->vpar[FR_BDR1],
                dp->vpar[FR_DISP], dp->vpar[FR_BDR2], dp->vpar[FR_FPCH]);
        if (dp->interlaced) {
            printf("  Interlaced\n");
        }
        for (log2bpp = 0; log2bpp <= 5; ++log2bpp) {
            uint32_t bits = 1 << log2bpp;
            uint32_t drate, dsize;
            if (bits < 8) {
                uint8_t shift = 3 - log2bpp;
                uint32_t round = (1 << shift) - 1;
                drate = (pixrate + round) >> shift;
                dsize = (pixels + round) >> shift;
            }
            else {
                uint8_t shift = log2bpp - 3;
                drate = pixrate << shift;
                dsize = pixels << shift;
            }
            printf ("  %2u bpp: bandwidth %6u000 bytes/sec, data size %7u bytes\n", bits, drate, dsize);
        }
        printf ("\n");
    }
}
#endif

static _kernel_oserror *loadtextMDF (const char *file)
{
    _kernel_oserror *res;
        MonitorDescriptionRef new_monitor;
        EDIDEnabled = 0;   /* disable any automatic edid stuff */

        debug printf ("file opened OK\n");
        res = parse_modefile (&new_monitor);
        debug printf ("closing file\n");
        close_modefile ();
        if (res != NULL) {
            debug printf ("failed to parse mode file\n");
        }
        else
        {
            debug printf ("monitor description parsed OK\n");
            sort_modelist (&new_monitor->modelist);
#if DODEBUG
            debug show_monitor (new_monitor);
#endif
            /* If we haven't got a file loaded at present, then
             * read current monitortype, to restore on module shutdown
             */
            if (old_monitortype == -1) {
                old_monitortype = read_monitortype ();
            }

            /* Now tell kernel to use monitor type 7 (File) */
            res = set_monitortype (MONITOR_FILE);
            if (res != NULL)
            {
                _kernel_oserror *res2;
                debug printf ("setting of monitor type to type `FILE' failed\n");
                res2 = restore_monitortype (); /* restore old value */
                debug
                if (res2 != NULL) {
                    printf ("couldn't reset monitor type to CMOS default!\n");
                }
            }
            else
            {
                char *path, *dot;
                _kernel_swi_regs regs;

                path = malloc((size_t)strlen(file)+32);
                if (path != NULL) {
                    /* Allow the MDF to come with an accompanying sprite */
                    strcpy(path,"IconSprites ");
                    dot = strrchr(file, '.');
                    if (dot != NULL) {
                        strcat(path, file);    /* Grab the path */
                        dot = 1 + strrchr(path, '.');
                        *dot = '\0';           /* Slice off the leafname */
                    }
                    strcat(path, "!Sprites");
                    _kernel_oscli(path);
                    free(path);
                }

                release_currentmonitor ();
                current_monitor = new_monitor;
                /* Forget any old preferred mode */
                preferred_mode->bit0 = 0;

                /* Newly defined monitor, announce it */
                regs.r[1] = Service_ModeFileChanged;
                _kernel_swi (OS_ServiceCall, &regs, &regs);
            }
        }
    return res;
}

#if DODEBUG
/* display_mode_parameters produces debug output showing the
 * mode descriptor being passed for a particular mode
 */
static void display_mode_parameters(ModeDescriptionRef mode_desc)
{
  printf("XRes: %i YRes: %i ",
              mode_desc->definition.xres,
              mode_desc->definition.yres);
  if (mode_desc->definition.interlaced == 1) {
    printf("(interlaced)");
  }
  else {
    printf("(non-interlaced)");
  }

  printf(" PixRate: %i\nHSync:%i Hbpch:%i Hlbdr:%i Hdisp:%i Hrbdr:%i Hfpch:%i\nVSync:%i Vbpch:%i Vtbdr:%i Vdispl:%i Vbbdr:%i Vfpch:%i\n\n",
         mode_desc->definition.pixel_khz,
         mode_desc->definition.hpar[FR_SYNC],
         mode_desc->definition.hpar[FR_BPCH],
         mode_desc->definition.hpar[FR_BDR1],
         mode_desc->definition.hpar[FR_DISP],
         mode_desc->definition.hpar[FR_BDR2],
         mode_desc->definition.hpar[FR_FPCH],
         mode_desc->definition.vpar[FR_SYNC],
         mode_desc->definition.vpar[FR_BPCH],
         mode_desc->definition.vpar[FR_BDR1],
         mode_desc->definition.vpar[FR_DISP],
         mode_desc->definition.vpar[FR_BDR2],
         mode_desc->definition.vpar[FR_FPCH]);
}
#endif


/*
 *  add_proposed_modes checks if a new mode is present already.
 *  If it has, we won't be adding it to the chain.
 *  Return 1 if successful, and 0 if we have rejected it for any reason
 */
static int add_proposed_mode(MonitorDescriptionRef monitor_definition, ModeDescriptionRef proposed_mode)
{

   proposed_mode->next = monitor_definition->modelist;
   monitor_definition->modelist = proposed_mode;
   return 1;
}


/* Copy a builtin mode and add it to the monitor description
 */
static _kernel_oserror *add_builtin_mode(MonitorDescriptionRef monitor, const ModeDefinition *mode, uint8_t priority)
{
    ModeDescriptionRef mode_desc = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
    if (mode_desc == NULL) {
        return error (ERR_NOSPACE, 0, 0, 0);
    }

    mode_desc->definition = *mode;
    compute_modedescription(mode_desc);
    mode_desc->frame_hz = mode->freq;
    mode_desc->priority = priority;

    if (add_proposed_mode(monitor, mode_desc) == 0) {
      free(mode_desc);
      return NULL;
    }

#if DODEBUG
    display_mode_parameters(mode_desc);
#endif

    return NULL;
}

/* generate_dmt_mode creates a mode using standardised timing parameters.
 * These come from the Display Monitor Timing Document (VESA).
 * They are part of EDID 1.0 to 1.3 and should be used where a DMT
 * standard exists (refer Appendix B of EDID 1.4 spec and the DMT document).
 */
static _kernel_oserror *generate_dmt_mode(char dmt, MonitorDescriptionRef monitor, uint8_t priority)
{
    /* If there is no established timing, ignore (for now).
     * Later we will generate a mode here and add
     */
    if (dmt > 0)
    {
        dmt--; /* Convert DMT back to array number */

        #if DODEBUG
        printf("Established Modes Display Monitor Timing :\n");
        #endif

        return add_builtin_mode(monitor, &display_monitor_timings[dmt], priority);
    }
#if DODEBUG
    else
    {
        printf("Ignoring established timing (not a standard mode).\n\n");
    }
#endif

    return 0;
}

#define EDID_Check_BaseOnly 0
#define EDID_Check_AllBlocks 1
static _kernel_oserror *Check_EDID_Checksum(char *EDIDData, char check_type)
{
    _kernel_oserror *res = NULL;

    char blocks_to_check = 0;
    char count = 0;

    EDIDBlockRef edidblock = (EDIDBlockRef) EDIDData;

    for (int block = 0; block <= blocks_to_check; block++) {
        count = 0;
        for (int byte = 0; byte < 128; byte++) {
            count = count + EDIDData[(block * 128) + byte];
        }
        if (count != 0) {
            char linebuff1[4];
            char linebuff2[4];
            sprintf (linebuff1, "%u", block);
            sprintf (linebuff2, "%u", blocks_to_check);
            res = error (ERR_BADCHECKSUM, linebuff1, linebuff2, 0);
        }
        else
        {
            if ((block == 0) && (check_type == EDID_Check_AllBlocks)) {
                blocks_to_check = edidblock->extension_block_count;
            }
#if DODEBUG
            /* For debug we confirm each block is OK as well as failed */
            printf("Checksum: Block %i of %i OK\n", block, blocks_to_check);
#endif
        }
    }

    return res;
}

/* Get_DTD_ASCII takes a block of text from an 18-byte EDID data block
 * And fills a supplied character buffer with a usable 0-terminated string
 * Buffer must be at least 14 bytes in length
 */

static void Get_DTD_ASCII(EDIDBlockRef edidblockref, int block_number, char *data)
{
    int i;
    for (i = 0; i < 13; ++i)
    {
        data[i] = edidblockref->data_block[block_number][i+5];
        if (data[i] == 0x0A)
        {
            break;
        }
        else if ((data[i] < 32) || (data[i] == 127))
        {
            /* Strip out any control characters for safety */
            data[i] = ' ';
        }
    }
    data[i] = 0;
}

static void generate_mode_using_gtf(double h_pixels, double v_lines, double ip_freq_rqd, ModeDescriptionRef mode_desc, MonitorDescriptionRef monitor)
{
    const int margins_rqd = 0; /* Set to 1 if margins are wanted. */
    const double margin_per = 0; /* Percentage size of margin (0 to 100) if reqd */
    double v_lines_rnd = 0; /* Number of desired visible lines rounded down to */
                            /* The nearest character cell */
    double v_sync_rqd = 3; /* The width of the v sync in lines */
    double h_sync_percent = 8; /* The width of the H sync as percentage of the total line period */
    double cell_gran_rnd = 8; /* Character cell width in pixels. May be able to confirm this value in hardware but at present hardcode this to 8 (usual value), */
    const int int_rqd = 0; /* int_rqd specifies whether the mode should be interlaced. Most modes used are not. */
    double v_field_rate_reqd = 0; /* The actual vertical field rate after interlacing is taking into consideration */
    double interlace = 0; /* If interlacing is used, this will be set to 0.5 */

    const double min_vsync_and_bp = 550; /* The minimum time of vertical sync and back porch interval (us) */
    const double min_porch = 1; /* Minimum front porch in lines (vertical) and character cells (horizontal) */
    const double c = 40; /* The blanking formula offset */
    const double m = 600; /* The blanking formula gradient */
    const double k = 128; /* The blanking formula scaling factor */
    const double j = 20; /* The blanking formula scaling factor weighting */

    /* coefficient calculations. These should be constants in standard GTF */
    double C = ((c-j) * k / 256) + j;
    double M = k / 256 * m;

    /* Find the refresh rate required (Hz) */

    /* If interlaced, the number of vertical lines assumed by the */
    /* calculation must be halved, as the computation calculates the */
    /* number of vertical lines per field. In either case, the number */
    /* of lines is rounded down to the nearest integer. */

    if (int_rqd == 1)
    {
        v_lines_rnd = floor(v_lines / 2);
        v_field_rate_reqd = ip_freq_rqd * 2;
        interlace = 0.5;
    }
    else
    {
        v_lines_rnd = round(v_lines);
        v_field_rate_reqd = ip_freq_rqd;
        /* Interlace is automatically set to 0 */
    }

    /* Round the number of pixels to the nearest character */
    /* cell boundary */
    double h_pixels_rnd = (round(h_pixels/cell_gran_rnd)) * cell_gran_rnd;

    /* Determine the width of the left and right borders */
    double left_margin = 0; /* Number of pixels in the left hand margin, rounded */
                          /* down to the nearest character cell. If no margins */
                          /* required this is set to 0. */
    double right_margin = 0; /* see left_margin */
    double top_margin = 0; /* No of lines rounded down to nearest line. */
    double bot_margin = 0; /* See top, left, right */

    if (margins_rqd == 1)
    {
        left_margin = round(h_pixels_rnd * margin_per / 100 / cell_gran_rnd) *cell_gran_rnd;
        right_margin = left_margin;
        top_margin = round(margin_per / 100 * v_lines_rnd);
        bot_margin = top_margin;
    }

    /* For the calculations below, refer to the VESA GTF v1.1 spec */

    /* Estimate the horizontal period */
    double h_period_est = ((1 / v_field_rate_reqd) - min_vsync_and_bp/1000000)
             / (v_lines_rnd + (2 * top_margin) + min_porch + interlace)
             * 1000000;

    /* Find the number of lines in V sync + B Porch */
    double vsync_and_bp = round(min_vsync_and_bp / h_period_est);

    /* Find number of lines in back porch alone */
    double v_back_porch = vsync_and_bp - v_sync_rqd;

    /* Find the total number of lines in the vertical field period */
    double total_v_lines = v_lines_rnd + top_margin + bot_margin + vsync_and_bp + interlace + min_porch;

    /* Estimate the vertical field frequency */
    double v_field_rate_est = 1/h_period_est/total_v_lines * 1000000;

    /* Find the actual horizontal period */
    double h_period = h_period_est / (v_field_rate_reqd / v_field_rate_est);

    /* Find the actual vertical field frequency */
    double v_field_rate = 1/h_period/total_v_lines * 1000000;

    /* Find the vertical frame frequency */
    if (int_rqd == 1) {
      v_field_rate = v_field_rate / 2;
    }

    /* GTF calculates margins using a percentage here. We use actual pixels */
    /* (and 0 always at present) */

    double total_active_pixels = h_pixels_rnd + left_margin + right_margin;

    /* Find the ideal blanking duty cycle from the blanking duty cycle equation */
    double ideal_duty_cycle = C - (M * h_period / 1000);

    /* Find the number of pixels in the blanking time to the nearest double */
    /* character cell */
    double h_blank_pixels = (round(total_active_pixels * ideal_duty_cycle / (100 - ideal_duty_cycle) / (2 * cell_gran_rnd))) * (2 * cell_gran_rnd);

    /* Find the total number of pixels */
    double total_pixels = total_active_pixels + h_blank_pixels;

    /* Find pixel clock frequency */
    double pixel_freq = total_pixels / h_period;

    /* Find horizontal frequency */
    /* double h_freq = 1000 / h_period; */

    /*
     * From GTF spec - Using Stage 1 parameters to derive stage 2 parameters
     */

    /* Find addressable lines per frame */
    double addr_lines_per_frame;
    if (int_rqd == 1) {
        addr_lines_per_frame = v_lines_rnd * 2;
    }
    else {
        addr_lines_per_frame = v_lines_rnd;
    }

    /* Find the total number of lines in a frame: */
    double total_lines_per_frame = v_lines_rnd + top_margin + bot_margin + vsync_and_bp + interlace + min_porch;
    if (int_rqd == 1) {
        total_lines_per_frame = total_lines_per_frame * 2;
    }

    /* Find the number of pixels in the horizontal sync period */
    double h_sync_pixels = (round(h_sync_percent/100 * total_pixels
      / cell_gran_rnd)) * cell_gran_rnd;

    /* Find the number of pixels in the horizontal front porch period */
    double h_front_porch = (h_blank_pixels / 2) - h_sync_pixels;

    double h_back_porch = h_front_porch + h_sync_pixels;

    /* Find the odd front porch period (lines) (36) */
    double v_fporch = min_porch + interlace;

    mode_desc->definition.xres = (int)h_pixels;
    mode_desc->definition.yres = (int)v_lines;
    mode_desc->definition.hpar[FR_SYNC] = (int) h_sync_pixels;
    mode_desc->definition.hpar[FR_BPCH] = (int) h_back_porch;
    mode_desc->definition.hpar[FR_BDR1] = (int) left_margin;
    mode_desc->definition.hpar[FR_DISP] = (int) h_pixels;
    mode_desc->definition.hpar[FR_BDR2] = (int) right_margin;
    mode_desc->definition.hpar[FR_FPCH] = (int) h_front_porch;
    mode_desc->definition.vpar[FR_SYNC] = (int) v_sync_rqd;
    mode_desc->definition.vpar[FR_BPCH] = (int) v_back_porch;
    mode_desc->definition.vpar[FR_BDR1] = (int) top_margin;

    if (int_rqd) {
        mode_desc->definition.vpar[FR_DISP] = (int) v_lines / 2;
    }
    else
    {
        mode_desc->definition.vpar[FR_DISP] = (int) v_lines;
    }

    mode_desc->definition.vpar[FR_BDR2] = (int) bot_margin;
    mode_desc->definition.vpar[FR_FPCH] = (int) v_fporch;
    mode_desc->definition.pixel_khz = (int) round(pixel_freq * 1000);
    mode_desc->definition.external_clock = -1;
    if (timing_support == EDID_USE_GTF) {
        mode_desc->definition.syncpol = HSync_Negative+VSync_Positive; /* Default GTF */
    }
    else
    {
        mode_desc->definition.syncpol = HSync_Positive+VSync_Negative; /* Secondary GTF */
    }
    mode_desc->definition.interlaced = int_rqd;

    sprintf(mode_desc->definition.name, "%d x %d", (int)h_pixels, (int)v_lines);
    compute_modedescription(mode_desc);

    if (add_proposed_mode(monitor, mode_desc) == 0) {
      free(mode_desc);
    }

#if DODEBUG
    display_mode_parameters(mode_desc);
#endif
}

static void generate_mode_using_cvt_rb(double h_pixels, double v_lines, double ip_freq_rqd, ModeDescriptionRef mode_desc, MonitorDescriptionRef monitor)
{
    const int int_rqd = 0; /* int_rqd specifies whether the mode should be interlaced. Most modes used are not. */
    const int margins_rqd = 0; /* Set to 1 if margins are wanted. */
    const double margin_per = 0; /* Percentage size of margin (0 to 100) if reqd */
    double cell_gran_rnd = 8; /* Character cell width in pixels. May be able to confirm this value in hardware but at present hardcode this to 8 (usual value), */
    double v_field_rate_reqd = 0; /* The actual vertical field rate after interlacing is taking into consideration */
    double v_lines_rnd = 0; /* Number of desired visible lines rounded down to the nearest character cell */
    double interlace = 0; /* If interlacing is used, this will be set to 0.5 */

    /* Determine the aspect ratio and set the v_sync_rnd variable */
    /* This is a slightly messy lookup table - VESA recommends the lookup */
    /* approach. We match on X, but in some cases we need to also check Y if */
    /* there are other modes with different heights */
    int v_sync_rnd = 0;

    if ((h_pixels == 640)  ||
        (h_pixels == 800)  ||
        (h_pixels == 1024) ||
        (h_pixels == 1400) ||
        (h_pixels == 1600) ||
        (h_pixels == 1920) ||
        (h_pixels == 2048) ||
        (h_pixels == 2560) ||
        (h_pixels == 3200) ||
        (h_pixels == 3840)) {
        v_sync_rnd = 4;
    }

    if ((h_pixels == 1280) && ((v_lines == 1024) || (v_lines == 768))) {
      v_sync_rnd = 7;
    }

    if ((h_pixels == 848) ||
        (h_pixels == 1064) ||
        ((h_pixels == 1280) && (v_lines == 720)) ||
        (h_pixels == 1360) ||
        (h_pixels == 1704) ||
        (h_pixels == 1864) ||
        ((h_pixels == 1920) && (v_lines == 1080)) ||
        (h_pixels == 2128) ||
        (h_pixels == 2560) ||
        (h_pixels == 2728) ||
        (h_pixels == 3408) ||
        (h_pixels == 4264)) {
        v_sync_rnd = 5;
    }

    if ((int) (h_pixels / v_lines * 10) == 16) {
        v_sync_rnd = 6;
    }

    if (v_sync_rnd == 0) {
#if DODEBUG
      printf("Error - Cannot handle this aspect ratio\n");
#endif
      /* If this happens we should just ignore the mode */
      free(mode_desc);
      return;
    }

    /* The variable names used below are those in the VESA Coordinated Timings
     *  Standard. I've kept this code as close to the original as possible for
     *  clarity at the cost of some speed. When this works 110%, this can be
     *  optimised out.
     */

    /* Find the refresh rate required (Hz) */

    /* If interlaced, the number of vertical lines assumed by the */
    /* calculation must be halved, as the computation calculates the */
    /* number of vertical lines per field. In either case, the number */
    /* of lines is rounded down to the nearest integer. */

    if (int_rqd == 1)
    {
        v_lines_rnd = floor(v_lines / 2);
        v_field_rate_reqd = ip_freq_rqd * 2;
        interlace = 0.5;
    }
    else
    {
        v_lines_rnd = floor(v_lines);
        v_field_rate_reqd = ip_freq_rqd;
        /* Interlace is automatically set to 0 */
    }

    /* Round the number of pixels to the nearest character cell boundary */
    double h_pixels_rnd = (floor(h_pixels/cell_gran_rnd)) * cell_gran_rnd;

    /* Determine the width of the left and right borders */
    double left_margin = 0; /* Number of pixels in the left hand margin, rounded down to the nearest character cell. If no margins required this is set to 0. */
    double right_margin = 0; /* see left_margin */
    double top_margin = 0; /* No of lines rounded down to nearest line. */
    double bot_margin = 0; /* See top, left, right */

    if (margins_rqd == 1)
    {
        left_margin = floor(h_pixels_rnd * margin_per / 100 / cell_gran_rnd) *cell_gran_rnd;
        right_margin = left_margin;
        top_margin = floor(margin_per / 100 * v_lines_rnd);
        bot_margin = top_margin;
    }

    /* Minimum vertical back porch (used in both sets of calcs). */
    const double min_v_bporch = 6;

    /* The total number of active pixels is equal to the rounded */
    /* horizontal pixels and the margins: */
    double total_active_pixels = h_pixels_rnd + left_margin + right_margin;

    /* Pixel clock resolution - see CVT spec S3.2 */
    const double clock_step = 0.25;

    /* Define back porch (used in our final block) */
    int v_back_porch;

    /* Define actual pixel frequency (for final block) */
    double act_pixel_freq;

    /* H blanking period (for final block) */
    int h_blank;

    /* H sync (for final block) */
    int h_sync;

    /* V front porch (NB in CVT this is min_v_porch_rnd and in CVT-RB this is */
    /* rb_v_fporch but as they are both constants declare them. */
    double v_front_porch = 3;

    if (timing_support == EDID_USE_CVT)
    {
        /* Computation of "CRT" (ie non-RB) CVT timings */
        /* Minimum timng for vertical blanking for 'CRT' timings */
        const double min_vsync_bp = 550;
        /* Standard 'CRT' timing vertical front porch */

        /* Estimate the horizontal period (kHz) */
        double h_period_est = ((1 / v_field_rate_reqd) - min_vsync_bp / 1000000) / (v_lines_rnd + (2 * top_margin) + v_front_porch + interlace) * 1000000;
        /* Find the number of lines in V sync + back porch */
        double v_sync_bp = floor(min_vsync_bp / h_period_est) + 1;
        if (v_sync_bp < v_sync_rnd + min_v_bporch) {
            v_sync_bp = v_sync_rnd + min_v_bporch;
        }

        /* Find the number of lines in V back porch */
        v_back_porch = (int) (v_sync_bp - v_sync_rnd);

        /* Find total number of lines in vertical field period */
        double total_v_lines = v_lines_rnd + top_margin + bot_margin + v_sync_bp + interlace + v_front_porch;

        /* C_PRIME = ((C-J) * K / 256 + J (from CVT spec) */
        const double c_prime = 30;

        /* M_PRIME = K / 256 * M (from CVT spec) */
        const double m_prime = 300;

        /* Find the ideal blanking duty cycle from the blanking duty cycle equation (%): */
        double ideal_duty_cycle = c_prime - (m_prime * h_period_est / 1000);

        /* Find the number of pixels in the horizontal blanking time to the nearest double character cell */
        /* (limit horizontal blanking so that it is >= 20% of the horizontal total). */
        if (ideal_duty_cycle < 20)
        {
            h_blank = (int) (floor(total_active_pixels * 20 / (100-20) / (2 * cell_gran_rnd)) * (2 * cell_gran_rnd));
        }
        else
        {
            h_blank = (int) (floor(total_active_pixels * ideal_duty_cycle / (100 - ideal_duty_cycle) / (2 * cell_gran_rnd)) * (2 * cell_gran_rnd));
        }

        /* Find the total number of pixels in a line */
        double total_pixels = total_active_pixels + h_blank;

        /* Find pixel clock frequency (MHz): */
        act_pixel_freq = clock_step * floor((total_pixels / h_period_est) / clock_step);

        /* Find actual horizontal frequency (kHz) */
        double act_h_freq = 1000 * act_pixel_freq / total_pixels;

        /* Find actual field rate (Hz) */
        double act_field_rate = 1000 * act_h_freq / total_v_lines;

        /* Find actual refresh rate (Hz) */
        double act_frame_rate = act_field_rate;
        if (int_rqd == 1) {
            act_frame_rate = act_field_rate / 2;
        }

        /* H sync per is the percentage of horizontal total period that */
        /* defines horizontal sync width */
        const double h_sync_per = 8;

        /* Calculate H sync */
        h_sync = (int) (floor(h_sync_per / 100 * total_pixels / cell_gran_rnd) * cell_gran_rnd);
    }
    else
    {
        /* Computation of Reduced Blanking timing parameters. */

        /* Estimate the horizontal period (kHZ) */
        const double rb_min_v_blank = 460; /* Min V blank for reduced timings */
        double h_period_est = ((1000000/v_field_rate_reqd) - rb_min_v_blank) / (v_lines_rnd + top_margin + bot_margin);

        double vbi_lines = floor(rb_min_v_blank / h_period_est) + 1;

        /* Vertical front porch is fixed in reduced blanking */
        v_front_porch = 3;

        double rb_min_vbi = v_front_porch + v_sync_rnd + min_v_bporch;

        double act_vbi_lines; /* Actual number of vertical blanking lines */
        if (vbi_lines < rb_min_vbi) {
          act_vbi_lines = rb_min_vbi;
        }
        else {
          act_vbi_lines = vbi_lines;
        }

        double total_v_lines = act_vbi_lines + v_lines_rnd + top_margin + bot_margin + interlace;

        h_sync = 32;   /* H sync is fixed in reduced blanking */
        h_blank = 160; /* H Blank is fixed in reduced blanking */

        /* Find total number of pixel clocks per line */
        double total_pixels = h_blank + total_active_pixels;

        const double clock_step = 0.25;

        /* Calculate the pixel clock frequency to nearest 0.125MHz */
        act_pixel_freq = clock_step * floor(v_field_rate_reqd * total_v_lines * total_pixels / 1000000) / clock_step;

        /* Find the number of lines in V_sync + back porch: */
        v_back_porch = (int) (act_vbi_lines - v_front_porch - v_sync_rnd);
    }

    /* Calculate front and back porch */
    int h_back_porch = h_blank / 2;
    int h_front_porch = h_blank - h_back_porch - h_sync;

    /* Now populate the mode definition block */
    mode_desc->definition.xres = (int)h_pixels;
    mode_desc->definition.yres = (int)v_lines;
    mode_desc->definition.hpar[FR_SYNC] = h_sync;
    mode_desc->definition.hpar[FR_BPCH] = h_back_porch;
    mode_desc->definition.hpar[FR_BDR1] = (int) left_margin;
    mode_desc->definition.hpar[FR_DISP] = (int) h_pixels;
    mode_desc->definition.hpar[FR_BDR2] = (int) right_margin;
    mode_desc->definition.hpar[FR_FPCH] = h_front_porch;
    mode_desc->definition.vpar[FR_SYNC] = (int) v_sync_rnd;
    mode_desc->definition.vpar[FR_BPCH] = v_back_porch;
    mode_desc->definition.vpar[FR_BDR1] = (int) top_margin;
    if (int_rqd) {
        mode_desc->definition.vpar[FR_DISP] = (int) v_lines / 2;
    }
    else
    {
        mode_desc->definition.vpar[FR_DISP] = (int) v_lines;
    }
    mode_desc->definition.vpar[FR_BDR2] = (int) bot_margin;
    mode_desc->definition.vpar[FR_FPCH] = (int) v_front_porch;
    mode_desc->definition.pixel_khz = (int) (act_pixel_freq * 1000);
    mode_desc->definition.external_clock = -1;
    if (timing_support == EDID_USE_CVT) {
        mode_desc->definition.syncpol = HSync_Negative+VSync_Positive;
    }
    else /* EDID_USE_CVTRB */
    {
        mode_desc->definition.syncpol = HSync_Positive+VSync_Negative;
    }
    mode_desc->definition.interlaced = int_rqd;

    sprintf(mode_desc->definition.name, "%d x %d", (int)h_pixels, (int)v_lines);
    compute_modedescription(mode_desc);

    if (add_proposed_mode(monitor, mode_desc) == 0) {
      free(mode_desc);
    }

#if DODEBUG
    display_mode_parameters(mode_desc);
#endif
}

static _kernel_oserror *generate_standard_timing(char std1, char std2, MonitorDescriptionRef monitor)
{
    ModeDescriptionRef mode_desc = NULL;
    /* If this mode is defined as a DMT standard, use this by checking the */
    /* bytes directly with the lookup table */
    int i = 0;

#if DODEBUG
    printf("Standard Timing (%x %x) ", std1, std2);
#endif

    while (std_timings[i].stdcode[0] || std_timings[i].stdcode[1])
    {
        if ((std1 == std_timings[i].stdcode[0]) && (std2 == std_timings[i].stdcode[1]))
        {
            mode_desc = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
            if (mode_desc == NULL) {
                return error (ERR_NOSPACE, 0, 0, 0);
            }
            mode_desc->definition = display_monitor_timings[std_timings[i].dmt-1];
            compute_modedescription(mode_desc);
            mode_desc->frame_hz = display_monitor_timings[std_timings[i].dmt-1].freq;
            mode_desc->priority = 5;

#if DODEBUG
            printf("(derived from DMT standard):\n");
            display_mode_parameters(mode_desc);
#endif

            if (add_proposed_mode(monitor, mode_desc) == 0) {
              free(mode_desc);
            }
            return NULL;
        }
        i++;
    }

    /* If it's not in the DMT lookups and we can generate a timing, do so */
    if (timing_support != EDID_USE_DMT)
    {
        int yres = 0;
        int xres = (std1 + 31) * 8;
        char pixel_ratio_flags = (std2 & 0xC0);
        if (pixel_ratio_flags == 0) { /* 00 = 16:10 */
          yres = (int) ((xres * 10) / 16);
        }
        if (pixel_ratio_flags == (1<<6)) { /* 01 = 4:3 */
          yres = (int) ((xres * 3) / 4);
        }
        if (pixel_ratio_flags == (1<<7)) { /* 10 = 5:4 */
          yres = (int) ((xres * 4) / 5);
        }
        if (pixel_ratio_flags == ((1<<7) + (1<<6))) { /* 11 = 16:9 */
          yres = (int) ((xres * 9) / 16);
        }

        int freq = (std2 & 0x3f) + 60;

        mode_desc = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
        if (mode_desc == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
        }
#if DODEBUG
        printf("(calculated):\n");
#endif

        if ((timing_support == EDID_USE_GTF) ||
            (timing_support == EDID_USE_GTF2))
        {
            generate_mode_using_gtf(xres, yres, freq, mode_desc, monitor);
        }
        if ((timing_support == EDID_USE_CVT) ||
            (timing_support == EDID_USE_CVTRB))
        {
            generate_mode_using_cvt_rb(xres, yres, freq, mode_desc, monitor);
        }

    }
    return NULL;
}


/*
 *  Generates a mode from a 3-byte CVT code
 *  NB this is UNTESTED as I haven't got an appropriate EDID to test from
 */
static _kernel_oserror *generate_cvt3_timing(char cvt1, char cvt2, char cvt3, MonitorDescriptionRef monitor)
{
    ModeDescriptionRef mode_desc = NULL;
    /* If this mode is defined as a DMT standard, use this by checking the */
    /* bytes directly with the lookup table */

#if DODEBUG
    printf("CVT 3-byte Timing (%x %x %x) ", cvt1, cvt2, cvt3);
#endif

    /* Check the reserved bits are 00. If not, let this mode fail silently */
    if ((cvt2 & 0x03) != 0) {
#if DODEBUG
      printf("has unknown values in the reserved bits of byte 2 - skipped.\n");
#endif
      return NULL;
    }

#ifdef DERIVE_CVT3_FROM_DMT
    int i = 0;
    while (cvt_timings[i].cvtcode[0] || cvt_timings[i].cvtcode[1] || cvt_timings[i].cvtcode[2])
    {
        if ((cvt1 == cvt_timings[i].cvtcode[0]) && (cvt2 == cvt_timings[i].cvtcode[1]) && (cvt3 == cvt_timings[i].cvtcode[2]))
        {
            mode_desc = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
            if (mode_desc == NULL) {
                return error (ERR_NOSPACE, 0, 0, 0);
            }
            mode_desc->definition = display_monitor_timings[cvt_timings[i].dmt-1];
            compute_modedescription(mode_desc);
            mode_desc->frame_hz = display_monitor_timings[cvt_timings[i].dmt-1].freq;
            mode_desc->priority = 4; /* CVT timing */

#if DODEBUG
            printf("(derived from DMT standard):\n");
            display_mode_parameters(mode_desc);
#endif

            if (add_proposed_mode(monitor, mode_desc) == 0) {
              free(mode_desc);
            }
            return NULL;
        }
        i++;
    }
#endif

    /* If it's not in the DMT lookups and we can generate a timing, do so */
    if ((mode_desc == NULL) && (timing_support != EDID_USE_DMT))
    {
        int vsize = cvt1 + ((cvt2 & 0xf0)<<4);
        int yres = (vsize+1)*2;
        int xres = 0;
        int freq = 0;

        /* Use the vertical line count to generate the horizontal addressable
         * Resolution (HAdd). Use 8 X {RoundDown[(VAdd X Aspect ratio / 8]}
         * Per the EDID guidance (p48). */
        char pixel_ratio_flags = (cvt2 & 0x0c)>>2;
        switch (pixel_ratio_flags)
        {
          case 0:
            xres = (int) (8 * floor((((double) yres * 4) / 3) / 8));
            break;
          case 1:
            xres = (int) (8 * floor((((double) yres * 16) / 9) / 8));
            break;
          case 2:
            xres = (int) (8 * floor((((double) yres * 16) / 10) / 8));
            break;
          case 3:
            xres = (int) (8 * floor((((double) yres * 15) / 9) / 8));
            break;
        }

        /* First generate a descriptor using the display-preferred frequency
         * (bits 5 and 6 of cvt3) */
        switch ((cvt3 & 0x60) >> 5)
        {
          case 0:
            freq = 50;
            break;
          case 1:
            freq = 60;
            break;
          case 2:
            freq = 75;
            break;
          case 3:
            freq = 85;
            break;
        }
        if (freq != 0)
        {
          mode_desc = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
          if (mode_desc == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
          }
#if DODEBUG
          printf("\nAt %x Hz (calculated):\n", freq);
#endif
          generate_mode_using_cvt_rb(xres, yres, freq, mode_desc, monitor);
          if (add_proposed_mode(monitor, mode_desc) == 0) {
            free(mode_desc);
          }
        }
        int preferred_freq = freq;

        /* Now we add any other frequencies it supports */

        /* Use timing_support to switch the timing method we use in the
         * CVT calculations and restore it at the end */
        int timing_support_preferred = timing_support;

        for(int supported_freq=0; supported_freq<5; supported_freq++)
        {
          if ((cvt3 & (1<<supported_freq)) == (1<<supported_freq))
          {
            switch (supported_freq)
            {
              case 0:
                freq = 60;
                timing_support = EDID_USE_CVTRB;
              case 1:
                freq = 85;
                timing_support = EDID_USE_CVT;
              case 2:
                freq = 75;
                timing_support = EDID_USE_CVT;
              case 3:
                freq = 60;
                timing_support = EDID_USE_CVT;
              case 4:
                freq = 50;
                timing_support = EDID_USE_CVT;
            }

            if (freq != preferred_freq)
            {
              mode_desc = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
              if (mode_desc == NULL) {
                return error (ERR_NOSPACE, 0, 0, 0);
              }
#if DODEBUG
              printf("\nAt %x Hz (calculated):\n", freq);
#endif
              generate_mode_using_cvt_rb(xres, yres, freq, mode_desc, monitor);
              if (add_proposed_mode(monitor, mode_desc) == 0) {
                free(mode_desc);
              }
            }
          }
        }
        timing_support = timing_support_preferred;

    }
    return NULL;
}


/*  dtd_block_to_modedesc converts a detailed timing descriptor block
 *  into a mode descriptor block. The defines above help it pick out
 *  the data which is split across nibbles into the parameters.
 *  dtd_data on entry should be a pointer to the first byte of the 18 byte
 *  dtd block.
 */
static bool dtd_block_to_modedesc(char* dtd_data, ModeDescriptionRef mode_desc)
{
#if DODEBUG
    printf("Detailed timing descriptor:\n");
#endif
    mode_desc->definition.xres          = dtd_data[2] + ((dtd_data[4] & 0xf0) << 4);
    mode_desc->definition.yres          = dtd_data[5] + ((dtd_data[7] & 0xf0) << 4);
    mode_desc->definition.interlaced    = ((dtd_data[17]>>7) & 1);
    mode_desc->definition.hpar[FR_SYNC] = dtd_data[9] + ((dtd_data[11] & 0x30) << 4);
    mode_desc->definition.hpar[FR_BDR1] = dtd_data[15];
    mode_desc->definition.hpar[FR_DISP] = mode_desc->definition.xres;
    mode_desc->definition.hpar[FR_BDR2] = dtd_data[15];
    mode_desc->definition.hpar[FR_FPCH] = dtd_data[8] + ((dtd_data[11] & 0xc0) << 2);
    mode_desc->definition.hpar[FR_BPCH] = dtd_data[3] + ((dtd_data[4] & 0x0f) << 8) -
                                          mode_desc->definition.hpar[FR_SYNC] -
                                          mode_desc->definition.hpar[FR_FPCH] -
                                          mode_desc->definition.hpar[FR_BDR1] -
                                          mode_desc->definition.hpar[FR_BDR2];
    mode_desc->definition.vpar[FR_SYNC] = (dtd_data[10] & 0xf) + ((dtd_data[11] & 0x3) << 4);
    mode_desc->definition.vpar[FR_BDR1] = dtd_data[16];
    mode_desc->definition.vpar[FR_DISP] = mode_desc->definition.yres;
    mode_desc->definition.vpar[FR_BDR2] = dtd_data[16];
    mode_desc->definition.vpar[FR_FPCH] = (dtd_data[10] >> 4) + ((dtd_data[11] & 0xc) << 2);
    mode_desc->definition.vpar[FR_BPCH] = dtd_data[6] + ((dtd_data[7] & 0x0f) << 8) -
                                          mode_desc->definition.vpar[FR_SYNC] -
                                          mode_desc->definition.vpar[FR_FPCH] -
                                          mode_desc->definition.vpar[FR_BDR1] -
                                          mode_desc->definition.vpar[FR_BDR2];
    mode_desc->definition.pixel_khz     = (dtd_data[0] + (dtd_data[1]<<8)) * 10;
    mode_desc->definition.external_clock = -1;

    /* Only accept non-stereoscopic modes
     * Technically we should check for sync here (since we only really support
     * digital separate syncs), but for now we'll assume that misrepresenting
     * the sync isn't going to cause major problems, as it will allow more
     * modes to work (e.g. BenQ FP241W HDMI port advertises 1080p as being
     * serrated sync-on-RGB, even though the monitor is perfectly happy with
     * digital syncs)
     */
    if ((dtd_data[17] & 0x60) != 0x00) {
#if DODEBUG
        printf("Rejecting DTD due to unsupported frame format\n");
#endif
        return false;
    }

    /* -----00- is negative-negative, start with that and then invert if necessary */
    mode_desc->definition.syncpol = HSync_Negative+VSync_Negative;
    if (dtd_data[17] & 4) {
        mode_desc->definition.syncpol ^= VSync_Negative^VSync_Positive;
    }
    if (dtd_data[17] & 2) {
        mode_desc->definition.syncpol ^= HSync_Negative^HSync_Positive;
    }

    /* If we are interlaced, we need to double the number of vertical pixels */
    if (mode_desc->definition.interlaced == 1) {
          mode_desc->definition.yres = mode_desc->definition.yres * 2;

    }

    sprintf(mode_desc->definition.name, "%d x %d", mode_desc->definition.xres, mode_desc->definition.yres);
    compute_modedescription(mode_desc);

#if DODEBUG
    display_mode_parameters(mode_desc);
#endif

    return true;
}


/* Get extd type checks the 18-byte data blocks for their type
 * The type returned is then either 10 (empty), 0 (detailed mode descriptor)
 * or other type numbers per the EDID specification
 */
static int get_extd_type(EDIDBlockRef edidblockref, int block_no)
{
    if (edidblockref->data_block[block_no][0] + edidblockref->data_block[block_no][1] + edidblockref->data_block[block_no][2] == 0)
    {
        return edidblockref->data_block[block_no][3];
    }
    else
    {
        return -1; /* -1 = display descriptor */
    }
}

/* Add to our list of audio formats */
static _kernel_oserror *add_audio_format(uint8_t byte1, uint8_t byte2, uint8_t byte3, MonitorDescriptionRef new_monitor)
{
    AudioFormat newformat;
    newformat.format_code = (byte1 >> 3) & 0x7f;
    newformat.max_channels = (byte1 & 7) + 1;
    newformat.sample_rates = byte2;
    newformat.format_specific = byte3;
    /* Discard if bogus */
    if ((!newformat.sample_rates) || ((newformat.format_code == 1) && !(newformat.format_specific)))
    {
        return NULL;
    }
    /* Work out where to merge it into our list
     * CEA 861-D doesn't state what we should do if multiple descriptors are
     * found for the same format code, so we should be conservative with how
     * we merge blocks together
     */
    int i;
    for (i=0;i<new_monitor->audio_format_count;i++)
    {
        AudioFormat *candidate = &new_monitor->audio_formats[i];
        if (candidate->format_code > newformat.format_code)
        {
            break;
        }
        else if (candidate->format_code < newformat.format_code)
        {
            continue;
        }
        /* Try and merge with this entry
         * note - currently not doing any fancy merging of the format-specific
         * byte (could be a bit tricky for LPCM depending on what future meaning
         * is given to the reserved bits)
         */
        if (newformat.format_specific == candidate->format_specific)
        {
            if (newformat.max_channels == candidate->max_channels)
            {
                /* Merge our list of sample rates into the candidate and call
                 * it a day.
                 */
                candidate->sample_rates |= newformat.sample_rates;
                return NULL;
            }
            else if (newformat.max_channels < candidate->max_channels)
            {
                /* Candidate supports more channels than us with same
                 * format-specific settings, so ignore any sample rates which
                 * the candidate supports.
                 */
                newformat.sample_rates &= ~candidate->sample_rates;
                if (!newformat.sample_rates)
                {
                    return NULL;
                }
            }
            else if (newformat.max_channels > candidate->max_channels)
            {
                /* We support more channels than the candidate, so remove
                 * sample rates from the candidate.
                 */
                candidate->sample_rates &= ~newformat.sample_rates;
                if (!candidate->sample_rates)
                {
                    /* Candidate can be removed completely */
                    new_monitor->audio_format_count--;
                    memmove(candidate, candidate+1, sizeof(AudioFormat)*(new_monitor->audio_format_count-i));
                    void *new = realloc(new_monitor->audio_formats, new_monitor->audio_format_count*sizeof(AudioFormat));
                    if (new)
                    {
                        new_monitor->audio_formats = (AudioFormat*) new;
                    }
                    /* Everything's been shuffled down, so process this entry
                     * again.
                     */
                    i--;
                    continue;
                }
            }
        }
    }
    /* Need to insert a new entry */
    void *new = realloc(new_monitor->audio_formats, (new_monitor->audio_format_count+1)*sizeof(AudioFormat));
    if (!new)
    {
        return error(ERR_NOSPACE, 0, 0, 0);
    }
    new_monitor->audio_formats = (AudioFormat*) new;

    /* Shuffle following entries up */
    memmove(new_monitor->audio_formats+i+1, new_monitor->audio_formats+i, sizeof(AudioFormat)*(new_monitor->audio_format_count-i));

    new_monitor->audio_format_count++;
    new_monitor->audio_formats[i] = newformat;

    return NULL;
}

/* Process an audio data block from a CEA extension block */
static _kernel_oserror *process_cea_audio_data_block(EDIDExtensionBlockRef ext_block, int length, const uint8_t *block, MonitorDescriptionRef new_monitor)
{
    while (length >= 3)
    {
#if DODEBUG
        printf("CEA Short Audio Descriptor %02x %02x %02x\n",block[0],block[1],block[2]);
#endif
        /* Ignore if any reserved bits in the first couple of bytes are set */
        if (!(block[0] & 128) && !(block[1] & 128))
        {
            _kernel_oserror *err = add_audio_format(block[0], block[1], block[2], new_monitor);
            if (err)
            {
                return err;
            }
        }
        block += 3;
        length -= 3;
    }
    return NULL;
}

/* Process a video data block from a CEA extension block */
static _kernel_oserror *process_cea_video_data_block(EDIDExtensionBlockRef ext_block, int length, const uint8_t *block, MonitorDescriptionRef new_monitor)
{
    /* TODO: Parse SVDs and add to mode list */
    return NULL;
}

/* Process a speaker allocation block from a CEA extension block */
static _kernel_oserror *process_cea_speaker_allocation_data_block(EDIDExtensionBlockRef ext_block, int length, const uint8_t *block, MonitorDescriptionRef new_monitor)
{
    if (length == 3)
    {
#if DODEBUG
        printf("CEA Speaker Allocation %02x %02x %02x\n",block[0],block[1],block[2]);
#endif
        new_monitor->speaker_mask = block[0] & 0x7f;
        new_monitor->speaker_mask_provided = true;
    }
    return NULL;
}

/* Process a data block from a CEA extension block */
static _kernel_oserror *process_cea_data_block(EDIDExtensionBlockRef ext_block, int tag_code, int length, const uint8_t *block, MonitorDescriptionRef new_monitor)
{
    if (tag_code == 7)
    {
        /* Extended tag */
        tag_code = *block++;
        length--;
#if DODEBUG
        printf("CEA extended data block code %d data length %d\n",tag_code,length);
#endif
        /* TODO: Process any interesting ones */
        return NULL;
    }
#if DODEBUG
    printf("CEA data block code %d data length %d\n",tag_code,length);
#endif
    switch(tag_code)
    {
    case 1: return process_cea_audio_data_block(ext_block, length, block, new_monitor);
    case 2: return process_cea_video_data_block(ext_block, length, block, new_monitor);
    case 4: return process_cea_speaker_allocation_data_block(ext_block, length, block, new_monitor);
    default: return NULL;
    }
}

/* Process a CEA extension block */
static _kernel_oserror *process_cea_extension(EDIDExtensionBlockRef ext_block, MonitorDescriptionRef new_monitor)
{
    /* offset from the start of the extension block to the */
    /* first dtd in the extension block. Uses the offset from block+2. */
    const uint8_t *extdata = (uint8_t *) ext_block;
    int dtd_offset = extdata[2];

    if (dtd_offset > (126 - 18))
    {
        /* Bogus DTD offset, ignore block */
        return NULL;
    }

    bool basic_audio = (ext_block->revision >= 2) && (extdata[3] & 0x40);
    if (basic_audio)
    {
#if DODEBUG
        printf("Basic audio supported\n");
#endif
        /* 2-ch LPCM at 32kHz, 44.1kHz, 48kHz
         * Assume 16/20/24bit supported (spec is a bit vague, but in reality it
         * shouldn't matter that much because they all get packaged the same)
         */
        _kernel_oserror *err = add_audio_format(0x9, 0x7, 0x7, new_monitor);
        if (err)
        {
            return err;
        }
    }

    if ((ext_block->revision >= 3) && (dtd_offset > 4))
    {
        /* CEA Data Block Collection present */
        int block_offset = 4;
        while (block_offset < dtd_offset)
        {
            int tag_code = extdata[block_offset] >> 5;
            int length = extdata[block_offset] & 0x1f;
            block_offset++;
            if (!tag_code || !length || (length > (dtd_offset-block_offset)))
            {
                /* Bad block length or invalid tag code. TODO - Should probably throw away everything we've learnt so far from this extension block. */
                return NULL;
            }
            _kernel_oserror *err = process_cea_data_block(ext_block, tag_code, length, extdata+block_offset, new_monitor);
            if (err)
            {
                return err;
            }
            block_offset += length;
        }
    }

    if (dtd_offset < 4) {
        /* No DTD's provided in this block */
        return NULL;
    }

    while ((dtd_offset <= (126 - 18)) &&
           (extdata[dtd_offset] != 0) && (extdata[dtd_offset+1] != 0))
    {
        ModeDescriptionRef mp;
        mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
        if (mp == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
        }

        if (!dtd_block_to_modedesc((char *) &(extdata[dtd_offset]), mp)) {
            free(mp);
        }
        else
        {
            mp->priority = 3;
            if (add_proposed_mode(new_monitor, mp) == 0) {
                free(mp);
            }
        }
        dtd_offset += 18; /* 18 is the size of a DTD block */
    }

    return NULL;
}

/* Process a VTB extension block */
static _kernel_oserror *process_vtb_extension_block(EDIDExtensionBlockRef ext_block, MonitorDescriptionRef new_monitor)
{
    _kernel_oserror *res = NULL;
    const uint8_t *extdata = (uint8_t *) ext_block;

    /* 'w', 'y' and 'z' originate from the VTB specification */
    /* 'w' is the number of detailed timing blocks (DTB) */
    int w = extdata[2];
    /* 'y' is the number of CVT descriptions */
    int y = extdata[3];
    /* 'z' is the number of standard timing descriptions */
    int z = extdata[4];

    /* There's only space for 122 bytes of timing data. If the block looks like it needs more than that then it's a bad block. */
    if (w*0x12 + y*0x3 + z*0x2 > 122) {
        return NULL;
    }
    /* Unused bytes should be zero */
    for (int byte = 0x5 + w*0x12 + y*0x3 + z*0x2; byte < 127; byte++) {
        if (extdata[byte]) {
            return NULL;
        }
    }

    for (int dtb_blockno = 0; dtb_blockno < w; dtb_blockno++)
    {
        ModeDescriptionRef mp;
        mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
        if (mp == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
        }

        if (!dtd_block_to_modedesc((char *) &(extdata[0x5 + dtb_blockno*0x12]), mp)) {
            free(mp);
        }
        else
        {
            mp->priority = 3;
            if (add_proposed_mode(new_monitor, mp) == 0) {
                free(mp);
            }
        }
    }

    for (int cvt_blockno = 0; cvt_blockno < y; cvt_blockno++)
    {
        ModeDescriptionRef mp;
        mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
        if (mp == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
        }
        int cvt_byte = 0x5 + w*0x12 + cvt_blockno*0x3;
        if (!((extdata[cvt_byte] == 0) &&
            (extdata[cvt_byte+1] == 0) &&
            (extdata[cvt_byte+2] == 0))) {

            res = generate_cvt3_timing (extdata[cvt_byte], extdata[cvt_byte+1], extdata[cvt_byte+2], new_monitor);
            if (res) {
                return res;
            }
        }
    }

    for (int std_blockno = 0; std_blockno < z; std_blockno++)
    {
        ModeDescriptionRef mp;
        mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
        if (mp == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
        }
        int std_byte = 0x5 + w*0x12 + y*0x3 + std_blockno*0x2;
        if (!((extdata[std_byte] == 0x1) &&
            (extdata[std_byte+1] == 0x1))) {

            res = generate_standard_timing (extdata[std_byte], extdata[std_byte+1], new_monitor);
            if (res) {
                return res;
            }
        }
    }

    return NULL;
}

static _kernel_oserror *parseedid(char *ediddata, const char *file)
{
    _kernel_oserror *res = NULL;
    FILE *f = NULL;
    MonitorDescriptionRef new_monitor;
    ModeDescriptionRef new_preferred_mode = NULL; /* No preferred mode */
    EDIDBlockRef edidblockref = (EDIDBlockRef) ediddata;
    int RangeBlock = -1;                          /* edid block containing timimg limits */

    /* OK, commit to reading a monitor description - go allocate space */
    new_monitor = (MonitorDescriptionRef) malloc (sizeof(MonitorDescription));
    if (new_monitor == NULL) {
        printf("Can't allocate space for monitor list\n");
        return error (ERR_NOSPACE, 0, 0, 0);
    }
    memset(new_monitor, 0, sizeof(MonitorDescription));

    strcpy(new_monitor->name,"Display");

    new_monitor->dpms_state = -1; /* DPMS -1 = Indicates not available */
    new_monitor->lcd_support = 0; /* 'CRT by default' - what does this do???*/
    new_monitor->output_format = -1; /* Output format */
    new_monitor->external_clock = -1; /* External clock not present */
    new_monitor->modelist = NULL; /* Make sure the mode list is initially nil. */

    /* If we are EDID 1.4 compliant or above GTF and CVT support should be */
    /* present. Use CVT in preference, fallback to DMT only */
    timing_support = EDID_USE_DMT; /* Default at DMT */
    if ((edidblockref->edid_version >= 1) && (edidblockref->edid_revision >= 4))
    {
#if DODEBUG
        printf("Use CVT; fallback to DMT if unavailable\n");
#endif
        timing_support = EDID_USE_CVT;
    }

    /* If we are EDID 1.4 compliant or above GTF support should be */
    /* present. Use GTF in preference, fallback to DMT only */
    if ((edidblockref->edid_version == 1) && ((edidblockref->edid_revision == 2) || (edidblockref->edid_revision == 3)))
    {
#if DODEBUG
        printf("Use GTF; fallback to DMT if unavailable\n");
#endif

        timing_support = EDID_USE_GTF;
    }
#if DODEBUG
    if (timing_support == EDID_USE_DMT)
    {
        printf("Use DMT only\n");
    }
    else
    {
      if ((edidblockref->feature_support & 1) == 1) {
          printf("This display supports continuous frequency modes (but we don't use this yet\n");
      }
      else {
          printf("This display supports only non-continuous frequency modes - use only the resolutions defined\n");
      }
    }
#endif

    /* Now if we have set force_timings as a debug option, override the */
    /* timing_support setting (debug option for testing calculations) */

#ifdef FORCE_TIMINGS
    timing_support = FORCE_TIMINGS;
#endif


    /* Next do each of the 2-byte 'standard timings' (Priority 5). */
    /* NB GTF support must be functional for these */
    for (int std_timing_code=0; std_timing_code<8;std_timing_code++)
    {
         if (!((edidblockref->standard_timings[std_timing_code*2] == 0x01) && (edidblockref->standard_timings[std_timing_code*2+1] == 0x01)))
         {
             res = generate_standard_timing(edidblockref->standard_timings[std_timing_code*2], edidblockref->standard_timings[std_timing_code*2+1], new_monitor);
             if (res)
             {
                 return res;
             }
        }
    }

    /* Sort the data blocks - store information strings and detailed */
    /* timing descriptors. Defer CVT codes and Established timings III */
    /* The first block is the 'preferred timing mode' and has highest */
    /* priority to go in the MDF. Any other 'detailed timing modes */
    /* have second priority so they will go in next */

    for (int blockno = 0; blockno < 4; blockno++)
    {
        switch (get_extd_type(edidblockref,blockno))
        {
            case -1: /* Normal descriptor block */
            {
#if DODEBUG
                printf("Data block\n");
#endif
                ModeDescriptionRef mp;
                mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
                if (mp == NULL) {
                    return error (ERR_NOSPACE, 0, 0, 0);
                }

                if (!dtd_block_to_modedesc((char *) &(edidblockref->data_block[blockno][0]), mp)) {
                    free(mp);
                }
                else
                {
#if DODEBUG
                    printf("Detailed Mode: %s, X: %i Y: %i\n", mp->definition.name,mp->definition.xres, mp->definition.yres);
#endif
                    if (add_proposed_mode(new_monitor, mp) == 0) {
                        free(mp);
                    }
                    else {
                        /* The first block should define the preferred mode */
                        if (blockno == 0) {
                            new_preferred_mode = mp;
                            mp->priority = 0x01;
                        }
                        else {
                            mp->priority = 0x02;
                        }
                    }
                }

                break;
            }
        case 0xFD: /* Display range limits */
#if DODEBUG
            printf ("Display range limits\n");
#endif
            RangeBlock = blockno; /* remember*/


            /* Not 100% sure about this but think this is how we pick up CVT-RB support */
            if (timing_support == EDID_USE_CVT)
            {
                char cvt_blanking = edidblockref->data_block[blockno][15];
                if ((cvt_blanking & 0x10) == 0x10) {
                    timing_support = EDID_USE_CVTRB;
                }
            }
            break;
        case 0xFC: /* Model name, will form title of Display menu */
           Get_DTD_ASCII(edidblockref, blockno, new_monitor->name);
#if DODEBUG
           printf("Model name: %s\n", new_monitor->name);
#endif
           break;
        case 0xf7:
#if DODEBUG
            printf("Established timings III");
#endif
            for (int timings_byte=0; timings_byte<6; timings_byte++)
            {
                for (int timings_bit=0; timings_bit<8; timings_bit++)
                {
                    if ((edidblockref->data_block[blockno][6+timings_byte] & (1<<(timings_bit%8))) == (1<<(timings_bit%8)))
                    {
                        generate_dmt_mode(established_timings3[(timings_byte * 8) +(7 - timings_bit)], new_monitor, 6);
                    }
                }
            }
            break;
          case 0xf8: /* 3-byte CVT timings if found (Priority 4) */
#if DODEBUG
            printf("CVT 3 Byte timing codes\n");
#endif
            for (int cvt_byte = 6;cvt_byte < 18; cvt_byte+=3)
            {
                if (!((edidblockref->data_block[blockno][cvt_byte] == 0) &&
                      (edidblockref->data_block[blockno][cvt_byte+1] == 0) &&
                      (edidblockref->data_block[blockno][cvt_byte+2] == 0))) {

                    res = generate_cvt3_timing (
                      edidblockref->data_block[blockno][cvt_byte],
                      edidblockref->data_block[blockno][cvt_byte+1],
                      edidblockref->data_block[blockno][cvt_byte+2],
                      new_monitor);
                    if (res) {
                        return res;
                    }
                }
            }

            break;
#if DODEBUG
          case 0xFF: /* Serial number - not used so only on in debug mode */
          {
              char serial_number[15];
              Get_DTD_ASCII(edidblockref, blockno, serial_number);
              printf ("Product serial number %s\n", serial_number);
              break;
          }
          case 0xFB: /* Colour point data */
              printf ("Colour point data\n");
              break;
          case 0xFA:
              printf ("Standard timing identifications\n");
              break;
          case 0xf9:
              printf ("Display colour management (DCM) data\n");
              break;
          case 0x10:
              printf("Empty\n");
              break;
#endif
        }

    }

    /* Add Established timings I and II  (priority 6) */

#if DODEBUG
    printf("Timings bitfield 0 = %02x\n",edidblockref->established_timings[0]);
    printf("Timings bitfield 1 = %02x\n",edidblockref->established_timings[1]);
    printf("Timings bitfield 2 = %02x\n",edidblockref->established_timings[2]);
#endif

    for (int timings_byte=0; timings_byte<2; timings_byte++)
    {
        for (int timings_bit=0; timings_bit<8; timings_bit++)
        {
            if ((edidblockref->established_timings[timings_byte] & (1<<(timings_bit%8))) == (1<<(timings_bit%8)))
            {
#if DODEBUG
              printf("Timings bitfield byte %d bit %d:\n", timings_byte, timings_bit);
#endif
              int dmt_mode = established_timings[(timings_byte * 8)+(7 - timings_bit)];
              if (dmt_mode > 0) {
                  generate_dmt_mode(dmt_mode, new_monitor, 6);
              }
              else {
                  // There are 3 cases who do not have defined DMT codes.
                  // These are byte 0 bits 7, 6 and 4 which we will calculate
                  int xres = 0;
                  int yres = 0;
                  int freq = 0;
                  switch (timings_bit | (timings_byte << 3))
                  {
                    case 7: // 720 X 400 @ 70Hz
                      /* Use some fixed timings for better compatibility */
                      add_builtin_mode(new_monitor, &established_timing_7, 6);
                      break;
                    case 6: // 720 X 400 @ 88Hz
                      xres = 720;
                      yres = 400;
                      freq = 88;
                      break;
                    case 4: // 640 X 480 @ 67Hz
                      xres = 640;
                      yres = 480;
                      freq = 67;
                      break;
                  }

                  if (xres > 0) {
                      ModeDescriptionRef mp;
                      mp = (ModeDescriptionRef) malloc (sizeof(ModeDescription));
                      if (mp == NULL) {
                          return error (ERR_NOSPACE, 0, 0, 0);
                      }

                      if ((timing_support == EDID_USE_GTF) ||
                          (timing_support == EDID_USE_GTF2)) {
                          generate_mode_using_gtf(xres, yres, freq, mp, new_monitor);
                      }
                      if ((timing_support == EDID_USE_CVT) ||
                          (timing_support == EDID_USE_CVTRB)) {
                          generate_mode_using_cvt_rb(xres, yres, freq, mp, new_monitor);
                      }
                  }

              }
            }
        }
    }


    /* Now check extension blocks for modes. Detailed timing modes found here have 3rd priority */
    if (edidblockref->extension_block_count > 0)
    {
        debug printf("%i Extension block(s) found\n", edidblockref->extension_block_count);

        for (int ext_block_id = 1; ext_block_id <= edidblockref->extension_block_count; ext_block_id++)
        {
            EDIDExtensionBlockRef ext_block = (EDIDExtensionBlockRef) &ediddata[128*ext_block_id];

            /* Different block types to be handled here */

            /* CEA Extension - uses Tag 0x02 */
            if (ext_block->tag == 0x02)
            {
                debug printf("Block %i: CEA Extension block found\n", ext_block_id);
                debug printf("Version %i\n", ext_block->revision);

                if (ext_block->revision != 0) /* Revision 0 doesn't exist. All othe revisions (including future ones we don't know about) should be at least partially parseable. */
                {
                    res = process_cea_extension(ext_block, new_monitor);
                    if (res) {
                        return res;
                    }
                }
            }

            /* VTB Extension block - Uses Tag 0x10, revision 0x01 */
            if ((ext_block->tag == 0x10) && (ext_block->revision == 0x01))
            {
                res = process_vtb_extension_block(ext_block, new_monitor);
                if (res) {
                    return res;
                }
            }
        }
    }


    /* Then sort the modes */
    if (new_monitor->modelist == NULL) {
        return semerr0 (ERR_NOMODES);
    }
    else {
        sort_modelist(&new_monitor->modelist);
    }



#if DODEBUG
    printf("Modes sorted\n");
#endif
    if(file) {
      /* open file for new mode file if required */
      /* file is a string terminated in 0x0D */
      char *ptr,*fbuf;
      int length=strcspn(file,"\r");
      fbuf = malloc(length+MAXMONITORNAME+2);
      /* get around the CR terminated file name */
      if(fbuf) {
        memcpy(fbuf,file,length);
        fbuf[length] = '.';
        strcpy(fbuf+length+1,new_monitor->name);
        while(ptr=strpbrk(fbuf+length+1," \"#$%&*.:@\\^|\x7f<>"),ptr) {
           *ptr='_';
        }

        f=fopen(fbuf,"w");
        free(fbuf);
      }
      if(!f) {
        return _kernel_last_oserror();
      }
    }

    if(f) {
      fprintf(f,"# Monitor description file for %s\n",new_monitor->name);
      fprintf(f,"# Created by ScrModes %s\n",Module_VersionString);
      fprintf(f,"# (EDID specified modes only, no calculated modes)\n\n");
      fprintf(f,"# Max Viewable H %d cm \n",edidblockref->horizontal_screen_size);
      fprintf(f,"# Max Viewable V %d cm\n",edidblockref->vertical_screen_size);
      if (RangeBlock != -1) {
        uint8_t flags = edidblockref->data_block[RangeBlock][4];
        int vmin=0,vmax=0,hmin=0,hmax=0, pixmax=0;
        if((flags&0x3)==0x2) {vmax=255;}
        if((flags&0x3)==0x2) {vmax=255; vmin=255;}
        if((flags&0xc)==0x8) {hmax=255;}
        if((flags&0xc)==0xc) {hmax=255; hmin=255;}
        vmin+=edidblockref->data_block[RangeBlock][5];
        vmax+=edidblockref->data_block[RangeBlock][6];
        hmin+=edidblockref->data_block[RangeBlock][7];
        hmax+=edidblockref->data_block[RangeBlock][8];
        pixmax=edidblockref->data_block[RangeBlock][9];
        fprintf(f,"# Line rate:     %2d - %2dkHz\n",hmin,hmax);
        fprintf(f,"# Frame rate:    %2d - %2dHz\n",vmin,vmax);
        fprintf(f,"# Max Dot rate: %3dMHz (rounded down)\n",pixmax*10);
      }
      fprintf(f,"# Uses %s frequency pixel clocks\n", ((edidblockref->feature_support & 1) == 1)?"Continuous":"Specific");

      char *rules="unknown";
      switch(timing_support) {
        case EDID_USE_CVT:rules="CVT";break;
        case EDID_USE_DMT:rules="DMT";break;
        case EDID_USE_CVTRB:rules="CVTRB";break;
        case EDID_USE_GTF:rules="GTF";break;
        case EDID_USE_GTF2:rules="GTF2";break;
      }
      fprintf(f,"# Use %s timing rules\n#\n",rules);

      fprintf(f,"file_format:1\nmonitor_title:%s\n",new_monitor->name);
      if(new_monitor->dpms_state!=-1) {
        fprintf(f,"DPMS_state:%d\n",new_monitor->dpms_state);
      }
      ModeDescriptionRef this = new_monitor->modelist;
      do {
        fprintf(f,"\n# Mode:  %d x %d @ %dHz",this->definition.xres,this->definition.yres,this->frame_hz);
        fprintf(f,"\n# Bounds: H  %3.2fkHz, V %3.2f, DClock %3.2fMHz",((float)(this->line_hz))/1000.0f,((float)(this->frame_mhz))/1000.0f,((float)(this->definition.pixel_khz))/1000.0f);
        fprintf(f,"\nstartmode");
        fprintf(f,"\n mode_name:%d x %d",this->definition.xres,this->definition.yres);
        fprintf(f,"\n x_res:%d",this->definition.xres);
        fprintf(f,"\n y_res:%d",this->definition.yres);
        fprintf(f,"\n pixel_rate:%d",this->definition.pixel_khz);
        fprintf(f,"\n h_timings:%d,%d,%d,%d,%d,%d",this->definition.hpar[0],this->definition.hpar[1],this->definition.hpar[2],this->definition.hpar[3],this->definition.hpar[4],this->definition.hpar[5]);
        fprintf(f,"\n v_timings:%d,%d,%d,%d,%d,%d",this->definition.vpar[0],this->definition.vpar[1],this->definition.vpar[2],this->definition.vpar[3],this->definition.vpar[4],this->definition.vpar[5]);
        fprintf(f,"\n sync_pol:%d",this->definition.syncpol);
        if (this->definition.interlaced == 1) {
          fprintf(f,"\n interlaced");
        }
        fprintf(f,"\nEndMode\n");
        this = this->next;  /* will be NULL at list end*/
      } while (this);
      /* now fo hex dump of EDID block */
      fprintf(f,"# EDID block dump\n#\n");
      for (int i=0; i<(edidblockref->extension_block_count+1)*0x80;i+=16) {
        fprintf(f,"# %02x %02x %02x %02x  %02x %02x %02x %02x",
           ediddata[i],ediddata[i+1],ediddata[i+2],ediddata[i+3],
           ediddata[i+4],ediddata[i+5],ediddata[i+6],ediddata[i+7]);
        fprintf(f,"  %02x %02x %02x %02x  %02x %02x %02x %02x\n",
           ediddata[i+8],ediddata[i+9],ediddata[i+10],ediddata[i+11],
           ediddata[i+12],ediddata[i+13],ediddata[i+14],ediddata[i+15]);
      }
      fprintf(f,"#\n#End\n");
      fclose (f);
    }
    else
    {
       /* Below taken from the loadmodefile code
        * If we haven't got a file loaded at present, then
        * read current monitortype, to restore on module shutdown
        */
       if (old_monitortype == -1) {
           old_monitortype = read_monitortype ();
       }

       res = set_monitortype (MONITOR_FILE);
       if (res != NULL) {
         _kernel_oserror *res2;
         debug printf ("setting of monitor type to type `FILE' failed\n");
         res2 = restore_monitortype (); /* restore old value */
         if (res2 != NULL)
         {
             debug printf ("couldn't reset monitor type to CMOS default!\n");
         }
       }
       else {
         _kernel_swi_regs regs;
         release_currentmonitor ();
         current_monitor = new_monitor;

         /* Set up the mode specifier */
         if(preferred_mode && new_preferred_mode)
         {
           preferred_mode->bit0 = 1;
           preferred_mode->format = 0;
           preferred_mode->xresol = new_preferred_mode->definition.xres;
           preferred_mode->yresol = new_preferred_mode->definition.yres;
           preferred_mode->depth = 5;
           preferred_mode->framerate = new_preferred_mode->frame_hz;
           preferred_mode->param[0].index = -1;
         }
         else if(preferred_mode)
         {
           preferred_mode->bit0 = 0;
         }

         /* Set the preferred sync type from video input definition bit 3. */
         /* (ref EDID spec table 3.11) */
         if ((edidblockref->video_input_definition & 0x8) == 0x8) {
             preferred_sync_type = 0;
         }
         else {
             preferred_sync_type = 1;
         }

         debug printf("Monitor type changed\n");

         /* Newly defined monitor, announce it */
         regs.r[1] = Service_ModeFileChanged;
         _kernel_swi (OS_ServiceCall, &regs, &regs);
         debug printf("Service_ModeFileChanged issued\n");
       }
    }

    return res;
}

static _kernel_oserror *loadedid (const char *file)
{
    _kernel_oserror *res;
    /* Load the EDID data into a data block. */
    /* NB at present we aren't loading extension blocks */

    int file_length, file_found;

    res = _swix(OS_File, _INR(0,1) | _OUT(0) | _OUT(4), 23, file, &file_found, &file_length);
    if (!res && (file_found == 1))
    {
        char *edidblock = (char *) malloc (file_length + 4);

        if (edidblock == NULL) {
            return error (ERR_NOSPACE, 0, 0, 0);
        }
        res = _swix(OS_File,_INR(0,3),0xff,file,edidblock,0);

        /* Check the block is valid */
        if (!res) {
            res = Check_EDID_Checksum((char *)edidblock, EDID_Check_AllBlocks);
        }
        if (!res) {
          parseedid(edidblock,NULL);
        }
        free(edidblock);
    }
    return res;
}

static _kernel_oserror *loadmodefile (const char *file)
{
  _kernel_oserror *res;

  res = open_modefile (file);
  if (res != NULL) {
      debug printf ("failed to open modefile\n");
  }
  else
  {
      /* Now need to differentiate if text file or EDID file. */
      /* We do so by looking for the EDID header 0x00ffffffffffff00 */
      int is_edid = 1;
      int c;
      for (int i = 0; i<8;i++)
      {
          c = getc(thefile);
          if (((i == 0) || (i == 7)) && (c != 0x00)) {
              is_edid = 0;
          }
          if (((i > 0) && (i < 7)) && (c != 0xff)) {
              is_edid = 0;
          }
      }

      if (is_edid == 1)
      {
          /* Close the file - we need to load the whole file to map it */
          /* onto the EDID struct */

          fclose(thefile);
          /* Now pass loadEDID the path */
          res = loadedid(file);
      }
      else
      {
          rewind(thefile); /* Reset the pointer to the beginning */
          res = loadtextMDF(file);
      }
  }
  return res;
}

static _kernel_oserror *readedidblock (int displaynum, EDIDBlockRef edidblock, int offset, int count)
{
    _kernel_oserror *res;
    int iic_code = (0xa1 << 16) | (0x80*offset << 0);
    int op_code = (displaynum << 24) | (0 << 16) | (GraphicsV_IICOp << 0);

    res = _swix(OS_CallAVector, _INR(0,2) | _IN(4) | _IN(9) | _OUT(0) | _OUT(4), iic_code, edidblock+offset, 0x80*count, op_code, GraphicsV, &iic_code, &op_code);

    /* If GraphicsV 14 was not claimed, R4 (op_code) should return
       unchanged in which case we need to alert the user that the
       hardware doesn't like EDID :-( */
    if (iic_code != 0) {
        res = error (ERR_IICOPFAIL, 0, 0, 0);
    }

    /* An 'EDID read not supported' error will trump an IIC failure. */
    if (op_code != 0) {
        res = error (ERR_CANTREADEDID, 0, 0, 0);
    }
    return res;
}

static _kernel_oserror *readedid (int displaynum, const char *file)
{
    _kernel_oserror *res;
    EDIDBlockRef edidblock = (EDIDBlockRef) malloc(128);
    if (edidblock == NULL) {
        return error (ERR_NOSPACE, 0, 0, 0);
    }
    debug printf ("ReadEDID called\n");

    res = readedidblock (displaynum, edidblock, 0, 1);

    /* Check the block is valid */
    if (!res) {
        res = Check_EDID_Checksum((char *)edidblock, EDID_Check_BaseOnly);
   }

    /* Now use a separate pointer to the block for extending it and */
    /* setting up extensions */
    /* (because if it fails we use the original pointer to free up the */
    /* memory block and exit). */
    char *ediddata = (char *)edidblock;

    /* If it is, resize to accomodate extension blocks */
    if (!res) {
        debug printf ("%i EDID extension blocks found\n", edidblock->extension_block_count);

        if (edidblock->extension_block_count > 0) {
            ediddata = realloc (edidblock, 128 * (edidblock->extension_block_count + 1));
            if (ediddata == NULL) {
                res = error (ERR_NOSPACE, 0, 0, 0);
            }
            else {
                edidblock = (EDIDBlockRef) ediddata;

                res = readedidblock (displaynum, edidblock, 1, edidblock->extension_block_count);

                /* Check the block is valid */
                if (!res) {
                    res = Check_EDID_Checksum((char *)edidblock, EDID_Check_AllBlocks);
                }
            }
        }
    }

    if (!res) {
      debug printf ("Parsing EDID block\n");
      EDIDEnabled = 1;
      /* ERR_NOMODES expects a filename, give it something vaguely sensible */
      thefilename = "(EDID)";
      res = parseedid(ediddata,file);
    }

    free(edidblock);
    return res;
}

/* List of new PixelFormats available from old GraphicsV_DisplayFeatures */
static PixelFormat oldformats[] = {
    {1,0,0},
    {3,0,1},
    {15,0,2},
    {255,ModeFlag_FullPalette,3},
    {65535,0,4},
    {-1,0,5},
};

/* Convert an old pixel depth value to a PixelFormat value */
static void pixelformat_from_depth(PixelFormatRef pf,int depth)
{
    pf->log2bpp = depth;
    pf->ncolour = (1<<(1<<depth))-1;
    pf->modeflags = (depth==3?ModeFlag_FullPalette:0);
}

/* Can this PixelFormat be represented as a pixel depth? (if so, pf->log2bpp is the value) */
static bool is_old_format(const PixelFormatRef pf)
{
    if(pf->log2bpp > 5)
        return false;
    if(pf->ncolour != (1<<(1<<pf->log2bpp))-1)
        return false;
    if(pf->modeflags != (pf->log2bpp==3?ModeFlag_FullPalette:0))
        return false;
    return true;
}

/* Return current GraphicsV driver number */
static int current_graphicsv_driver (void)
{
    int variables[2];
    variables[0] = VduExt_CurrentGraphicsVDriver;
    variables[1] = -1;
    _swix(OS_ReadVduVariables,_INR(0,1),variables,variables);
    return variables[0];
}

static void build_a_vidclist (VIDCListRef vp, ModeDescriptionRef mp, const PixelFormatRef pf)
{
    int fn;
    int ctrllistpos = 0;

    /* Fill in the fields */
    vp->format = 3;
    vp->depth = pf->log2bpp;
    for (fn = 0; fn < FR__COUNT; ++fn)
    {
        vp->hpar[fn] = mp->definition.hpar[fn];
        vp->vpar[fn] = mp->definition.vpar[fn];
    }
    vp->pixelrate = mp->definition.pixel_khz;
    vp->syncpol = mp->definition.syncpol;

    /* Only specify ModeFlags & NColour if necessary? */
    if(!is_old_format(pf))
    {
        vp->vcparam[ctrllistpos].index = NCOLOUR_INDEX;
        vp->vcparam[ctrllistpos].value = pf->ncolour;
        ctrllistpos++;
        vp->vcparam[ctrllistpos].index = MODEFLAGS_INDEX;
        vp->vcparam[ctrllistpos].value = pf->modeflags;
        ctrllistpos++;
    }

    if (current_monitor->dpms_state != -1)
    {
        vp->vcparam[ctrllistpos].index = DPMS_INDEX;
        vp->vcparam[ctrllistpos].value = current_monitor->dpms_state;
        ctrllistpos++;
    }

    if (current_monitor->lcd_support != 0)
    {
        debug printf("I'm an LCD panel & I'm going to tell the Kernel!\n");
        vp->vcparam[ctrllistpos].index = LCDMODE_INDEX;
        vp->vcparam[ctrllistpos].value = LCDMODE_VALUE;
        ctrllistpos++;
        if (current_monitor->lcd_support != 3)
        {
            vp->vcparam[ctrllistpos].index = LCDDUAL_INDEX;
            vp->vcparam[ctrllistpos].value = LCDDUAL_VALUE;
            ctrllistpos++;
        }
        vp->vcparam[ctrllistpos].index = LCDOFF0_INDEX;
        vp->vcparam[ctrllistpos].value = LCDOFF0_VALUE;
            ctrllistpos++;
        vp->vcparam[ctrllistpos].index = LCDOFF1_INDEX;
        vp->vcparam[ctrllistpos].value = LCDOFF1_VALUE;
            ctrllistpos++;
        vp->vcparam[ctrllistpos].index = DACCTRL_INDEX;
        vp->vcparam[ctrllistpos].value = DACCTRL_VALUE;
            ctrllistpos++;
    }

    if (mp->definition.external_clock != -1)
    {
        vp->vcparam[ctrllistpos].index = HCLK_INDEX;
        vp->vcparam[ctrllistpos].value = mp->definition.external_clock;
        ctrllistpos++;
    }

    if (mp->definition.interlaced)
    {
        vp->vcparam[ctrllistpos].index = INTERLACED_INDEX;
        vp->vcparam[ctrllistpos].value = 1;
        ctrllistpos++;
    }

    if (current_monitor->output_format != -1)
    {
        vp->vcparam[ctrllistpos].index = OPFORMAT_INDEX;
        vp->vcparam[ctrllistpos].value = current_monitor->output_format;
        ctrllistpos++;
    }

    vp->vcparam[ctrllistpos].index = -1;      /* List terminator */
}

/*
 * Test for whether a given mode definition is usable within the
 * specified data rate and video memory size bounds, at a given pixel
 * depth.  Limitations of the current video controller chip (if known)
 * are also factored in to the test.
 */
static int mode_valid (ModeDescriptionRef mp, const PixelFormatRef pf,
                       uint32_t maxdatarate /* kB/s */,
                       uint32_t maxdatasize /* bytes */)
{
    _kernel_swi_regs r;
    VIDCList         vetlist;
    uint32_t pixrate = mp->definition.pixel_khz;
    uint32_t mx = mp->definition.xres;
    uint32_t my = mp->definition.yres;
    uint32_t pixels = mx * my;
    uint32_t datarate, datasize;

    /* Get true bpp value */
    uint32_t bpp = 1<<pf->log2bpp;
    if(pf->log2bpp == 6) /* 24bit packed formats */
        bpp = 24;
    else if(pf->log2bpp == 7) /* YUV formats - TODO! */
        return 0;

    /* Convert from pixels to bytes: method varies according to depth */
    if ((bpp > 4) && (current_monitor->lcd_support == 1)) {
        return 0;         /** Eek! 4bpp is max for b/w panels! **/
    }

    if (bpp < 8)
    {
        uint8_t shift = 3 - pf->log2bpp;
        uint32_t round = (1 << shift) - 1;
        datarate = (pixrate + round) >> shift;
        datasize = (pixels + round) >> shift;
    }
    else
    {
        uint8_t mult = bpp>>3;
        datarate = pixrate * mult;
        datasize = pixels * mult;
    }

    /* Check global data rate/size limits */
    if (datarate > maxdatarate || datasize > maxdatasize) {
        return 0;
    }

    /* Apply video-controller-specific checks */
    int driver = current_graphicsv_driver();

    r.r[4] = GraphicsV_PixelFormats | (driver<<24);
    r.r[9] = GraphicsV;
    _kernel_swi (OS_CallAVector, &r, &r);
    if (r.r[4] == 0)
    {
        int i=r.r[1];
        PixelFormatRef formats = (PixelFormatRef) r.r[0];
        while(i)
        {
            if((formats->ncolour == pf->ncolour)
              && (formats->modeflags == pf->modeflags)
              && (formats->log2bpp == pf->log2bpp))
                break;
            formats++;
            i--;
        }
        if(i == 0)
            return 0;    /* Had a definitive answer from GraphicsV that this bpp is forbidden */
    }
    else
    {
        /* Try the old DisplayFeatures call */
        if(!is_old_format(pf))
            return 0;    /* Not a format supported by DisplayFeatures */
        r.r[4] = GraphicsV_DisplayFeatures | (driver<<24);
        r.r[9] = GraphicsV;
        _kernel_swi (OS_CallAVector, &r, &r);
        if ((r.r[4] == 0) && ((r.r[1] & (1<<pf->log2bpp)) == 0)) {
            return 0;    /* Had a definitive answer from GraphicsV that this bpp is forbidden */
        }
    }

    /* Propose the resulting mode to the graphics driver */
    build_a_vidclist (&vetlist, mp, pf);
    r.r[0] = (int)&vetlist;
    r.r[1] = NULL;
    r.r[4] = GraphicsV_VetMode | (driver<<24);
    r.r[9] = GraphicsV;
    _kernel_swi (OS_CallAVector, &r, &r);
    if ((r.r[4] == 0) && (r.r[0] != 0)) {
        return 0;    /* Had a definitive answer from GraphicsV that it no-likey */
    }

    /* No obvious conflicts, accept the mode */
    return 1;
}

static ModeDescriptionRef find_by_xy (ModeDescriptionRef mp,
                                      uint32_t xres, uint32_t yres, int *count)
{
    while (mp && mp->definition.xres < xres)
        mp = mp->next;
    while (mp && mp->definition.xres == xres && mp->definition.yres < yres)
        mp = mp->next;
    if (mp && mp->definition.xres == xres && mp->definition.yres == yres)
    {
        int entries;
        ModeDescriptionRef head = mp;
        entries = 0;
        do
        {
            ++entries;
            mp = mp->next;
        } while (mp && mp->definition.xres == xres &&
                 mp->definition.yres == yres);
        *count = entries;
        return head;
    }
    else
        return NULL;
}

static int restrict_bandwidth (int os_limit)
{
    /*
     * On a HAL based kernel the kernel doesn't know what the bandwidth limitations
     * for a given mode are (an LCD graphics controller might for example be able
     * to use local SRAM buffering for smallish modes, but swap to shared slow DRAM
     * for bigger modes, both of which have differing bandwidths). The kernel
     * therefore just guesses a value, which we choose to ignore here and leave any
     * vetting up to GraphicsV.
     */
    UNUSED(os_limit);

    return INT32_MAX;
}

static void service_modeextension (_kernel_swi_regs *regs)
{
    /*
     * Static allocation of a single VIDCList, for return from
     * Service_ModeExtension in the case that we have a mode
     * satisfying the requirements.  The data in this block is
     * overwritten by the next Service_ModeExtension call which we
     * also satisfy.  NB. Since we currently have no mechanism whereby
     * additional fields can be specified (e.g. in the ModeInfo file)
     * to be returned in a video control parameters list at the end of
     * the main block, there is no need for this block to be variable
     * length.  If that were ever added, the space would need to be
     * claimed either by assuming some maximum possible VCP list size
     * and keeping it static, or allocating the right size
     * dynamically; the latter case would imply keeping a file-scope
     * static pointer so that the space can be released as required
     * when module_shutdown is called.
     *
     * TMD 02-Nov-93 - A video control parameters list is now appended
     * if the file includes the DPMS_state keyword. However since this
     * is only 1 pair of words, I have allocated it statically.
     * If no list is necessary, the 1st word holds -1.
     * If a list is necessary, the 1st word holds DPMS_INDEX, the 2nd
     * holds the dpms value, and the 3rd word holds -1.
     *
     * WT 19-Jan-95 - The parameters list is extended to cater for LCD
     * panels, both single and dual panel, as defined in the LCD_support
     * field of the mode definition file. So, now 6 words are statically
     * allocated.
     */
    static VIDCList thevidclist;

    ModeSelectorRef    sel;
    ModeDescriptionRef mp;
    uint32_t dataratelimit, datasizelimit;
    int nmodes;
    PixelFormat pf;

    /*
     * Check for being passed a mode selector as opposed to a mode
     * number - we only handle the former.
     */
    if (!IS_MODE_SEL_PTR (regs->r[2])) {
        return;
    }

    /*
     * Check for suitable monitor type being requested - we handle
     * don't-care case as well as explicit file-specified monitor
     * type, but don't touch other specific monitor class codes.
     */
    if (regs->r[3] != -1 && regs->r[3] != MONITOR_FILE) {
        return;                         /* pass service on */
    }

    /*
     * Address the mode selector (R2 on entry has been found to be a
     * pointer), and check for known format (bit 0 set, bits 7..1
     * clear).
     */
    sel = MODESEL(regs->r[2]);
    if (sel->bit0 != 1 || sel->format != 0) {
        return;                         /* pass service on */
    }

    /*
     * Examine the mode selector to deduce the pixel format
     */
    pixelformat_from_depth(&pf,sel->depth);
    ModeParam *param = sel->param;
    while(param->index != -1)
    {
        if(param->index == VduExt_ModeFlags)
            pf.modeflags = param->value;
        else if(param->index == VduExt_NColour)
            pf.ncolour = param->value;
        param++;
    }

    /* Mask out unwanted mode flags */
    pf.modeflags &= ~(ModeFlag_NonGraphic | ModeFlag_Teletext | ModeFlag_GapMode | ModeFlag_BBCGapMode | ModeFlag_HiResMono | ModeFlag_DoubleVertical | ModeFlag_HardScrollDisabled | ModeFlag_InterlacedMode);

    /* Massage flags for RGB modes a bit */
    if((pf.modeflags & ModeFlag_DataFormatFamily_Mask) == ModeFlag_DataFormatFamily_RGB)
    {
        /* Detect 64 colour modes and convert to 256 colour */
        if((pf.ncolour == 63) && (pf.log2bpp == 3))
        {
            pf.ncolour = 255;
            pf.modeflags |= ModeFlag_FullPalette;
        }
        /* Clear the greyscale flag. TODO - keep it so greyscale-only devices can make use of it? */
        pf.modeflags &= ~ModeFlag_GreyscalePalette;
    }

    /* Bail if we see something unexpected */
    if(pf.modeflags & ~(ModeFlag_FullPalette | ModeFlag_64k | ModeFlag_ChromaSubsampleMode | ModeFlag_DataFormat_Mask))
        return;

    /* Pick up data size limit from args to service call */
    datasizelimit = regs->r[5]; /* data size is measured in bytes */

    /*
     * Current Screen Mode selection API FuncSpec (0197,290/FS, Issue
     * D) says data rate figure in R4 is in bytes/sec.  Since Medusa
     * h/ware can do up to 170,000,000 bytes/sec, and that number is a
     * factor of only 12 times smaller than the max number in a 32-bit
     * signed integer, it would seem more future-proof and consistent
     * (cf. pixel rate specs which use kHz not Hz) to use 1000's of
     * bytes/sec, but for now convert to preferred units as used internally.
     */
    dataratelimit = restrict_bandwidth (regs->r[4]) / 1000;

    /*
     * Scan all available modes, looking for a match.  First find the
     * subset of all known modes which have the right resolution.
     * They are contiguous on the master list.  We track where to stop
     * by knowing how many of them there are (find_by_xy counts up)
     * rather than by rechecking the pointer and x/y fields every
     * time.
     */
    mp = find_by_xy (current_monitor->modelist, sel->xresol, sel->yresol, &nmodes);
    if (mp == NULL) {
        return;                         /* no match */
    }
    do
    {
        /* Test whether this mode can satisfy the requirements */
        if ((sel->framerate == -1 || sel->framerate == mp->frame_hz) &&
             mode_valid (mp, &pf, dataratelimit, datasizelimit))
        {
            build_a_vidclist (&thevidclist, mp, &pf); /* use the local static structure */

            /* And claim the service */
            regs->r[1] = 0;                 /* Service_Serviced */
            regs->r[3] = (int)&thevidclist; /* return pointer to VIDC list to use */
            regs->r[4] = NULL;              /* marks no workspace list (mode selector given) */
            return;
        }
        mp = mp->next;
    } while (--nmodes);
}

static void service_enumeratescreenmodes (_kernel_swi_regs *regs)
{
    ModeDescriptionRef mp;
    uint32_t dataratelimit, datasizelimit;
    PixelFormatRef pf,pflist;
    int numformats,pflistlen;
    _kernel_swi_regs r;

    /*
     * See comments re. data-rate spec in service_modeextension.
     */
    dataratelimit = restrict_bandwidth (regs->r[4]) / 1000;
    datasizelimit = regs->r[5];

    /* Get list of pixel formats supported by driver */
    int driver = current_graphicsv_driver();

    r.r[4] = GraphicsV_PixelFormats | (driver<<24);
    r.r[9] = GraphicsV;
    _kernel_swi (OS_CallAVector, &r, &r);
    if (r.r[4] == 0)
    {
        pflist = (PixelFormatRef) r.r[0];
        pflistlen = r.r[1];
    }
    else
    {
        /* Use the old list */
        pflist = oldformats;
        pflistlen = sizeof(oldformats)/sizeof(oldformats[0]);
    }


    /* Scan all available modes at all available pixel formats */
    mp = current_monitor->modelist;
    pf = pflist;
    numformats = pflistlen;

    for (;;)
    {
        if (!mode_valid (mp, pf, dataratelimit, datasizelimit))
        {
            /*
             * TMD 03-Nov-93: Fix bug MED-00833
             * Code used to set depth to 5 here, assuming that if the mode
             * was invalid at a low depth, it would be invalid at all higher
             * depths. This is a wrong assumption when a mode can fail because
             * the length of the line is not a suitable multiple.
             */
        }
        else
        {
            /* OK, it fits; what to do with it?  Follow algorithm from F.S. */
            if (regs->r[2] > 0)
            {
                /* skipping (in a partial enumeration) - nowt to do */
            }
            else
            {
                int nlen = strlen (mp->definition.name);
                int entrysize = 24 + ((nlen + 1 + 3) & ~3);
                bool old_format = is_old_format(pf);
                if (!old_format) {
                    entrysize += 8;
                }
                if (regs->r[6] != 0)
                {
                    /* Enumeration case - filling in block */
                    if (regs->r[7] >= entrysize)
                    {
                        if(old_format)
                        {
                            ModeInfoBlockRef ip = (ModeInfoBlockRef)regs->r[6];
                            int i;

                            /* Copy the mode information into the supplied data buffer */
                            ip->blocksize = entrysize;
                            ip->format = 0;  ip->flags = 0;  ip->bit0 = 1;
                            ip->xresol = mp->definition.xres;
                            ip->yresol = mp->definition.yres;
                            ip->depth = pf->log2bpp; /* log2 (bits/pixel) */
                            ip->framerate = mp->frame_hz; /* integer Hz value used here */

                            /* Copy name + 1 terminating null into block */
                            strcpy (ip->name, mp->definition.name);
                            /* Pad name field out with 0's to N*4 */
                            for (i = nlen+1; (i & 3) != 0; ++i)
                                ip->name[i] = 0;
                        }
                        else
                        {
                            ModeInfoBlock1Ref ip = (ModeInfoBlock1Ref)regs->r[6];
                            int i;

                            /* Copy the mode information into the supplied data buffer */
                            ip->blocksize = entrysize;
                            ip->format = 1;  ip->flags = 0;  ip->bit0 = 1;
                            ip->xresol = mp->definition.xres;
                            ip->yresol = mp->definition.yres;
                            ip->pixelformat = *pf;
                            ip->framerate = mp->frame_hz; /* integer Hz value used here */

                            /* Copy name + 1 terminating null into block */
                            strcpy (ip->name, mp->definition.name);
                            /* Pad name field out with 0's to N*4 */
                            for (i = nlen+1; (i & 3) != 0; ++i)
                                ip->name[i] = 0;
                        }
                        /* Step buffer pointer past this new entry */
                        regs->r[6] += entrysize;
                    }
                    else
                    {
                        regs->r[1] = 0; /* Service_Serviced */
                        return;
                    }
                }
                /* Update remaining size of user data area */
                regs->r[7] -= entrysize;
            }
            /* count down matching modes in calling r2 */
            --regs->r[2];
        }

        /* Move on to next mode, if there are any left */
        if (numformats--)
        {
            pf++;                       /* next deeper mode of current def'n */
        }
        else
        {
            mp = mp->next;              /* next mode in list */
            if (mp == NULL) {
                return;                 /* no more modes from this module */
            }
            pf = pflist;                /* start with min. depth */
            numformats = pflistlen;
        }
    }
}

static int mode_available(uint32_t xres, uint32_t yres, const PixelFormatRef pf, int framerate)
{
    ModeDescriptionRef mp;
    int nmodes;

    mp = find_by_xy (current_monitor->modelist, xres, yres, &nmodes);
    if (mp == NULL) {
        return 0;
    }
    do
    {
        if ((framerate == -1 || framerate == mp->frame_hz) &&
            mode_valid (mp, pf, INT32_MAX, INT32_MAX))
        {
            return 1;
        }
        mp = mp->next;
    } while (--nmodes);

    return 0;
}

static void service_modetranslation (_kernel_swi_regs *regs)
{
    unsigned int flags;
    int depth;
    PixelFormat pf;

    static const char pal[4]  = {  0,  8, 12, 15 };
    static const char ntsc[4] = { 44, 45, 46, 46 };
    static const char vga[4]  = { 25, 26, 27, 28 };

    /* We do monitor type 7 only */
    if (regs->r[3] != 7 || !current_monitor) {
        return;
    }

    /*
     * Someone has asked for an old-style mode number, but we
     * must have refused it.
     *
     * If we don't handle this, the Kernel will select one of
     * modes 25, 26, 27 or 28. This would be fine, except
     * we may not have mode 25, due to interlacing problems, or
     * we may have only non-interlaced modes.
     *
     * Note we're not told the bandwidth and memory limits.
     * Could deal with this by issuing OS_CheckModeValid for
     * each mode, but that adds reentrancy problems :) The
     * selection of modes above are within the limits of even
     * an A310, so we assume they won't be too big/fast.
     */

    /*
     * What depth are they looking for? If the mode is
     * unknown, use 1bpp (as the Kernel does).
     */
    if (_swix(OS_ReadModeVariable, _INR(0,1)|_OUT(2)|_OUT(_FLAGS),
              regs->r[2], 9, &depth, &flags) || (flags & _C)) {
        depth = 0;
              }

    /*
     * Clamp depth to 8bpp to restrict ourselves to old-style
     * modes.
     */
    if (depth > 3) {
        depth = 3;
    }

retry_with_4bpp:
     pixelformat_from_depth(&pf,depth);

    /*
     * Check if 640x480xdepth @ 60Hz is available. If so, allow
     * kernel to do normal.
     */
     if (mode_available(640, 480, &pf, 60))
     {
         regs->r[1] = 0;                /* Service_Serviced */
         regs->r[2] = vga[depth];       /* substitute mode */
         return;
     }

     /*
      * We don't have a standard VGA mode. Let's try a PAL TV
      * mode.
      */
     if (mode_available(640, 256, &pf, 50))
     {
         regs->r[1] = 0;                /* Service_Serviced */
         regs->r[2] = pal[depth];       /* substitute mode */
         return;
     }

     /*
      * Alright then. How about a NTSC TV mode?
      */
     if (mode_available(640, 200, &pf, 60))
     {
         regs->r[1] = 0;                /* Service_Serviced */
         regs->r[2] = ntsc[depth];      /* substitute mode */
         return;
     }

     /*
      * Check if 640x480xdepth @ any rate is available.
      */
     if (mode_available(640, 480, &pf, -1))
     {
         regs->r[1] = 0;                /* Service_Serviced */
         regs->r[2] = vga[depth];       /* substitute mode */
         return;
     }

     /*
      * Still getting nowhere? Maybe we can't do 1bpp or 8bpp for
      * various reasons. Try again with 4bpp.
      */
     if (depth != 2)
     {
         depth = 2;
         goto retry_with_4bpp;
     }

     /* I give up. Let someone else worry about it. */
     return;
}

static void service_displaychanged (_kernel_swi_regs *regs)
{
    _kernel_oserror *res;
    switch(regs->r[0])
    {
        case DisplayChanged_Changing:
            /* The current driver is changing. We must recache any
               driver-specific things which we store.
               At the moment all the driver-specific stuff happens during the
               enumerate/translate calls, so there's nothing to do. */
            if (EDIDEnabled)
            {
                res = readedid(regs->r[2],NULL);
            }

            break;
        case DisplayChanged_Changed:
            /* Display change is complete */
            /* Issue mode file changed service call so that the display manager
               is up to date.
               (might be possible to skip this if EDID is in use and EDID has
               already issued it) */
            _swix(OS_ServiceCall,_IN(1),Service_ModeFileChanged);
            break;
    }
}


static void service_monitorleadtranslation (_kernel_swi_regs *regs)
{
  if ((preferred_mode != NULL) && (preferred_mode->bit0 == 1))
  {
    regs->r[1] = 0;
    regs->r[3] = (int) preferred_mode;
    regs->r[4] = 7;
    regs->r[5] = preferred_sync_type;
  }
}

static int we_are_preferred (void *pw)
{
    _kernel_swi_regs sregs;
    sregs.r[0] = 18;
    sregs.r[1] = (int)"ScreenModes";
    (void)_kernel_swi (OS_Module, &sregs, &sregs);
    return (sregs.r[4] == *(int *)pw);
}

static const int samplerates[] =
{
     32000*1024,
     44100*1024,
     48000*1024,
     88200*1024,
     96000*1024,
    176400*1024,
    192000*1024,
};

static _kernel_oserror *swi_enumerateaudioformats(_kernel_swi_regs *regs)
{
    if (!current_monitor)
    {
        return error(ERR_NOMODEFILE, 0, 0, 0);
    }

    /* In:  r0 = flags:
                 bit 0: 0 -> read raw data
                        1 -> read friendly data
            r1 = format code to start from (-1 = first)
            r2 = index within format code (-1 = first)
       Out: r1 = format code of this entry (-1 if no more formats)
            r2 = index within format code (-1 if no more formats)
            r3 = max channels
            raw data:
              r4 = audio short descriptor byte 2
              r5 = audio short descriptor byte 3
            friendly data:
              r4 = sample rate (Hz*1024)
              r5 = LPCM: bit depth
                   codes 2-8: max bit rate in Hz
                   other codes: not supported by this API

       n.b. index values (r2) differ between raw & friendly modes
    */
    if (regs->r[0] & ~1)
    {
        return error(ERR_BADENUMAUDIO, 0, 0, 0);
    }
    /* Find the right index to start from */
    AudioFormat *current = current_monitor->audio_formats;
    int count = current_monitor->audio_format_count;
    int format = regs->r[1];
    int start_index = regs->r[2];
    while (count && (current->format_code < format))
    {
        current++;
        count--;
    }
    if (regs->r[0] & 1)
    {
        /* Friendly mode */
        /* Skip formats we don't understand */
        int my_index = 0;
find_next_entry:;
        int sample_rate = -1;
        int bits = -1;
        while (count && ((current->format_code < 1) || (current->format_code > 8)))
        {
            current++;
            count--;
        }
        if (!count)
        {
            regs->r[1] = -1;
            regs->r[2] = -1;
            return NULL;
        }
        bool is_LPCM = (current->format_code == 1);
        if (is_LPCM)
        {
            if ((current->format_specific & 0xf8) || !(current->format_specific & 0x7))
            {
                /* Weird bit depth mask for LPCM, skip entry */
                current++;
                count--;
                goto find_next_entry;
            }
        }
find_next_sub_entry:
        /* Find first sample_rate & bits value */
        while (!(current->sample_rates & (1<<sample_rate)))
        {
            sample_rate++;
        }
        if (is_LPCM)
        {
            while (!(current->format_specific & (1<<bits)))
            {
                bits++;
            }
        }
        /* Skip entries as necessary */
        if ((current->format_code == format) && (my_index <= start_index))
        {
            my_index++;
            /* Step to next sample rate */
            sample_rate++;
            if ((1<<sample_rate) > current->sample_rates)
            {
                /* Step to next bit depth value */
                sample_rate = 0;
                bits++;
                if (!is_LPCM || ((1<<bits) > current->format_specific))
                {
                    /* Step to next format list entry */
                    current++;
                    count--;
                    goto find_next_entry;
                }
            }
            goto find_next_sub_entry;
        }
        if (current->format_code > format)
        {
            my_index = 0;
        }
        regs->r[1] = current->format_code;
        regs->r[2] = my_index;
        regs->r[3] = current->max_channels;
        regs->r[4] = samplerates[sample_rate];
        regs->r[5] = is_LPCM ? (16 + 4*bits) : (current->format_specific*8000);

        return NULL;
    }
    else
    {
        /* Raw mode */
        int my_index = 0;
        while (count && (current->format_code == format) && (my_index <= start_index))
        {
            current++;
            count--;
            my_index++;
        }
        if (!count)
        {
            regs->r[1] = -1;
            regs->r[2] = -1;
            return NULL;
        }
        if (current->format_code > format)
        {
            my_index = 0;
        }
        regs->r[1] = current->format_code;
        regs->r[2] = my_index;
        regs->r[3] = current->max_channels;
        regs->r[4] = current->sample_rates;
        regs->r[5] = current->format_specific;

        return NULL;
    }
}


/* EXPORTED */
_kernel_oserror *ScreenModes_initialise(const char *cmd_tail, int podule_base, void *pw)
{
    preferred_mode = malloc(sizeof(ModeSelector));
    if (preferred_mode)
    {
        memset(preferred_mode,0,sizeof(ModeSelector));
    }
    UNUSED(cmd_tail);
    UNUSED(podule_base);
    UNUSED(pw);
    EDIDEnabled = 0;          /* not enabled on module boot */

    return NULL;
}

_kernel_oserror *ScreenModes_final (int fatal, int podule, void *pw)
{
    /*
     * Free the space claimed for the current monitor
     * description (if any) and revert to the configured monitor type,
     * when the module is shut down.
     */
    (void) restore_monitortype (); /* restore old value */
    release_currentmonitor ();
    if (preferred_mode)
    {
        free(preferred_mode);
    }

    UNUSED(pw);
    UNUSED(podule);
    UNUSED(fatal);

    return NULL;
}


/* EXPORTED */
void ScreenModes_servicecall (int servicecallno, _kernel_swi_regs *regs, void *pw)
{
    if ((current_monitor == NULL) && (servicecallno != Service_DisplayChanged)) {
        return;                         /* nothing loaded */
    }

    /* Ignore service calls if we are not the current preferred instantiation */
    if (!we_are_preferred (pw)) {
      return;
    }

    if (servicecallno == Service_ModeExtension) {
        service_modeextension (regs);
    }
    else if (servicecallno == Service_EnumerateScreenModes) {
        service_enumeratescreenmodes (regs);
    }
    else if (servicecallno == Service_ModeTranslation) {
        service_modetranslation (regs);
    }
    else if (servicecallno == Service_DisplayChanged) {
        service_displaychanged (regs);
    }
    else if (servicecallno == Service_MonitorLeadTranslation) {
        service_monitorleadtranslation (regs);
    }
}


/* EXPORTED */
_kernel_oserror *ScreenModes_cmdhandler (const char *arg_string, int argc, int cmd_no, void *pw)
{
    _kernel_oserror *result;

    switch (cmd_no)
    {
        case CMD_LoadModeFile:
                result = loadmodefile (arg_string);
                break;
        case CMD_ReadEDID:
                result = readedid (current_graphicsv_driver(),NULL);
                break;
        case CMD_CreateModeFile:
                result = readedid (current_graphicsv_driver(),arg_string);
                break;
        default:
                return NULL;
    }

    UNUSED(pw);
    UNUSED(argc);

    return result;
}


/* EXPORTED */
_kernel_oserror *ScreenModes_swihandler (int swi_no, _kernel_swi_regs *r, void *pw)
{
    _kernel_oserror *result;

    switch (swi_no)
    {
        case ScreenModes_ReadInfo - ScreenModes_00:
            switch (r->r[0])    /* r0 = subreason code */
            {
                case ScreenModes_ReadInfo_MonitorName: /* Return pointer to monitor name */
                    if (current_monitor)
                    {
                        r->r[0] = (int) &current_monitor->name;
                        result = NULL;
                    }
                    else
                    {
                        /* No monitor description file loaded */
                        result = error (ERR_NOMODEFILE, 0, 0, 0);
                    }
                    break;

                case ScreenModes_ReadInfo_SpeakerMask: /* Read monitor speaker mask */
                    if (current_monitor)
                    {
                        r->r[0] = current_monitor->speaker_mask; /* Mask */
                        r->r[1] = current_monitor->speaker_mask_provided ? 0x7f : 0; /* Validity of each bit */
                        result = NULL;
                    }
                    else
                    {
                        /* No monitor description file loaded */
                        result = error (ERR_NOMODEFILE, 0, 0, 0);
                    }
                    break;

                default:        /* Unknown ScreenModes_ReadInfo call */
                    result = error (ERR_BADREADINFO, 0, 0, 0);
            }
            break;

        case ScreenModes_EnumerateAudioFormats - ScreenModes_00:
            return swi_enumerateaudioformats(r);

        default:                /* Unknown ScreenModes SWI */
            return error_BAD_SWI;
    }
    UNUSED(pw);

    return result;
}


/* EOF ScrModes.c */

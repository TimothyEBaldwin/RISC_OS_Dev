; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; > Sources.SprExtend

        GET     Hdr:ListOpts
        GET     Hdr:Macros
        GET     Hdr:System
        GET     Hdr:CPU.Arch
        GET     Hdr:ModHand
        GET     Hdr:Services
        GET     Hdr:VduExt
        GET     Hdr:HighFSI
        GET     Hdr:OsWords
        GET     Hdr:FSNumbers
        GET     Hdr:NewErrors
        GET     Hdr:NDRDebug
        GET     Hdr:Sprite
        GET     Hdr:ColourTran
        GET     Hdr:PublicWS
        GET     Hdr:Draw         ; needed for transform sprite
        GET     Hdr:ExtraLong    ; needed for transform sprite
        GET     Hdr:MsgTrans
        GET     Hdr:Proc
        GET     Hdr:HostFS
        GET     Hdr:Debug
        GET     Hdr:HostDebug
        GET     VersionASM
        GET     Hdr:PDriver

        IMPORT  find_image_dims
        IMPORT  putscaled_compiler
        IMPORT  jpeg_find_line
        IMPORT  assembler_panic
        IMPORT  panic_exit
        EXPORT  create_dynamic_area
        EXPORT  exit
        EXPORT  exit_c
        
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Switches
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        GBLL    hostvdu
        GBLL    file                    ; where to output the debugging to
hostvdu SETL    {FALSE}
file    SETL    {TRUE}                  

      [ :LNOT: :DEF: localmessages
        GBLL    localmessages
localmessages SETL {FALSE}
      ]

        GBLL    AvoidScreenReads        ; when true, look out for BIC masks of FFFFFFFF and skip read
AvoidScreenReads SETL    {TRUE}

        GBLL    multibuffer
multibuffer     SETL {FALSE}            ; keep multiple copies of generated code
nbuffers        * 8                     ; number of code buffers to use

        GBLL    vidc20
vidc20  SETL    {TRUE}                  ; VIDC20 support, else graphics enhancer

        GBLL    ignore_ttr
ignore_ttr SETL {TRUE}                  ; if plotting <16 to >8bpp and it has a
                                        ; palette, use that instead of the ttr
        GBLL    med01867
med01867 SETL   {TRUE}                  ; if true changes ignore_ttr behaviour to
                                        ; only apply at 8bpp full palette
        GBLL    flagbit
flagbit SETL    {TRUE}                  ; if true forces the palette to be used over the translation
      [ flagbit                         ; table, overriding the effect of of med01867 if b4 of R5 on entry was set
        GBLA    flg2_ignorettr
flg2_ignorettr  SETA 1                  ; R5 is shifted right 4 before storing
        GBLA    flg2_ditheron
flg2_ditheron   SETA 4
      ]

        GBLL    widetrans               ; support for wide translation tables via R5 bit 5
widetrans SETL  {TRUE}
      [ widetrans
        GBLA    flg2_widetrans
flg2_widetrans  SETA 2
      ]

        GBLL    jpeg                    ; jpeg decompression
jpeg    SETL    {TRUE}

        GBLL    dynamicarea             ; for storing jpeg workspace
dynamicarea SETL {TRUE}

        GBLL    StrongARM               ; be safe about dynamic code
StrongARM SETL  {TRUE}

        GBLL    usemull                 ; faster signed long multiply
usemull SETL    :LNOT: NoARMM

        GBLL    debugmc
        GBLL    debugpt
        GBLL    debugmg
        GBLL    debugid
        GBLL    debugin
        GBLL    debugsc
        GBLL    debugsp
        GBLL    debugso
        GBLL    debugch
        GBLL    debugtr
        GBLL    debuger
        GBLL    debugmb
        GBLL    debugms
        GBLL    debugag
        GBLL    debuggs
        GBLL    debugcc
debug   SETL    {FALSE}
debugmc SETL    debug :LAND: {FALSE}    ; macro compilation
debugpt SETL    debug :LAND: {FALSE}    ; pointer
debugmg SETL    debug :LAND: {FALSE}    ; 'merge sprites' code
debugid SETL    debug :LAND: {FALSE}    ; insertdelete rows or columns
debugin SETL    debug :LAND: {FALSE}    ; input parameters
debugsc SETL    debug :LAND: {FALSE}    ; screen parameters
debugsp SETL    debug :LAND: {FALSE}    ; sprite parameters
debugso SETL    debug :LAND: {TRUE}     ; sprite operations (non kernel OS_SpriteOp)
debugch SETL    debug :LAND: {FALSE}    ; character painting
debugtr SETL    debug :LAND: {FALSE}    ; transformed plotting
debuger SETL    debug :LAND: {FALSE}    ; error trapping
debugmb SETL    debug :LAND: {FALSE}    ; multibuffer code for code generator
debugms SETL    debug :LAND: {FALSE}    ; minimal multibuffer info messages
debugag SETL    debug :LAND: {FALSE}    ; amg transient debugging - could be anywhere :-)
debuggs SETL    debug :LAND: {FALSE}    ; JPEG SWI debugging.
debugcc SETL    debug :LAND: {FALSE}    ; PutSpriteScaled compiler in C

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Module prefix
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        AREA    |!!!ModuleHeader|, CODE, READONLY, PIC

Module_BaseAddr
        ASSERT  (.=Module_BaseAddr)
        DCD     0                                           ; No start
        DCD     Init    - Module_BaseAddr
        DCD     Die     - Module_BaseAddr
        DCD     Service - Module_BaseAddr
        DCD     Title   - Module_BaseAddr
        DCD     Helpstr - Module_BaseAddr
        DCD     0                                           ; Helptable
        DCD     SpriteExtendJPEGSWI_Base                    ; MySWIBase
        DCD     SpriteExtend_SWIDecode - Module_BaseAddr    ; MySWIDecode
        DCD     SpriteExtend_SWINames - Module_BaseAddr     ; MySWINames
        DCD     0
        DCD     0
        DCD     ModFlags - Module_BaseAddr

Title   =       "SpriteExtend",0

Helpstr =       "SpriteExtension",9,"$Module_HelpVersion"
      [ debug
        =       " Development version"
      ]
        =       0
        ALIGN

ModFlags
      [ :LNOT: No32bitCode
        DCD     ModuleFlag_32bit
      |
        DCD     0
      ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Macros
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ; OSS Macro for Sprite internationalised error blocks. This is because all
        ; the names start with "Sprite_". This adds no useful information to the
        ; string, and just makes the module and the Messages file bigger
        MACRO
$label  MakeSpriteErrorBlock $name, $noalign, $tag
        ALIGN
$label
ErrorBlock_$name
        DCD     ErrorNumber_Sprite_$name
      [ "$tag" = ""
        DCB     "$name"
      |
        DCB     "$tag"
      ]
        DCB     0
      [ "$noalign" = ""
        ALIGN
      ]
        MEND

        MACRO
$label  ALIGNHASH  $o,$m
      [ ((@-$o):AND:($m-1))<>0
$label  #          $m-((@-$o):AND:($m-1))
      |
$label  #          0
      ]
        MEND

        MACRO
        Claim   $vector,$entry
        MOV     R0,#$vector
        ADRL    R1,$entry
        MOV     R2,R12
        SWI     XOS_Claim
        MEND

        MACRO
        Release $vector,$entry
        MOV     R0,#$vector
        ADRL    R1,$entry
        MOV     R2,R12
        SWI     XOS_Release
        MEND

        MACRO
$l      SetImm  $reg,$value,$cc
$l      EOR$cc  $reg,$reg,#xxx
        EOR$cc  $reg,$reg,$value
        MEND

        MACRO
$l      SetLsr  $reg,$value,$cc
$l      EOR$cc  $reg,$reg,#xxx:SHL:7
        EOR$cc  $reg,$reg,$value,LSL #7
        MEND

        MACRO
$l      SetLsl  $reg,$value,$cc
$l      EOR$cc  $reg,$reg,#xxx:SHL:7
        EOR$cc  $reg,$reg,$value,LSL #7
        MEND

        MACRO
$l      CheckAlignedAndWithin $sprite,$offset,$end,$temp
$l      LDR     $temp, [$sprite, #$offset]
        TST     $temp, #3               ; not word aligned
        BNE     %F99
        ADDS    $temp, $sprite, $temp   ; check for unsigned overflow (C=1)
        CMPCC   $temp, $end
        BHI     %F99                    ; out of range
        MEND

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Data areas & register allocation
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

log2bpc         RN      R11             ; bpc
ycount          RN      R9              ; xcount
ysize           RN      R8              ; xsize
yadd            RN      R5
ydiv            RN      R4
inoffset        RN      R1              ; inshift
outoffset       RN      R0

inshift         RN      R1              ; inoffset

im2             RN      R12             ; wsptr         ; ecfeor
im1             RN      R11             ; log2bpc       ; ecfora
masko           RN      R10             ; ttr           ; ecfptr
xcount          RN      R9              ; ycount
xsize           RN      R8              ; ysize
xadd            RN      R7
xdiv            RN      R6
outmask         RN      R5              ; yadd
outword         RN      R4              ; ydiv
outptr          RN      R3
inptr           RN      R2
in2             RN      R1              ; inoffset      ; inshift
in1             RN      R0              ; outoffset

inbpp           RN      R12             ; im2
ttr             RN      R10             ; masko

                  ^     0,R13           ; for stackframe
stack_inshift     #     4               ; this data is copied onto the stack
stack_outword     #     4               ; so that R12 can be re-used
stack_outmask     #     4
stack_xsize       #     4
stack_xcount      #     4
stack_ecfptr      #     4
stack_ecflimit    #     4
stack_vcount      #     4
stack_xdiv        #     4
stack_xadd        #     4
stack_tempoutptr  #     4
stack_wsptr       #     4               ; for recovering R12 later!
        ASSERT  (:INDEX:@) = 12*4       ; must be exactly 12 words on stack
stack_BPP         #     4               ; copy
stack_outoffset   #     4               ; copy
stack_inbpp       #     4               ; copy
stack_colourttr   #     4               ; copy
stack_masko       #     4               ; copy
stack_calladdr    #     4               ; copy
stack_calladdr2   #     4               ; copy
stack_returnaddr  #     4
stack_maskword    #     4               ; = (2^outlog2bpp)-1 ROR outlog2bpp
stack_maskinptr   #     4               ; destroyable copy for inside loop
stack_maskinshift #     4               ; destroyable copy for inside loop
stack_temp1       #     4               ; for temp saving of registers inside loop
stack_temp2       #     4               ; for temp saving of registers inside loop
stack_end         #     0


; Everything from here down of interest to compiled C
; code. IF THERE ARE ANY CHANGES BELOW THIS POINT then there must be
; matching changes in the C workspace definition.
                ^       0,R12
data            #       0

        ASSERT  (:INDEX:@)=0
save_outoffset  #       4       ; reloaded from R12
save_inoffset   #       4
save_inptr      #       4
save_outptr     #       4
save_ydiv       #       4
save_yadd       #       4
save_ysize      #       4
save_ycount     #       4

save_block      #       0
save_inshift    #       4       ; <---!   this data is copied onto the stack
save_outword    #       4       ;     !   so that R12 can be re-used
save_outmask    #       4       ;     !
save_xsize      #       4       ;     !
save_xcount     #       4       ;     !
save_ecfptr     #       4       ;   --!   up to here is reloaded using LDMIA
save_ecflimit   #       4       ;     !
save_vcount     #       4       ;     !
save_xdiv       #       4       ;     !
save_xadd       #       4       ; <---!

save_masko      #       4
save_xcoord     #       4
save_ycoord     #       4
save_inputxsize #       4
save_inputysize #       4
save_tempxsize  #       4
save_tempysize  #       4
save_xftimesyf  #       4
save_xmag       #       4
save_ymag       #       4

save_inflags    #       4
save_inlog2bpp  #       4
save_inlog2bpc  #       4
save_inbpp      #       4
save_mode       #       4               ; used in PaintChar
save_spr_type   #       4

save_maskinshift #      4
save_maskinptr  #       4
save_maskinoffset #     4

                [ multibuffer
pc_ecflimit0    #       nbuffers :SHL: 2        ; addresses inside macro code
pc_outoffset0   #       nbuffers :SHL: 2
thisslot        #       4
calladdr20      #       nbuffers :SHL: 2
calladdr0       #       nbuffers :SHL: 2
                |
pc_ecflimit     #       4                       ; addresses inside macro code
pc_outoffset    #       4
                ]


inmode          #       4
inlog2px        #       4
inlog2py        #       4
ColourTTR       #       4

nextrowdata     #       12
nextcoldata     #       12
TOTAL           #       4
XTOTAL          #       4

vduspritepars   #       4+4         ; sprite code, areaCBptr ...
vduspritename   #       12          ; ... name

changedbox      #       4

spritecode      #       4

                ; things MOVED to let ccompiler get at them.

                [ ignore_ttr
trns_palette    #       4
                [ flagbit
trns_flags2     #       4
                ]
                ]

BPC             #       4
BPP             #       4

ccompiler_bitblockmove # 4      ; routine for C to call back into assembler.
calibration_table # 4           ; printer calibration table

              [ jpeg
is_it_jpeg      #       4       ; BOOL - is this sprite JPEG?
ctrans_recent   #       4       ; BOOL - check for ColourTrans 1.25 or later
in_x            #       4       ; initial x coord in input sprite
in_y            #       4       ; initial y coord in input sprite
fetchroutine    #       4       ; routine for compiled code to call to get line of JPEG data.
save_sprite     #       4       ; the actual source sprite
jpeg_info_ptr   #       4       ; pointer to JPEG workspace - allocated from RMA if needed
area_number     #       4       ; dynamic area number
              ]

bgcolour        #       4       ; background colour, for plotting mask.
save_PdriverIntercept # 4       ; Flags used to determine if the pdriver is
                                ; currently intercepting the JPEG plots.

dither_truecolour   #   4       ; do we dither true colour images when reducing BPP?

newtranstable   #       256 *4  ; buffer for pixel translation table
                                ; or for palette converted to 16bpp...

; Everything from here up of interest to compiled C
; code. IF THERE ARE ANY CHANGES ABOVE THIS POINT then there must be
; matching changes in the C workspace definition.

spritename      #       12

stackframe      #       4

macroword       #       4

charblock       #       9

       ALIGNHASH        data,16

RAM_SpriteEntry #       12
Sprite_OScopy   #       4       ; copy of OS routine address
OSflag          #       4

       ALIGNHASH        data,16

areaCB          #       0
                #       4               ; saEnd
                #       4               ; saNumber
                #       4               ; saFirst
                #       4               ; saFree
spriteCB        #       0
                #       4               ; spNext
                #       12              ; spName
                #       4               ; spWidth
                #       4               ; spHeight
                #       4               ; spLbit
                #       4               ; spRbit
                #       4               ; spImage
                #       4               ; spTrans
                #       4               ; spMode
spriteEnd       #       0

spriteSize      *       spriteEnd-spriteCB
spriteAreaSize  *       spriteEnd-areaCB + 2*8*8*16/8  ; mode 10 has 16 bpp!
                #       2*8*8*16/8
        ASSERT  (@-areaCB) = spriteAreaSize

        ALIGNHASH       data,16

sp_mode         #       4               ;WT: added for 1bpp mask support
sp2_next        #       4               ;WT: added for 1bpp mask support

sp1_data        #       0
sp1_width       #       4
sp1_height      #       4
sp1_lbit        #       4
sp1_rbit        #       4
sp1_image       #       4
sp1_trans       #       4
sp1_header      #       4
sp1_imagesize   #       4

sp1_areaCBptr   #       4

sp2_data        #       0
sp2_width       #       4
sp2_height      #       4
sp2_lbit        #       4
sp2_rbit        #       4
sp2_image       #       4
sp2_trans       #       4
sp2_header      #       4
sp2_imagesize   #       4

        ALIGNHASH       data,64

vduoutputbuffer #       0
log2px          #       4
log2py          #       4
Log2bpp         #       4
Log2bpc         #       4

orgx            #       4
orgy            #       4
gwx0            #       4
gwy0            #       4
gwx1            #       4
gwy1            #       4

linelength      #       4
screenstart     #       4
ywindlimit      #       4

modeflags       #       4

                [ multibuffer
buffer0mask     #       nbuffers :SHL: 2
buffer0count    #       nbuffers :SHL: 2
sprite_doesnt_exist_error # 4   ; OSS Pointer to error block in RMA
                                ; AMG moved here to avoid an out of range error

                ]

        ALIGNHASH       data,64

                [ multibuffer
codebuffer0     #       nbuffers * &200
codebuffer      #       &200 ;still needed elsewhere
                |
codebuffer      #       &200
                ]


                [ multibuffer
                |
sprite_doesnt_exist_error # 4   ; OSS Pointer to error block in RMA
                ]

                ; Private space for use by compiled C.
                ; If the C code needs more than this then this area must be extended.
ccompiler_sp    #       4       ; for unexpected jumps out of compiled C
ccompiler_space #       9392    ; C code checks at run-time for there being enough.
ccompiler_end   #       0
ccompiler_errptr #      0       ; os_error pointer for if an OS error lead to exit from C code.

enddata         #       0

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Table of service calls we want
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        ASSERT  Service_ModeChange > Service_Reset
        ASSERT  Service_ResourceFSStarted > Service_ModeChange

ServiceTable
        DCD     0
        DCD     ServiceUrsula - Module_BaseAddr
        DCD     Service_Reset
      [ multibuffer
        DCD     Service_ModeChange
      ]
        DCD     Service_ResourceFSStarted
        DCD     0
        DCD     ServiceTable - Module_BaseAddr

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Service call handler
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Service
        MOV     r0, r0                  ; Indicates there is a service call table

        ; Fast rejection
        TEQ     r1, #Service_ResourceFSStarted
      [ multibuffer
        TEQNE   r1, #Service_ModeChange
      ]
        TEQNE   r1, #Service_Reset
        MOVNE   pc, lr

ServiceUrsula
      [ multibuffer
        TEQ     r1, #Service_ModeChange
        BEQ     modechange
      ]
        TEQ     r1, #Service_Reset      ; Re-initialise on soft reset
        BEQ     Init

        ; ** Drop through for territory started **
        ; OSS A new Territory has started, so I need to re-cache the error block
service_territory_started
        Entry "r0-r11"
        LDR     r12, [r12]
        BL      cache_sprite_doesnt_exist_error
        EXIT

      [ multibuffer

        ; one of the problems with using a quick 'n' fast algorithm like usage counts
        ; for deciding which routine needs replacing is that it has weaknesses. The
        ; specific weakness being dealt with here is that if a long time is spent in
        ; one mode then high usage counts will result for that mode. When a new mode
        ; is selected the new routines needed for that mode will fight over the remaining
        ; slots with a lower usage count. In worst case this will mean that new
        ; routines will be built on virtually every plot!
        ;
        ; there are two options for avoiding this. The first is to hold a time stamp
        ; to indicate when a routine was last used. This option has been rejected
        ; because of the overhead of calling the SWI. The second is to junk all the
        ; currently built routines on a mode change. This may result in some routines
        ; being rebuilt which have already been built, but will avoid the scenario
        ; outlined above.
        ;
        ; note that I am not clearing the associated macrowords for each routine - this
        ; should help to avoid too many needless rebuilds of routines

modechange
        Push    "R0-R2,R12,LR"

        ; zero the workspace pointer for JPEG - allocated from RMA if needed
        MOV     R0,#0
        ADRL    R2,jpeg_info_ptr
        STR     R0,[R2]

        LDR     R0,[R12]
        MOVS    R12,R0
        BEQ     modechange_nospace

        ADRL    R0,buffer0count
        MOV     R1,#((nbuffers :SHL: 2)-4)
        MOV     R2,#0
modechange_loop
        STR     R2,[R0,R1]
        SUBS    R1,R1,#4
        BPL     modechange_loop
        Debug   mb,"Clearing all usage counts on mode change"
modechange_nospace
        Pull    "R0-R2,R12,PC"
      ]

; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
; Initialisation
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Init
        Push    "R0-R12,LR"

        LDR     R2,[R12]
        TEQ     R2,#0
        BNE     gotarea

        MOV     R0,#ModHandReason_Claim
        LDR     R3,=enddata-data
        SWI     XOS_Module
        BVS     initexitdie
        STR     R2,[R12]

        ; Set the error pointer to zero only if we are allocating the workspace.
        ; This is because on Service_Reset we have the workspace and we still have
        ; the old cached error block so zeroing the pointer would cause us to
        ; never free that block.

        MOV     r0, #0
        STR     r0, [r2, #:INDEX:sprite_doesnt_exist_error]
gotarea
        MOV     R12,R2

        MOV     R0,#-1
        STR     R0,inmode
        STR     R0,macroword

        MOV     R0,#0
        STR     R0,vduspritename

        ; OSS Attempt to cache the error. This may well fail, but we ignore the
        ; failure. We will get another go later on Service_TerritoryStarted and
        ; that time it should succeed.

        BL      cache_sprite_doesnt_exist_error
02
      [ multibuffer
        ; set up the buffer usage counts and current macrowords
        ADR     R4,buffer0mask
        ADR     R5,buffer0count
        MOV     R6,#0
        MOV     R7,#((nbuffers :SHL: 2)-4)
20
        STR     R6,[R4,R7]
        STR     R6,[R5,R7]
        SUBS    R7,R7,#4
        BPL     %BT20
      ]
        CLRV

        ; Hook onto the Sprite vector
        Claim   SpriteV,My_SpriteOp

        MOVVC   R0,#-1
        SWIVC   XOS_ChangedBox  ; R1 --> 5-word block for changed coords
        STRVC   R1,changedbox

        BLVC    readvduvars     ; read for later

      [ file
        Debug_Open "<Debug$File>"
      ]

        MOV     R7,#0
        ADRL    R6,ccompiler_space
        STR     R7,[R6]                   ; mark the ccompiler workspace clearly as uninitialised
        ADRL    r0,bitblockmove           ; ensure C code has access to bitblockmove
        STR     r0,ccompiler_bitblockmove

      [ jpeg
        ; set up the fetchroutine, for use by any subsequent compiled code.
        ADRL    R2,jpeg_fetchroutine
        STR     R2,fetchroutine

        ; zero the workspace pointer for JPEG - allocated from RMA if needed
        MOV     R0,#0
        ADRL    R2,jpeg_info_ptr
        STR     R0,[R2]

        ; clear priver intercept flags....
        MOV     r0, #0
        ADRL    r2, save_PdriverIntercept
        STR     r0, [r2]
      ]
        ; initialise dithering off..
        MOV     r0, #0
        ADRL    r2, dither_truecolour
        STR     r0, [r2]

        ; check ColourTrans version is up to date
        ADR     r0, init_ctrans_check
        SWI     XOS_CLI
        MOVVS   r0, #0
        MOVVC   r0, #-1
        ADRL    r2, ctrans_recent
        STR     r0, [r2]
        
initexitdie
        STRVS   R0, [sp]
        Pull    "R0-R12,PC"

init_ctrans_check
        DCB     "RMEnsure ColourTrans 1.25 Error 1",0
        ALIGN

Die
        Push    "R0-R12,LR"
        LDR     R12,[R12]       ; R12 --> workspace

        ; OSS Free the cached "Sprite doesn't exist" error block - never
        ; returns errors.
        BL      free_sprite_doesnt_exist_error

      [ file
        Debug_Close
      ]

      [ jpeg
      [ dynamicarea
        ADRL    R1, area_number              ; dynamic area number
        LDR     R1, [R1]
        CMP     R1, #0
        MOVNE   R0, #1
        SWINE   XOS_DynamicArea
      |
        ; if JPEG workspace has been allocated, free it.
        ADRL    R2,jpeg_info_ptr
        LDR     R2,[R2]
        CMP     R2,#0
        MOVNE   R0,#ModHandReason_Free
        SWINE   OS_Module                  ; free block
      ]
      ]

        ; Unhook from Sprite vector
        Release SpriteV,My_SpriteOp             ; OSS  Errors from this ARE returned
01
        B       initexitdie

        GET     Sources.SprOp
        GET     Sources.SWIs
        GET     Sources.SprAdjSize
        GET     Sources.SprTrans
        GET     Sources.MsgCode
        GET     Sources.PutScaled

      [ debug
        InsertNDRDebugRoutines
        InsertDebugRoutines
        InsertHostDebugRoutines
      ]

        END

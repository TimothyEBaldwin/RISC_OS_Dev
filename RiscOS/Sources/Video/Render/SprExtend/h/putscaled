/* Copyright 2010 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* h.PutScaled
   More interface between core code and SpriteExtend innards.
   started: 12 Sep 93 WRS
*/

#ifndef putscaled_h_
#define putscaled_h_

/**************************************************************************
*                                                                         *
*    Pertinent structures.                                                *
*                                                                         *
**************************************************************************/

/* A sprite header, copied from RISC_OSLib */
typedef struct
{
 int next;
 char name[12];
 int width;
 int height;
 int lbit;
 int rbit;
 int image;
 int mask;
 int mode;
} sprite_header;

/* Printer calibration table - definition internal to ColourTrans,
 * colour printer drivers.
 */
typedef struct
{
  int version;            /* table version number - must be 0 */
  int idealblack;         /* if not 0, need to do colour skewing */
  int idealwhite;         /* if not &FFFFFF00, need to do colour skewing */
  int postprocessSWI;     /* if not 0, need to call ColourTrans */
  /* If idealblack==0, idealwhite==&ffffff00, postprocessSWI==0 then we can do the
   * colour calibration by doing thee lookups. Otherwise, you have to call ColourTrans for
   * each pixel.
   */
  int tablecount;         /* number of tables (1 or 3) */
  char redtable[256];     /* if tablecount==1 this is blue and green tables too */
  char greentable[256];   /* translate 24-bit colour values by doing a lookup for each colour */
  char bluetable[256];
} calibration_table;

/**************************************************************************
*                                                                         *
*    Assembler Workspace declarations.                                    *
*                                                                         *
**************************************************************************/

/* These correspond to the assembler workspace. Changes to either must
 * be synchronised.
 */
typedef struct
{
  #define WP_FIRST_FIELD save_outoffset
  int    save_outoffset;  /* #       4       ; reloaded from R12 */
  int    save_inoffset;   /* #       4 */
  int *  save_inptr;      /* #       4 */
  int *  save_outptr;     /* #       4 */
  int    save_ydiv;       /* #       4 */
  int    save_yadd;       /* #       4 */
  int    save_ysize;      /* #       4 */
  int    save_ycount;     /* #       4 */


  int    save_inshift;    /* #       4       ; <---!   this data is copied onto the stack */
  int    save_outword;    /* #       4       ;     !   so that R12 can be re-used */
  int    save_outmask;    /* #       4       ;     ! */
  int    save_xsize;      /* #       4       ;     ! */
  int    save_xcount;     /* #       4       ;     ! */
  int    save_ecfptr;     /* #       4       ;   --!   up to here is reloaded using LDMIA */
  int    save_ecflimit;   /* #       4       ;     ! */
  int    save_vcount;     /* #       4       ;     ! */
  int    save_xdiv;       /* #       4       ;     ! */
  int    save_xadd;       /* #       4       ; <---! */

  int    save_masko;      /* #       4 */
  int    save_xcoord;     /* #       4 */
  int    save_ycoord;     /* #       4 */
  int    save_inputxsize; /* #       4 */
  int    save_inputysize; /* #       4 */
  int    save_tempxsize;  /* #       4 */
  int    save_tempysize;  /* #       4 */
  int    save_xftimesyf;  /* #       4 */
  int    save_xmag;       /* #       4 */
  int    save_ymag;       /* #       4 */

  int    save_inflags;    /* #       4      */
  int    save_inlog2bpp;  /* #       4 */
  int    save_inlog2bpc;  /* #       4 */
  int    save_inbpp;      /* #       4 */
  int    save_mode;       /* #       4               ; used in PaintChar */
  int    save_spr_type;   /* #       4 */

  int    save_maskinshift; /* #      4 */
  int    save_maskinptr;  /* #       4 */
  int    save_maskinoffset; /* #     4 */

#ifdef ASMmultibuffer
  int    pc_ecflimit0[ASMnbuffers];     /* #       nbuffers :SHL: 2              ; addresses inside macro code */
  int    pc_outoffset0[ASMnbuffers];    /* #       nbuffers :SHL: 2 */
  int    thisslot;         /* #       4 */
  int    calladdr20[ASMnbuffers];       /* #       nbuffers :SHL: 2               */
  int    calladdr0[ASMnbuffers];        /* #       nbuffers :SHL: 2 */
#else
  int    pc_ecflimit;     /* #       4                       ; addresses inside macro code */
  int    pc_outoffset;    /* #       4 */
#endif


  int    inmode;          /* #       4 */
  int    inlog2px;        /* #       4 */
  int    inlog2py;        /* #       4 */
  int    ColourTTR;       /* #       4 */

  int    nextrowdata[3];     /* #       12 */
  int    nextcoldata[3];     /* #       12 */
  int    TOTAL;           /* #       4 */
  int    XTOTAL;          /* #       4 */

  int    vduspritepars[2];   /* #       4+4         ; sprite code, areaCBptr ... */
  int    vduspritename[3];   /* #       12          ; ... name */

  int    changedbox;      /* #       4 */

  int    spritecode;      /* #       4 */

                /* ; things MOVED to let ccompiler get at them. */

#ifdef ASMignore_ttr
  int    trns_palette;    /* #       4 */
#endif
#ifdef ASMflagbit
  int    trns_flags2;      /* #       4      ; Added when merged with 0.62 (GPS)*/
#endif

  int    BPC;             /* #       4 */
  int    BPP;             /* #       4 */

  int    ccompiler_bitblockmove; /* # 4     ; routine for C to call back into assembler. */
  calibration_table * cal_table; /* # 4     ; printer calibration table */

#if 1
  BOOL   is_it_jpeg;      /* #       4 */
  BOOL   ctrans_recent;   /* #       4 */
  int    in_x;            /* #       4       ; initial x coord in input sprite */
  int    in_y;            /* #       4       ; initial y coord in input sprite */
  int    fetchroutine;    /* #       4       ; routine for compiled code to call to get line of JPEG data. */
  sprite_header * save_sprite;     /* #       4       ; the actual source sprite */
  decompress_info_ptr jpeg_info_ptr; /* #       4       ; pointer to JPEG workspace */
  int    area_number;       /* #       4      ; dynamic area number*/
#endif

  int    bgcolour;            /* #       4       ; background colour, for plotting mask. */
  int    save_PdriverIntercept; /* #  4       ; Flags used to determine if the pdriver is*/


  BOOL   dither_truecolour;    /* #       4       ; do we dither true colour images when reducing BPP? */

  int    newtranstable[256];   /*   #       256 *4                  ; buffer for pixel translation table */
} asm_workspace;

/**************************************************************************
*                                                                         *
*    Exported C functions (called by the assembler part of SpriteExtend   *
*                                                                         *
**************************************************************************/

typedef void (*blitter)(asm_workspace *wp);
blitter putscaled_compiler(asm_workspace *wp, workspace *ws, workspace *ws_end, int gcol);

#endif

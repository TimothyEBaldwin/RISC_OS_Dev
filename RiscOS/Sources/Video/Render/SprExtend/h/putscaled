/* Copyright 2010 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* h.PutScaled
   More interface between core code and SpriteExtend innards.
   started: 12 Sep 93 WRS
*/

#ifndef putscaled_h_
#define putscaled_h_

/**************************************************************************
*                                                                         *
*    Pertinent structures.                                                *
*                                                                         *
**************************************************************************/

/* A sprite header, copied from RISC_OSLib */
typedef struct
{
 int next;
 char name[12];
 int width;
 int height;
 int lbit;
 int rbit;
 int image;
 int mask;
 int mode;
} sprite_header;

/* Printer calibration table - definition internal to ColourTrans,
 * colour printer drivers.
 */
typedef struct
{
  int version;            /* table version number - must be 0 */
  int idealblack;         /* if not 0, need to do colour skewing */
  int idealwhite;         /* if not &FFFFFF00, need to do colour skewing */
  int postprocessSWI;     /* if not 0, need to call ColourTrans */
  /* If idealblack==0, idealwhite==&ffffff00, postprocessSWI==0 then we can do the
   * colour calibration by doing thee lookups. Otherwise, you have to call ColourTrans for
   * each pixel.
   */
  int tablecount;         /* number of tables (1 or 3) */
  char redtable[256];     /* if tablecount==1 this is blue and green tables too */
  char greentable[256];   /* translate 24-bit colour values by doing a lookup for each colour */
  char bluetable[256];
} calibration_table;

/**************************************************************************
*                                                                         *
*    Assembler Workspace declarations.                                    *
*                                                                         *
**************************************************************************/

/* These correspond to the assembler workspace. Changes to either must
 * be synchronised.
 */
typedef struct
{
  #define WP_FIRST_FIELD save_outoffset
  int    save_outoffset;  /* #       4       ; reloaded from R12 */
  int    save_inoffset;   /* #       4 */
  int *  save_inptr;      /* #       4 */
  int *  save_outptr;     /* #       4 */
  int    save_ydiv;       /* #       4 */
  int    save_yadd;       /* #       4 */
  int    save_ysize;      /* #       4 */
  int    save_ycount;     /* #       4 */


  int    save_inshift;    /* #       4 */
  int    save_xsize;      /* #       4 */
  int    save_xcount;     /* #       4 */
  int    save_ecfptr;     /* #       4 */
  int    save_ecflimit;   /* #       4 */
  int    save_xdiv;       /* #       4 */
  int    save_xadd;       /* #       4 */

  int    save_masko;      /* #       4 */
  int    save_xcoord;     /* #       4 */
  int    save_ycoord;     /* #       4 */
  int    save_inputxsize; /* #       4 */
  int    save_inputysize; /* #       4 */
  int    save_xmag;       /* #       4 */
  int    save_ymag;       /* #       4 */

  int    save_inlog2bpp;  /* #       4 ; <- updated by readspritevars, SWIJPEG_PlotScaled */
  int    save_inlog2bpc;  /* #       4 ; <- updated by readspritevars, SWIJPEG_PlotScaled */
  int    save_inbpp;      /* #       4 ; <- updated by readspritevars, SWIJPEG_PlotScaled */
  int    save_mode;       /* #       4 ; input sprite mode word, only used by putscaled_compiler */
  int    save_spr_type;   /* #       4 ; top 5 bits of sprite mode word, a bit useless if RISC OS 5 sprite mode word */

  int    save_maskinshift; /* #      4 */
  int    save_maskinptr;  /* #       4 */
  int    save_maskinoffset; /* #     4 */

#ifdef ASMmultibuffer
  int    pc_ecflimit0[ASMnbuffers];     /* #       nbuffers :SHL: 2              ; addresses inside macro code */
  int    pc_outoffset0[ASMnbuffers];    /* #       nbuffers :SHL: 2 */
  int    thisslot;         /* #       4 */
  int    calladdr20[ASMnbuffers];       /* #       nbuffers :SHL: 2               */
  int    calladdr0[ASMnbuffers];        /* #       nbuffers :SHL: 2 */
#else
  int    pc_ecflimit;     /* #       4                       ; addresses inside macro code */
  int    pc_outoffset;    /* #       4 */
#endif


  int    inmode;          /* #       4 ; <- updated by readspritevars, SWIPJEG_PlotScaled */
  int    inlog2px;        /* #       4 ; <- updated by readspritevars, SWIPJEG_PlotScaled */
  int    inlog2py;        /* #       4 ; <- updated by readspritevars, SWIPJEG_PlotScaled */
  int    ColourTTR;       /* #       4 */

  int    changedbox;      /* #       4 */

  int    spritecode;      /* #       4 ; SpriteOp reason code we were called with */

#ifdef ASMignore_ttr
  int    trns_palette;    /* #       4 */
#endif
#ifdef ASMflagbit
  int    trns_flags2;      /* #       4      ; Added when merged with 0.62 (GPS)*/
#endif

  int    log2px;          /* #       4 ; <- updated by readvduvars */
  int    log2py;          /* #       4 ; <- updated by readvduvars */
  int    Log2bpp;         /* #       4 ; <- updated by readvduvars */
  int    Log2bpc;         /* #       4 ; <- updated by readvduvars */
  int    orgx;            /* #       4 ; <- updated by readvduvars */
  int    orgy;            /* #       4 ; <- updated by readvduvars */
  int    gwx0;            /* #       4 ; <- updated by readvduvars, tweaked elsewhere for double pixel modes */
  int    gwy0;            /* #       4 ; <- updated by readvduvars */
  int    gwx1;            /* #       4 ; <- updated by readvduvars, tweaked elsewhere for double pixel modes */
  int    gwy1;            /* #       4 ; <- updated by readvduvars */
  int    linelength;      /* #       4 ; <- updated by readvduvars */
  int    screenstart;     /* #       4 ; <- updated by readvduvars */
  int    ywindlimit;      /* #       4 ; <- updated by readvduvars */
  int    modeflags;       /* #       4 ; <- updated by readvduvars */
  int    ncolour;         /* #       4 ; <- updated by readvduvars */
  int    BPC;             /* #       4 ; <- updated by readvduvars */
  int    BPP;             /* #       4 ; <- updated by readvduvars */

  int    ccompiler_bitblockmove; /* # 4     ; routine for C to call back into assembler. */
  calibration_table * cal_table; /* # 4     ; printer calibration table */

#ifdef ASMjpeg
  BOOL   is_it_jpeg;      /* #       4 */
  BOOL   ctrans_recent;   /* #       4 */
  int    in_x;            /* #       4       ; initial x coord in input sprite */
  int    in_y;            /* #       4       ; initial y coord in input sprite */
  int    fetchroutine;    /* #       4       ; routine for compiled code to call to get line of JPEG data. */
  sprite_header * save_sprite;     /* #       4       ; the actual source sprite */
  decompress_info_ptr jpeg_info_ptr; /* #       4       ; pointer to JPEG workspace */
  int    area_number;     /* #       4      ; dynamic area number*/
#endif

  int    save_PdriverIntercept; /* #  4       ; Flags used to determine if the pdriver is*/


  BOOL   dither_truecolour; /* #   4       ; do we dither true colour images when reducing BPP? */
  int    ecfyoffset_ptr;    /* #   4       ; pointer to Kernel's ECF offset & shift values, required for dithering */
  int    ecfshift_ptr;      /* #   4 */

  int    CPUFlags;          /* #   4       ; Flags about which instructions we can use */
#define CPUFlag_LDRH  1     // LDRH/STRH available
#define CPUFlag_BLX   2     // BLX available
#define CPUFlag_MOVW  4     // MOVW available


  int    newtranstable[256];   /*   #       256 *4                  ; buffer for pixel translation table */
} asm_workspace;

/**************************************************************************
*                                                                         *
*    Exported C functions (called by the assembler part of SpriteExtend)  *
*                                                                         *
**************************************************************************/

typedef void (*blitter)(asm_workspace *wp);

#endif

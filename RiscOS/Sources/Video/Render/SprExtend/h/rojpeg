/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* h.rojpeg
   Interface between core code and SpriteExtend innards.
   started: 12 Sep 93 WRS
*/

#ifndef rojpeg_h_
#define rojpeg_h_

/* Error diffused dithering */
char *asm_get_table32k(int *palette_data);
void asm_diffuse_to_8bpp(int *line, int linelength, char *output, char *table32k, int nlines, int linestep, int *palette_data);
void asm_diffuse_to_24bpp(int *line, int linelength, int *output, char *table32k, int nlines, int linestep, int *palette_data);

/* Called from the assembler code if something terrible went wrong */
void panic_trace(decompress_info_ptr cinfo, int *regblock, int code);

/* Entry points used by CFSI assembler code */
int do_jpeg_scan_file_32(char *space, int space_size, const JOCTET *file_image, int image_length);
int do_jpeg_scan_file_16(char *space, int space_size, const JOCTET *file_image, int image_length);

/* Used by both CFSI and SpriteExtend assembler code */
typedef struct
{
  int type; /* Bits   0-2: 1=monochrome, 3=YUV or RGB, 4=CMYK or YCCK
             *        3-6: unused
             *          7: image density was a ratio
             *       8-11: SOF type
             *      12-31: unused
             */
  int width;
  int height;
  int density;
} image_dims_info;
_kernel_oserror *jpeg_find_image_dims(const char *jdata, image_dims_info *image, int *ws_size);
#define jfid_OK          (_kernel_oserror *)0
#define jfid_NOT_JPEG    (_kernel_oserror *)1
#define jfid_CANT_RENDER (_kernel_oserror *)2

/* Return a pointer to the fully decompressed scan line of 32-bit pixels at the given y coordinate.
 * This might be in the already-decompressed band buffer, or it might require decompression
 * of a band. Only pixels between xmin and xmax in the original scan-file are assured of being correct.
 * 
 * If ycoord is outside the acceptable range (0..image_height-1) the result may well
 * be trash.
 */
int *jpeg_find_line(decompress_info_ptr cinfo, int ycoord, int *palette_data);

/* Given a file image and all necessary workspace, scan the file image,
 * build an array of band pointers into it. file_image points to image_length
 * bytes, which should be a JFIF file. Only two forms of file are accepted - a
 * greyscale single-scan file, and an interlaced YUV (YCbCr) file.
 * 
 * A non-zero error code is returned if an error occurred. Reason code in
 *   cinfo->error_code           (same as returned result)
 *   cinfo->error_argument       (any additional argument)
 * Typical reasons include an unacceptable or badly formed JPEG file.
 *
 * cinfo must point to cinfo->workspace_size bytes of available workspace. This
 * should be about 50K for typical JPEG files, or 20K + 4*16*max width of JPEG
 * file you wish to work with. If it's not big enough then
 * cinfo->error_argument is set to what it needs to be - you are welcome to
 * allocate more space and call again.
 * 
 * If the file is at the same address as the previous call, and a sample of the
 * data is the same, then jpeg_scan_file guesses that it's the same data - it's hard to
 * do a random update to the data of a JPEG file.
 * 
 * width and height say how big the resulting image should be - complain if not
 * precisely correct. If double size and band buffer is big enough, interpolate
 * upwards If width==-1 the width test is omitted. If height==-1 the height
 * test is omitted.
 * 
 * (It would be wonderful to feed in scale factors too, so that strange combinations of
 * scaling, interpolation etc. made sensible decisions. Unfortunately this requires the
 * calling code to be prepared to accept an output of an unexpected size, say by a factor
 * of 2 or 8. Not this time.)
 * 
 * Interpolate in the X direction takes twice as much store, and will only be done if
 * it will fit. On return, if it was requested, cinfo->error_argument1 will have
 * jopt_INTERP_X set if the interpolation is enabled. jopt_OUTBPP_8 and jopt_OUTBPP_16
 * are similar, they constitute a request and they only happen if the corresponding
 * bits of cinfo->error_argument1 are set on exit.
 */
int jpeg_scan_file(decompress_info_ptr cinfo, const JOCTET *file_image, size_t image_length,
                   int xmin, int xmax, int width, int height, int options);

/* JFIF file parsing options */
#define jopt_GREY 1            /* Greyscale output is acceptable, even if the file is colour */
#define jopt_DC_ONLY 2         /* Do only the DC values of the tiles - faster, less accurate */
#define jopt_INTERP_X 4        /* Interpolate in the X direction */
#define jopt_OUTBPP_8 8        /* Output 8bit pixels (assume standard palette) */
#define jopt_OUTBPP_16 16      /* Output 16bit pixels */
#define jopt_OUTBPP_8YUV 32    /* Output 8bit pixels - different method inside (assume std palette) */
#define jopt_DIFFUSE 64        /* Error diffuse data to palette entries */
#define jopt_OUTBPP_8GREY 128  /* Output 8bit grey pixels (assume need ascending grey palette) */
#define jopt_HUFF_ONLY 0x10000 /* For timing only - just do the huffman decoding */
#define jopt_DCT_ONLY  0x20000 /* For timing only - just do huffman and DCT, not colour transform */

/* Get from RGB=YYY word to 4 pixels of luma */
#define YYYTOYYYY(k) ((k) | ((k)<<8)) 

#endif

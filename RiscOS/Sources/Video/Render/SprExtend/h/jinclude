/*
 * jinclude.h
 *
 * Copyright (C) 1991, 1992, Thomas G. Lane.
 * This file is part of the Independent JPEG Group's software.
 * For conditions of distribution and use, see the accompanying README file.
 *
 * This is the central file that's #include'd by all the JPEG .c files.
 * Its purpose is to provide a single place to fix any problems with
 * including the wrong system include files.
 * You can edit these declarations if you use a system with nonstandard
 * system include files.
 */

/* RISCOS thing - only allow this file to be included once */
#ifndef jinclude__
#define jinclude__


/*
 * Normally the __STDC__ macro can be taken as indicating that the system
 * include files conform to the ANSI C standard.  However, if you are running
 * GCC on a machine with non-ANSI system include files, that is not the case.
 * In that case change the following, or add -DNONANSI_INCLUDES to your CFLAGS.
 */

#ifdef __STDC__
#ifndef NONANSI_INCLUDES
#define INCLUDES_ARE_ANSI       /* this is what's tested before including */
#endif
#endif

/*
 * We need the size_t typedef, which defines the parameter type of malloc().
 * In an ANSI-conforming implementation this is provided by <stdio.h>,
 * but on non-ANSI systems it's more likely to be in <sys/types.h>.
 * On some not-quite-ANSI systems you may find it in <stddef.h>.
 */

#ifndef INCLUDES_ARE_ANSI       /* shouldn't need this if ANSI C */
#include <sys/types.h>
#endif
#ifdef __SASC                   /* Amiga SAS C provides it in stddef.h. */
#include <stddef.h>
#endif

/*
 * In ANSI C, and indeed any rational implementation, size_t is also the
 * type returned by sizeof().  However, it seems there are some irrational
 * implementations out there, in which sizeof() returns an int even though
 * size_t is defined as long or unsigned long.  To ensure consistent results
 * we always use this SIZEOF() macro in place of using sizeof() directly.
 */

#undef SIZEOF                   /* in case you included X11/xmd.h */
#define SIZEOF(object)  ((size_t) sizeof(object))

/*
 * We need the memcpy() and strcmp() functions, plus memory zeroing.
 * ANSI and System V implementations declare these in <string.h>.
 * BSD doesn't have the mem() functions, but it does have bcopy()/bzero().
 * NOTE: we assume the size parameters to these functions are of type size_t.
 * Insert casts in these macros if not!
 */

#ifdef INCLUDES_ARE_ANSI
  #include <string.h>
  #define MEMZERO(voidptr,size)   memset((voidptr), 0, (size))
#else /* not ANSI */
  #ifdef BSD
    #include <strings.h>
    #define MEMZERO(voidptr,size)   bzero((voidptr), (size))
    #define memcpy(dest,src,size)   bcopy((src), (dest), (size))
  #else /* not BSD, assume Sys V or compatible */
    #include <string.h>
    #define MEMZERO(voidptr,size)   memset((voidptr), 0, (size))
  #endif /* BSD */
#endif /* ANSI */


/* Now include the portable JPEG definition files. */
#include "jconfig.h"
#include "jpegdata.h"

/* For jdcolor */
int mono_convert_pixel(int pix);
void mono_convert_pixels(int *y);
void mono_convert_block(JBLOCK jblock, int *outptr, int outoffset);
void mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset);
void colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset,
                                  int wide, int high);
void colour_convert_pixels(int *y, int u, int v);
void colour_convert_block_8(JBLOCK jblock, char *outptr, int outoffset);
void colour_convert_block_16(JBLOCK jblock, short *outptr, int outoffset);
void colour_convert_block_32(JBLOCK jblock, int *outptr, int outoffset);

#ifdef ASMIDCT
/* Optionally assembler coded IDCT stuff */
#define jpeg_idct_ifast(i,b,c)            asm_jpeg_idct_ifast(i,b,c)
void asm_jpeg_idct_ifast(decompress_info_ptr cinfo, JBLOCK block, int count);
#endif

#ifdef ASMHUFF
/* Optionally assembler coded Huffman stuff */
#define huff_decode_blocks(a,b,c,d,e,f,g) asm_huff_decode_blocks(a,b,c,d,e,f,g)
#define huff_skip_blocks(a,b,c,d,e,f,g)   asm_huff_skip_blocks(a,b,c,d,e,f,g)
void asm_huff_decode_blocks(decompress_info_ptr cinfo, JBLOCK block,
                            HUFF_TBL *dctbl, HUFF_TBL *actbl, QUANT_TBL_PTR quanttbl,
                            int *last_dc_val, int nblocks);
void asm_huff_skip_blocks(decompress_info_ptr cinfo, JBLOCK block,
                          HUFF_TBL *dctbl, HUFF_TBL *actbl, QUANT_TBL_PTR quanttbl,
                          int *last_dc_val, int nblocks);
#endif

#ifdef ASMCOLOR
/* Optionally assembler coded colour conversion stuff */
#define mono_convert_pixel(p)             asm_mono_convert_pixel(p)
#define mono_convert_pixels(y)            asm_mono_convert_pixels(y)
#define mono_convert_block(j,o,f)         asm_mono_convert_block(j,o,f)
#define mono_convert_block_8(j,o,f)       asm_mono_convert_block_8(j,o,f)
#define colour_convert_block_8(j,o,f)     asm_colour_convert_block_8(j,o,f)
#define colour_convert_block_16(j,o,f)    asm_colour_convert_block_16(j,o,f)  
#define colour_convert_block_32(j,o,f)    asm_colour_convert_block_32(j,o,f)
#define colour_convert_unusual_block(a,b,c,d,e) asm_colour_convert_unusual_block(a,b,c,d,e)
#define colour_convert_pixels(y,u,v)      asm_colour_convert_pixels(y,u,v)
int asm_mono_convert_pixel(int pix);
void asm_mono_convert_pixels(int *y);
void asm_mono_convert_block(JBLOCK jblock, int *outptr, int outoffset);
void asm_mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset);
void asm_colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset,
                                      int wide, int high);
void asm_colour_convert_pixels(int *y, int u, int v);
void asm_colour_convert_block_8(JBLOCK jblock, char *outptr, int outoffset);
void asm_colour_convert_block_16(JBLOCK jblock, short *outptr, int outoffset);
void asm_colour_convert_block_32(JBLOCK jblock, int *outptr, int outoffset);
#endif

#endif


#define JPEG_INTERNALS
#include "jinclude.h"
#include "jpeglib.h"

#ifndef ASMCOLOR

#define SCALEBITS       19
#define ONE_HALF        ((INT32) 1 << (SCALEBITS - 1))
#define FIX(x)          ((INT32) ((x) * (1L<<SCALEBITS) + 0.5))

/*****************************************************************************
*                                                                            *
*   Monochrome colour conversion                                             *
*                                                                            *
*****************************************************************************/

int mono_convert_pixel(int pix)
/* Just do a single pixel - eg. for DC-only display. The pixel does not have to
 * be shifted down, as it has not gone through the DCT.
 */
{
  int y = pix;

  y = ((y + 4) >> 3) + 128;      /* normalise */
  if (y < 0) y = 0;              /* range check */
  if (y > 255) y = 255;
  
  return y | (y << 8) | (y << 16); /* replicate Y value */
}

void mono_convert_pixels(int *y)
/* Convert four pixels. Input y values are in y[0..3], put output there too.
 * Used for DC-only mono output. The input pixels do not have to be shifted
 * down by 19, as they have not been through the DCT.
 */
{
  int i;
  int yy;

  for (i = 0; i < 4; i++)
  {
    yy = ((y[i] + 4) >> 3) + 128;
    if (yy < 0) yy = 0; if (yy > 255) yy = 255;
    y[i] = yy | (yy << 8) | (yy << 16);
  }
}

void mono_convert_block_8(JBLOCK jblock, int *outptr, int outoffset)
/* Convert greyscale image into 8bit Grey values. */
{
  int i, j;
  char *pixel;

  for (j = 0; j < 8; j++)
  {
    pixel = (char *)outptr;
    for (i = 0; i < 8; i++)
    {
      int y;

      y = jblock[j + i*8];             /* extract, NB in row order */
      y = (y + ONE_HALF) >> SCALEBITS; /* descale */

      y += 128;                        /* normalise */
      if (y < 0) y = 0;                /* clip */
      if (y > 255) y = 255;            

      pixel[i] = y;                    /* store the pixel value */
    }
    outptr += outoffset;
  }
}

void mono_convert_block(JBLOCK jblock, int *outptr, int outoffset)
/* Convert greyscale image into 32bit RGB values. */
{
  int i, j;

  for (j = 0; j < 8; j++)
  {
    for (i = 0; i < 8; i++)
    {
      int y;

      y = jblock[j + i*8];             /* extract, NB in row order */
      y = (y + ONE_HALF) >> SCALEBITS; /* descale */

      y += 128;                        /* normalise */
      if (y < 0) y = 0;                /* clip */
      if (y > 255) y = 255;
      y = y | (y << 8) | (y << 16);    /* construct RGB value */
      outptr[i] = y;
    }
    outptr += outoffset;
  }
}

/*****************************************************************************
*                                                                            *
*   YUV->RGB colour conversion.                                              *
*                                                                            *
*****************************************************************************/

void colour_convert_unusual_block(JCOEF *yuv, int *outptr, int outoffset, int wide, int high)
/* yuv[0..1] are Y, yuv[4] is U, yuv[5] is V. wide/high are 1 or 2.
 * Both being 2 is the most common case, for which we use hand-coded assembler instead.
 */
{
  int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *bu =  yuv + 4*DCTSIZE2;
  JCOEF *bv =  yuv + 5*DCTSIZE2;

  for (j = 0; j < 8*high; j++)
  {
    for (i = 0; i < 8*wide; i++)
    {
      int y;
      int u;
      int v;

      /* Simplification because we don't use this code in the 2x2 case, so
       * we only need to worry about accessing a second block. */

      y = ((i < 8 && j < 8) ? by0 : by1)[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>(high-1)) + (i>>(wide-1))*8];
      v = bv[(j>>(high-1)) + (i>>(wide-1))*8];

      y = (y + ONE_HALF) >> SCALEBITS;     /* descale */
      y += 128;                            /* normalise */
      u = (u + ONE_HALF) >> SCALEBITS;
      v = (v + ONE_HALF) >> SCALEBITS;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += ONE_HALF; r >>= SCALEBITS; r += y; if (r < 0) r = 0; if (r > 255) r = 255;
        g += ONE_HALF; g >>= SCALEBITS; g += y; if (g < 0) g = 0; if (g > 255) g = 255;
        b += ONE_HALF; b >>= SCALEBITS; b += y; if (b < 0) b = 0; if (b > 255) b = 255;
        outptr[i] = r | (g << 8) | (b << 16);
      }
    }
    outptr += outoffset;
  }
}

void colour_convert_pixels(int *y, int u, int v)
/* Convert four pixels. Input y values are in y[0..3], put output there too.
 * Used for DC-only colour output. The input pixels do not have to be shifted
 * down by SCALEBITS, as they have not been through the DCT.
 */
{
  u = (u + 4) >> 3; /* descale */
  v = (v + 4) >> 3;

  {
    int r =                        v * FIX(1.40200);
    int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
    int b =     u * FIX(1.77200);
    int i;
    int rr, gg, bb, yy;

    r += ONE_HALF; r >>= SCALEBITS;
    g += ONE_HALF; g >>= SCALEBITS;
    b += ONE_HALF; b >>= SCALEBITS;
    for (i = 0; i < 4; i++)
    {
      yy = ((y[i] + 4) >> 3) + 128;
      rr = r + yy; if (rr < 0) rr = 0; if (rr > 255) rr = 255;
      gg = g + yy; if (gg < 0) gg = 0; if (gg > 255) gg = 255;
      bb = b + yy; if (bb < 0) bb = 0; if (bb > 255) bb = 255;
      y[i] = rr | (gg << 8) | (bb << 16);
    }
  }
}

void colour_convert_block_16(JCOEF *yuv, short *outptr, int outoffset)
/* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 16bit pixels */
{
  int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *by2 = yuv + 2*DCTSIZE2;
  JCOEF *by3 = yuv + 3*DCTSIZE2;
  JCOEF *bu =  yuv + 4*DCTSIZE2;
  JCOEF *bv =  yuv + 5*DCTSIZE2;
  int *words = (int *)outptr;
  unsigned int pair = 0;

  for (j = 0; j < 16; j++)
  {
    for (i = 0; i < 16; i++)
    {
      int  y, u, v;
      char dither[4];

#if 1
      dither[0] = 2; dither[1] = 6;
      dither[2] = 4; dither[3] = 0;
#else
      dither[0] = dither[1] = dither[2] = dither[3] = 3; /* no dither */
#endif

      y = (j < 8 ? (i < 8 ? by0 : by1) : (i < 8 ? by2 : by3))[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>1) + (i>>1)*8];
      v = bv[(j>>1) + (i>>1)*8];

      y += (dither[((j&1)*2) + (i&1)]<<SCALEBITS);
      y += (125<<SCALEBITS); /* + mean of 3 contributed by dither */
      y += (ONE_HALF<<3);
      u = (u + ONE_HALF) >> SCALEBITS;
      v = (v + ONE_HALF) >> SCALEBITS;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += y; r >>= (SCALEBITS+3); if (r < 0) r = 0; if (r > 31) r = 31;
        g += y; g >>= (SCALEBITS+3); if (g < 0) g = 0; if (g > 31) g = 31;
        b += y; b >>= (SCALEBITS+3); if (b < 0) b = 0; if (b > 31) b = 31;
        pair = (pair >> 16) | ((r | (g << 5) | (b << 10)) << 16);
        if (i & 1)
        {
          words[i>>1] = pair;
          pair = 0;
        }
      }
    }
    words += outoffset;
  }
}

void colour_convert_block_8(JCOEF *yuv, char *outptr, int outoffset)
/* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block of 8bit pixels */
{
  int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *by2 = yuv + 2*DCTSIZE2;
  JCOEF *by3 = yuv + 3*DCTSIZE2;
  JCOEF *bu =  yuv + 4*DCTSIZE2;
  JCOEF *bv =  yuv + 5*DCTSIZE2;
  int erry, erru, errv;
  extern int *pixel_to_yuv_table_base(void); /* relocation without CMHG */
  extern char *yuv_to_pixel_table_base(void); /* relocation without CMHG */
  const int *pixel_to_yuv_table = pixel_to_yuv_table_base();
  const char *yuv_to_pixel_table = yuv_to_pixel_table_base();

  for (j = 0; j < 8; j++) /* count row pairs output */
  {
    erry = erru = errv = 0; /* new row, wipe the cumulative errors */

    for (i = 0; i < 32; i++) /* count pixels output */
    {
      int  y, u, v;
      char p = i & 3; /* do pixels in 2x2 squares */
      char colour;

      /* 'n' shaped source access, extract from right block, NB row order */
      y = (j < 4 ? (i < 16 ? by0 : by1) : (i < 16 ? by2 : by3))[((j<<1)&7) + (((p - 1)&2)>>1) + (((i&15)>>1)*8)];
      u = bu[j + (i>>2)*8];
      v = bv[j + (i>>2)*8];

      y = (y + (128<<SCALEBITS)) >> SCALEBITS; /* descale */
      u = (u + (128<<SCALEBITS)) >> SCALEBITS;
      v = (v + (128<<SCALEBITS)) >> SCALEBITS;

      /* Mix in the errors and clamp */
      y += erry; if (y < 0) y = 0; if (y > 255) y = 255;
      u += erru; if (u < 0) u = 0; if (u > 255) u = 255;
      v += errv; if (v < 0) v = 0; if (v > 255) v = 255;

      /* Combine Y:U:V in the ratio 5:4:4, and use as an index
       * into the YUV->pixel table
       */
#if 1
      colour = yuv_to_pixel_table[((y & 0xF8) << 5) |
                                   (u & 0xF0) |
                                  ((v & 0xF0) >> 4)];
#else
      colour = i + (j * 32); /* test of patterning */
#endif
      /* Reduce patterning by doing a 'n' shaped dance
       *   [ p=1  p=2 ]
       *   [ p=0  p=3 ]
       * which is a 'u' shape when the origin is in the BLHC
       */
      outptr[((p & 2) >> 1) +
             (((p - 1) & 2) ? (outoffset * sizeof(int)) : 0)] = colour;

      /* Lookup backwards to calculate the error term */
      erry = y - ((pixel_to_yuv_table[colour] >> 16) & 0xFF);
      erru = u - ((pixel_to_yuv_table[colour] >> 8) & 0xFF);
      errv = v - ((pixel_to_yuv_table[colour] >> 0) & 0xFF);

      /* Next output pair on this row */
      if (p == 3) outptr += 2;
    }

    /* Start on the left 2 rows down */
    outptr += (outoffset * sizeof(int) * 2) - (DCTSIZE * 2);
  }
}

void colour_convert_block_32(JCOEF *yuv, int *outptr, int outoffset)
/* yuv[0..3] are Y, yuv[4] is U, yuv[5] is V. Output 16*16 colour block */
{
  int i, j;
  JCOEF *by0 = yuv + 0*DCTSIZE2;
  JCOEF *by1 = yuv + 1*DCTSIZE2;
  JCOEF *by2 = yuv + 2*DCTSIZE2;
  JCOEF *by3 = yuv + 3*DCTSIZE2;
  JCOEF *bu =  yuv + 4*DCTSIZE2;
  JCOEF *bv =  yuv + 5*DCTSIZE2;

  for (j = 0; j < 16; j++)
  {
    for (i = 0; i < 16; i++)
    {
      int y, u, v;

      y = (j < 8 ? (i < 8 ? by0 : by1) : (i < 8 ? by2 : by3))[(j&7) + (i&7)*8]; /* extract from right block, NB row order */
      u = bu[(j>>1) + (i>>1)*8];
      v = bv[(j>>1) + (i>>1)*8];

      y = (y + ONE_HALF) >> SCALEBITS;     /* descale */
      y += 128;                            /* normalise */
      u = (u + ONE_HALF) >> SCALEBITS;
      v = (v + ONE_HALF) >> SCALEBITS;
      {
        int r =                        v * FIX(1.40200);
        int g = 0 - u * FIX(0.34414) - v * FIX(0.71414);
        int b =     u * FIX(1.77200);

        r += ONE_HALF; r >>= SCALEBITS; r += y; if (r < 0) r = 0; if (r > 255) r = 255;
        g += ONE_HALF; g >>= SCALEBITS; g += y; if (g < 0) g = 0; if (g > 255) g = 255;
        b += ONE_HALF; b >>= SCALEBITS; b += y; if (b < 0) b = 0; if (b > 255) b = 255;
        outptr[i] = r | (g << 8) | (b << 16);
      }
    }
    outptr += outoffset;
  }
}

#endif

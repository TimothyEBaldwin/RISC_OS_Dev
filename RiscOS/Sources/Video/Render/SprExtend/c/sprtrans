/* Copyright 2013 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#if 1

/* Stack workspace */
typedef struct
{
  int trns_spr_xcoords[4];           /* #       16      ;       Four x coordinates */
  int trns_spr_ycoords[4];           /* #       16      ;       Four y coordinates */
  int trns_comp_spr_left;            /* #       4       ;       Sprite left hand edge (bottom 16 bits) */
  int trns_comp_spr_start;           /* #       4       ;       Sprite start (accounting for internal coord block top) */
  int trns_comp_spr_byte_width;      /* #       4       ;       Sprite byte width << (3-sprite bpp) */
  int trns_comp_spr_height;          /* #       4       ;       Sprite height (top 16 bits) and right hand edge (bottom 16) */
  int trns_comp_spr_ttr;             /* #       4       ;       Translation table (if required) */
  int trns_comp_spr_masko;           /* #       4       ;       Sprite mask offset from image << (3-sprite bpp) */
  int trns_comp_ecf_ora;             /* #       4       ;       ECF OR word */
  int trns_comp_ecf_eor;             /* #       4       ;       ECF EOR word */
  int trns_codebuffer;               /* #       4       ;       Pointer to codebuffer */
  int trns_spr_X_x0_y;               /* #       4       ;       Sprite X,Y at top coordinate of area */
  int trns_spr_Y_x0_y;               /* #       4       ;            in 16.16 fixed point */
  int trns_spr_inc_X_x;              /* #       4       ;       Sprite increments */
  int trns_spr_inc_Y_x;              /* #       4       ;          ( change induced by single */
  int trns_spr_inc_Y_y;              /* #       4       ;            increments in screen x,y on */
  int trns_spr_inc_X_y;              /* #       4       ;            sprite X,Y ) */
  int trns_spr_lineptr;              /* #       4       ;       Line to output onto */
  int trns_spr_edgeblock[6*4];       /* #       6*4*4   ;       Edge blocks, in format as below */
  int trns_spr_edgeblock_end[6];     /* #       4*6     ;        -1, to denote end of edge block */
  int trns_ecf_ptr;                  /* #       4       ;       Ecf pointer */
  int trns_masking_word;             /* #       4       ;       Masking word for > eight bit per pixel */
  int trns_comp_mask_offset;         /* #       4       ;       used to point at 1bpp mask data */
  int trns_comp_spr_mask_width;      /* #       4       ;       1bpp mask equivalent of spr_width */
  int trns_comp_mask_base;           /* #       4       ;       1bpp mask adjustment to mask data */
} stack_ws;

/**************************************************************************
*                                                                         *
*    Overall construction of the X loop.                                  *
*                                                                         *
**************************************************************************/

static void sprtrans_readpixormask(asm_workspace *wp, workspace *ws)
/* Read pixel or mask from [r_inptr, r_inoffset] into r_pixel */
{
  if(wp->save_inlog2bpp < 3)
  {
    ins(ws, LDRB(R(r_pixel), R(r_inptr)) | INDEX_LSR(R(r_inoffset),3-wp->save_inlog2bpp), "LDRB    r_pixel,[r_inptr,r_inoffset,LSR #3-in_l2bpp]");
    AND(R(r_temp1),R(r_inoffset),IMM(7>>wp->save_inlog2bpp),                              "AND     r_temp1,r_inoffset,#7>>in_l2bpp");
    if(wp->save_inlog2bpp > 0)
    {
      MOV(R(r_temp1),OP2R(R(r_temp1)) | LSLI(wp->save_inlog2bpp),                         "MOV     r_temp1,r_temp1,LSL #in_l2bpp");
    }
    MOV(R(r_pixel),OP2R(R(r_pixel)) | LSRR(R(r_temp1)),                                   "MOV     r_pixel,r_pixel,LSR r_temp1");
    AND(R(r_pixel),R(r_pixel),IMM((1<<(1<<wp->save_inlog2bpp))-1),                        "AND     r_pixel,r_pixel,#(1<<(1<<in_l2bpp))-1");
  }
  else if(wp->save_inlog2bpp == 3)
  {
    ins(ws, LDRB(R(r_pixel), R(r_inptr)) | INDEX(R(r_inoffset),0),                        "LDRB    r_pixel,[r_inptr,r_inoffset]");
  }
  else if(wp->save_inlog2bpp == 4)
  {
    if(wp->CPUFlags & CPUFlag_LDRH)
    {
      MOV(R(r_pixel),OP2R(R(r_inoffset)) | LSLI(1),                                          "MOV     r_pixel,r_inoffset,LSL #1");
      ins(ws, 0x019000B0 | (R(r_pixel)<<12) | (R(r_inptr)<<16) | R(r_pixel),                 "LDRH    r_pixel,[r_inptr,r_pixel]");
    }
    else
    {
      ins(ws, LDR(R(r_pixel), R(r_inptr)) | INDEX(R(r_inoffset),1),                       "LDR     r_pixel,[r_inptr,r_inoffset,LSL #1]");
      MOV(R(r_pixel),OP2R(R(r_pixel)) | LSLI(16),                                         "MOV     r_pixel,r_pixel,LSL #16");
      MOV(R(r_pixel),OP2R(R(r_pixel)) | LSRI(16),                                         "MOV     r_pixel,r_pixel,LSR #16");
    }
  }
  else
  {
    ins(ws, LDR(R(r_pixel), R(r_inptr)) | INDEX(R(r_inoffset),2),                         "LDR     r_pixel,[r_inptr,r_inoffset,LSL #2]");
  }
}

static void sprtrans_plotaction(asm_workspace *wp, workspace *ws)
/* Combine r_outword and r_outmask to create the final screen word in r_outword */
{
  if(!TRANSMASK)
  {
    comment(ws,"GCOL action handling");
    if(!ws->gcol)
    {
      if(ws->regnames.r_outmask.regno != -1)
      {
        /* Read screen word if mask not all 1's */
        CMN(R(r_outmask),IMM(1),                              "CMN     r_outmask,#1");
        ins(ws, LDR(R(r_inoffset),R(r_outptr)) | NE,          "LDRNE   r_inoffset,[r_outptr]");
        AND(R(r_outword),R(r_outword),OP2R(R(r_outmask)),     "AND     r_outword,r_outword,r_outmask");
        BIC(R(r_inoffset),R(r_inoffset),OP2R(R(r_outmask)),   "BIC     r_inoffset,r_inoffset,r_outmask");
        EOR(R(r_outword),R(r_inoffset),OP2R(R(r_outword)),    "EOR     r_outword,r_inoffset,r_outword");
      }
      else
      {
        /* Mask is always all 1's! */
      }
    }
    else
    {
      /* Always read screen */
      ins(ws, LDR(R(r_inoffset),R(r_outptr)),                 "LDR     r_inoffset,[r_outptr]");
      if(ws->regnames.r_outmask.regno != -1)
      {
        AND(R(r_outword),R(r_outword),OP2R(R(r_outmask)),     "AND     r_outword,r_outword,r_outmask");
      }
      switch(ws->gcol)
      {
      case 1: /* OR */
        ORR(R(r_outword),R(r_inoffset),OP2R(R(r_outword)),    "ORR     r_outword,r_inoffset,r_outword");
        break;
      case 2: /* AND */
        if(ws->regnames.r_outmask.regno != -1)
        {
          EOR(R(r_outword),R(r_outword),OP2R(R(r_outmask)),   "EOR     r_outword,r_outword,r_outmask");
          BIC(R(r_outword),R(r_inoffset),OP2R(R(r_outword)),  "BIC     r_outword,r_inoffset,r_outword");
        }
        else
        {
          AND(R(r_outword),R(r_inoffset),OP2R(R(r_outword)),  "AND     r_outword,r_inoffset,r_outword");
        }
        break;
      case 3: /* EOR */
        EOR(R(r_outword),R(r_inoffset),OP2R(R(r_outword)),    "EOR     r_outword,r_inoffset,r_outword");
        break;
      case 4: /* invert screen */
        if(ws->regnames.r_outmask.regno != -1)
        {
          EOR(R(r_outword),R(r_inoffset),OP2R(R(r_outmask)),  "EOR     r_outword,r_inoffset,r_outmask");
        }
        else
        {
          MVN(R(r_outword),OP2R(R(r_inoffset)),               "MVN     r_outword,r_inoffset");
        }
        break;
      case 5: /* Identity */
        MOV(R(r_outword),OP2R(R(r_inoffset)),                 "MOV     r_outword,r_inoffset");
        break;
      case 6: /* AND with NOT colour */
        BIC(R(r_outword),R(r_inoffset),OP2R(R(r_outword)),    "BIC     r_outword,r_inoffset,r_outword");
        break;
      case 7: /* ORR with NOT colour */
        if(ws->regnames.r_outmask.regno != -1)
        {
          EOR(R(r_outword),R(r_outword),OP2R(R(r_outmask)),   "EOR     r_outword,r_outword,r_outmask");
        }
        else
        {
          MVN(R(r_outword),OP2R(R(r_outword)),                "MVN     r_outword,r_outword");
        }
        ORR(R(r_outword),R(r_inoffset),OP2R(R(r_outword)),    "ORR     r_outword,r_inoffset,r_outword");
        break;
      }
    }
  }
  else
  {
    comment(ws,"Mask plot ECF handling");
    ins(ws, LDR(R(r_inoffset),R(r_outptr)),                   "LDR     r_inoffset,[r_outptr]");
    LDR_SP(r_temp1,trns_comp_ecf_ora)
    LDR_SP(r_outword,trns_comp_ecf_eor)
    if(ws->regnames.r_outmask.regno != -1)
    {
      AND(R(r_temp1),R(r_temp1),OP2R(R(r_outmask)),           "AND     r_temp1,r_temp1,r_outmask");
      AND(R(r_outword),R(r_outword),OP2R(R(r_outmask)),       "AND     r_outword,r_outword,r_outmask");
    }
    ORR(R(r_inoffset),R(r_inoffset),OP2R(R(r_temp1)),         "ORR     r_inoffset,r_inoffset,r_temp1");
    EOR(R(r_outword),R(r_inoffset),OP2R(R(r_outword)),        "EOR     r_outword,r_inoffset,r_outword");
  }
}

static void sprtrans_loop_x(asm_workspace *wp, workspace *ws)
/* Overall control of the code and outer loop */
{
#ifdef DEBUG
  char a[256];
  char b[256];
#endif

  /* Top of the loop */
  newline();

  /* Various useful constants */
  tracef("%t20.in_l2bpp  *     %i %t68; log base 2 of bits per input pixel (2)\n" _ wp->save_inlog2bpp);
  tracef("%t20.out_l2bpp *     %i %t68; log base 2 of bits per output pixel (2)\n" _ wp->Log2bpp);

  /* Fixed registers supplied by the assembler wrapper */
  RN(r_xsize_spr_left, 0,   "top 16: xsize. bottom 16: spr_left");
  RN(r_inptr, 1,            "sprite data pointer");
  RN(r_inoffset, 2,         "offset (in pixels) into sprite");
  RN(r_X, 3,                "X coord in sprite (16.16 fixed point)");
  RN(r_Y, 4,                "Y coord in sprite (16.16 fixed point)");
  RN(r_inc_X_x, 5,          "sprite X increment");
  RN(r_inc_Y_x, 6,          "sprite Y increment");
  RN(r_byte_width, 7,       "byte (pixel?) width/stride of sprite rows");
  RN(r_spr_height_right, 8, "top 16: spr_height. bottom 16: spr_right");
  RN(r_outptr, 9,           "current screen ptr");
  RN(r_out_x, 12,           "screen X coord at start of loop");

  /* Other registers */
  RN(r_temp1, 12,           "temp");
  RN(r_pixel, 14,           "current pixel");
  
  /* Dynamically allocated registers */
  ws->next_free_reg = 10;
  if(!DEST_32_BIT)
  {
    RN(r_outword, -1, "current output word");
    RN(r_outmask, -1, "current output mask");
    ws->next_free_reg = 0;
  }
  else if(!TRANSMASK && SOURCE_MASK)
  {
    RN(r_outword, -1, "current output word");
  }

  if(TRANSMASK)
  {
    /* r_outword needed */
    if(ws->regnames.r_outword.regno == -1)
      RN(r_outword,-1,"Output word");
  }

  /* Work out temporary registers needed by pixel translation code */
  if(!TRANSMASK)
  {
    int need_temps;

    need_temps = translate_pixel_rn(wp,ws,0);
    if(ws->next_free_reg == 12)
      ws->next_free_reg = 0;

    /* Translation table register */
    if(wp->trns_palette || wp->ColourTTR)
    {
      int regno = -1;
      /* If we've run out of registers, but translate_pixel doesn't need any temporaries, use r_temp1 to store the table pointer. We'll have to load the pointer for each pixel, but at least we won't have to temporarily push things onto the stack. */
      if((ws->next_free_reg < 10) && !need_temps)
        regno = ws->regnames.r_temp1.regno;       
      RN(r_table,regno,"translation table");
      if(ws->next_free_reg == 12)
        ws->next_free_reg = 0;
    }
  
    if(need_temps > 1)
      RN(r_temp2,-1,"temp");
    if(ws->next_free_reg == 12)
      ws->next_free_reg = 0;
  }

  /* Work out how many registers we've overflowed by */
  int overflow = 0;
  if(ws->next_free_reg < 10)
    overflow = ws->next_free_reg;

  comment(ws,"Initialise some loop registers and exit if zero width row");
  ins(ws, PUSH | (1<<14),                     "STMFD   sp!,{r14}");
  if(!DEST_32_BIT)
  {
    MOV(R(r_outword),IMM(128) | IMMROR(8),    "MOV     r_outword,#&80000000");
  }
  CMP(R(r_xsize_spr_left),IMM(0),             "CMP     r_xsize_spr_left,#0");
  if(!DEST_32_BIT)
  {
    MOV(R(r_outmask),IMM(0),                  "MOV     r_outmask,#0");
  }
  ins(ws, POP | (1<<15) | LE,                 "LDMLEFD sp!,{pc}");

  ws->compiled_routine_stacked = 16;

  /* Can we set up the pixel expansion mask here, or do we need to do it for each pixel? */
  BOOL setup_expansion_each_time = 0;
  if(ws->regnames.r_expansionmask.regno != -1)
  {
    if(ws->regnames.r_expansionmask.regno >= 10)
    {
      dither_expansion_init(wp,ws);
    }
    else
    {
      setup_expansion_each_time = 1;
    }
  }

  /* Can we set up the TTR pointer here, or do we need to do it for each pixel? */
  BOOL setup_ttr_each_time = 0;
  if(!TRANSMASK && (wp->trns_palette || wp->ColourTTR))
  {
    if((ws->regnames.r_table.regno >= 10) && (ws->regnames.r_table.regno != ws->regnames.r_temp1.regno))
    {
      LDR_SP(r_table,trns_comp_spr_ttr)
    }
    else
    {
      setup_ttr_each_time = 1;
    }
  }

  comment(ws,"Get address of lefthand X of screen row");

  if(wp->Log2bpp < 3)
  {
    ADD(R(r_outptr), R(r_outptr), OP2R(R(r_out_x)) | LSRI(3-wp->Log2bpp), "ADD     r_outptr,r_outptr,r_out_x, LSR #3-out_l2bpp  ; byte pointer of screen pixel");
  }
  else
  {
    ADD(R(r_outptr), R(r_outptr), OP2R(R(r_out_x)) | LSLI(wp->Log2bpp-3), "ADD     r_out_ptr,r_outptr,r_out_x, LSL #out_l2bpp-3 ; byte pointer of screen pixel");
  }
  
  if(!DEST_32_BIT)
  {
    if(wp->Log2bpp > 0)
    {
      MOV(R(r_out_x), OP2R(R(r_out_x)) | LSLI(wp->Log2bpp),            "MOV     r_out_x,r_out_x, LSL #out_l2bpp");
    }
    BIC(R(r_outptr), R(r_outptr), IMM(3),                              "BIC     r_outptr,r_outptr,#3                         ; align pointer");
    AND(R(r_out_x), R(r_out_x), IMM((31>>wp->Log2bpp)<<wp->Log2bpp),   "AND     r_out_x,r_out_x,#(31>>out_l2bpp)<<out_l2bpp  ; bit offset in screen word");

    comment(ws,"Shift start words (pixel and mask) according to pixel offset");
    MOV(R(r_outword), OP2R(R(r_outword)) | LSRR(R(r_out_x)),           "MOV     r_outword,r_outword, LSR r_out_x"); 
  }

  /* Main loop */
  DEFINE_LABEL(loop_x_enter,          "Main loop start");

  comment(ws,"Get sprite pointers for current pixel");

  MOV(R(r_inoffset),OP2R(R(r_Y)) | ASRI(16) | S,             "MOVS    r_inoffset,r_Y,ASR #16                       ; sprite Y coord");
  MOV(R(r_temp1),OP2R(R(r_spr_height_right)) | LSRI(16),     "MOV     r_temp1,r_spr_height_right,LSR #16           ; get sprite height");
  MOV(R(r_inoffset),IMM(0) | MI,                             "MOVMI   r_inoffset,#0                                ; clamp Y to 0");
  CMP(R(r_temp1),OP2R(R(r_Y)) | ASRI(16),                    "CMP     r_temp1,r_Y,ASR #16                          ; Y beyond sprite height?");
  if(SOURCE_BPPMASK)
  {
    LDR_SP(r_pixel,trns_comp_spr_mask_width)
  }
  SUB(R(r_inoffset),R(r_temp1),IMM(1) | LE,                  "SUBLE   r_inoffset,r_temp1,#1                        ; clamp Y to sprite height");
  if(SOURCE_BPPMASK)
  {
    MUL(R(r_pixel),R(r_inoffset),R(r_pixel),0,               "MUL     r_pixel,r_inoffset,r_pixel                   ; offset of 1bpp mask row");
  }
  CMP(R(r_X),OP2R(R(r_xsize_spr_left)) | LSLI(16),           "CMP     r_X,r_xsize_spr_left,LSL #16                 ; X off left edge of sprite?");
  MOV(R(r_temp1),OP2R(R(r_X)),                               "MOV     r_temp1,r_X                                  ; sprite X coord");
  if(!TRANSMASK || !SOURCE_BPPMASK) /* Sprite offset not needed if we're only reading the 1bpp mask */
  {
    MUL(R(r_inoffset),R(r_byte_width),R(r_inoffset),0,       "MUL     r_inoffset,r_byte_width,r_inoffset           ; offset of sprite row");
  }
  MOV(R(r_temp1),OP2R(R(r_xsize_spr_left)) | LSLI(16) | LT,  "MOVLT   r_temp1,r_xsize_spr_left,LSL #16             ; clamp X to sprite left edge");
  CMP(R(r_X),OP2R(R(r_spr_height_right)) | LSLI(16),         "CMP     r_X,r_spr_height_right,LSL #16               ; X off right edge of sprite?");
  MOV(R(r_temp1),OP2R(R(r_spr_height_right)) | LSLI(16) | GE,"MOVGE   r_temp1,r_spr_height_right,LSL #16");
  SUB(R(r_temp1),R(r_temp1),IMM(1) | GE,                     "SUBGE   r_temp1,r_temp1,#1                           ; clamp X to sprite right");
  if(SOURCE_BPPMASK)
  {
    ADD(R(r_pixel),R(r_pixel),OP2R(R(r_temp1)) | LSRI(16),   "ADD     r_pixel,r_pixel,r_temp1,LSR #16              ; final mask offset");
  }
  if(!TRANSMASK || !SOURCE_BPPMASK)
  {
    ADD(R(r_inoffset),R(r_inoffset),OP2R(R(r_temp1)) | LSRI(16),"ADD     r_inoffset,r_inoffset,r_temp1,LSR #16        ; final sprite offset");
  }
  
  if(!TRANSMASK)
  {
    if(SOURCE_BPPMASK)
    {
      /* Preserve mask offset */
      STR_SP(r_pixel,trns_comp_mask_offset)
    }
    
    comment(ws,"Load sprite pixel");
    sprtrans_readpixormask(wp,ws);
    comment(ws,"r_pixel is now a source pixel");

    /* Push some registers if we've overflowed */
    if(overflow)
    {
      IFDEBUG(ldm_reg_list(ws,b,(1<<overflow)-1,0);)
      IFDEBUG(do_sprintf(a,"STMFD   sp!,{%s}",b);)
      ins(ws, PUSH | (1<<overflow)-1,  a);
      ws->compiled_routine_stacked += overflow<<2;
    }

    /* Set up any registers needed for expansion */
    if(setup_expansion_each_time)
    {
      dither_expansion_init(wp,ws);
    }
    if(setup_ttr_each_time)
    {
      LDR_SP(r_table,trns_comp_spr_ttr)
    }

    /* Translate */
    translate_pixel(wp,ws);

    /* Restore pushed registers */
    if(overflow)
    {
      IFDEBUG(do_sprintf(a,"LDMFD   sp!,{%s}",b);)
      ins(ws, POP | (1<<overflow)-1, a);
      ws->compiled_routine_stacked -= overflow<<2;
    }

    if(!DEST_32_BIT)
    {
      comment(ws,"Merge into output word");
      MOV(R(r_outword),OP2R(R(r_outword)) | LSRI(1<<wp->Log2bpp) | S,             "MOVS    r_outword,r_outword,LSR #1<<out_l2bpp");
      MOV(R(r_outmask),OP2R(R(r_outmask)) | LSRI(1<<wp->Log2bpp),                 "MOV     r_outmask,r_outmask,LSR #1<<out_l2bpp");
      ORR(R(r_outword),R(r_outword),OP2R(R(r_pixel)) | LSLI(32-(1<<wp->Log2bpp)), "ORR     r_outword,r_outword,r_pixel,LSL #32-(1<<out_l2bpp)");
    }
    else if(SOURCE_MASK)
    {
      /* Protect r_pixel being overwritten by mask read */
      MOV(R(r_outword),OP2R(R(r_pixel)),                                          "MOV     r_outword,r_pixel");
    }
    else
    {
      /* Make r_outword == r_pixel to simplify GCOL handling */
      RN(r_outword,ws->regnames.r_pixel.regno,"Output word (== r_pixel)");
    }
  }
  else if(!DEST_32_BIT)
  {
    MOV(R(r_outword),OP2R(R(r_outword)) | LSRI(1<<wp->Log2bpp) | S,               "MOVS    r_outword,r_outword,LSR #1<<out_l2bpp");
    MOV(R(r_outmask),OP2R(R(r_outmask)) | LSRI(1<<wp->Log2bpp),                   "MOV     r_outmask,r_outmask,LSR #1<<out_l2bpp");
  }

  /* If we have a mask, and GCOL action says we should use it, do so */
  if(SOURCE_MASK)
  {
    int mask_l2bpp;
    if(SOURCE_BPPMASK)
    {
      comment(ws,"Read 1bpp mask");
      if(!TRANSMASK)
      {
        /* Recover mask offset stashed earlier */
        LDR_SP(r_pixel,trns_comp_mask_offset)
      }
      LDR_SP(r_temp1,trns_comp_mask_base)
      ins(ws, LDRB(R(r_inoffset),R(r_temp1)) | INDEX_LSR(R(r_pixel),3),            "LDRB    r_inoffset,[r_temp1,r_pixel,LSR #3]");
      AND(R(r_pixel),R(r_pixel),IMM(7),                                            "AND     r_pixel,r_pixel,#7");
      MOV(R(r_pixel),OP2R(R(r_inoffset)) | LSRR(R(r_pixel)),                       "MOV     r_pixel,r_inoffset,LSR r_pixel");
      mask_l2bpp = 0;
    }
    else
    {
      comment(ws,"Read old style mask");
      LDR_SP(r_pixel,trns_comp_spr_masko) /* TODO keep resident if possible (e.g. TRANSMASK) */
      ADD(R(r_inoffset),R(r_inoffset),OP2R(R(r_pixel)),                            "ADD     r_inoffset,r_inoffset,r_pixel");
      sprtrans_readpixormask(wp,ws);
      mask_l2bpp = wp->save_inlog2bpp;
    }

    /* Merge into r_outmask */
    if(!DEST_32_BIT)
    {
      comment(ws,"Merge into output mask");
      if(mask_l2bpp == wp->Log2bpp)
      {
        ORR(R(r_outmask),R(r_outmask),OP2R(R(r_pixel)) | LSLI(32-(1<<wp->Log2bpp)), "ORR     r_outmask,r_outmask,r_pixel,LSL #32-(1<<out_l2bpp)");
      }
      else
      {
        if(SOURCE_BPPMASK)
        {
          TST(R(r_pixel),IMM(1),                                                    "TST     r_pixel,#1");
        }
        else
        {
          TEQ(R(r_pixel),IMM(0),                                                    "TEQ     r_pixel,#0");
        }
        if(wp->Log2bpp < 4)
          ORR(R(r_outmask),R(r_outmask),IMM(255 & ~(255 >> (1<<wp->Log2bpp))) | IMMROR(8) | NE, "ORRNE   r_outmask,r_outmask,#&FF000000 :AND: :NOT: (&FF000000 >> (1<<out_l2bpp))");
        else
        {
          ORR(R(r_outmask),R(r_outmask),IMM(255) | IMMROR(8) | NE,                  "ORRNE   r_outmask,r_outmask,#&FF000000");
          ORR(R(r_outmask),R(r_outmask),IMM(255) | IMMROR(16) | NE,                 "ORRNE   r_outmask,r_outmask,#&00FF0000");
        }
      }
    }
    else
    {
      /* Make r_outmask == r_pixel to simplify plot action handling */
      RN(r_outmask,ws->regnames.r_pixel.regno,"Output mask (== r_pixel)");
      if(mask_l2bpp != 5)
      {
        TEQ(R(r_pixel),IMM(0),                                                      "TEQ     r_pixel,#0");
        MVN(R(r_pixel),IMM(0) | NE,                                                 "MVNNE   r_pixel,#0");
      }
    }
  }
  else if(!DEST_32_BIT)
  {
    /* No mask, just set the relevant bits in r_outmask */
    if(wp->Log2bpp < 4)
      ORR(R(r_outmask),R(r_outmask),IMM(255 & ~(255 >> (1<<wp->Log2bpp))) | IMMROR(8), "ORR     r_outmask,r_outmask,#&FF000000 :AND: :NOT: (&FF000000 >> (1<<out_l2bpp))");
    else
    {
      ORR(R(r_outmask),R(r_outmask),IMM(255) | IMMROR(8),                         "ORR     r_outmask,r_outmask,#&FF000000");
      ORR(R(r_outmask),R(r_outmask),IMM(255) | IMMROR(16),                        "ORR     r_outmask,r_outmask,#&00FF0000");
    }
  }

  /* Skip plot action if not at end of word */
  if(!DEST_32_BIT)
  {
    branch(ws, B | CC, L(loop_x_exit), "BCC     loop_x_exit");
  }

  sprtrans_plotaction(wp,ws);

  comment(ws,"Store screen pixel");          
  ins(ws, STR(R(r_outword),R(r_outptr)) | POSTINC(4),         "STR     r_outword,[r_outptr],#4");
  if(!DEST_32_BIT)
  {
    MOV(R(r_outword),IMM(128) | IMMROR(8),                    "MOV     r_outword,#&80000000");
  }

  DEFINE_LABEL(loop_x_exit,"Main loop end");
  comment(ws,"Move to next pixel");
  SUB(R(r_xsize_spr_left),R(r_xsize_spr_left),IMM(1) | IMMROR(16),  "SUB     r_xsize_spr_left,r_xsize_spr_left,#&10000");
  ADD(R(r_X),R(r_X),OP2R(R(r_inc_X_x)),                             "ADD     r_X,r_X,r_inc_X_x");
  CMP(R(r_xsize_spr_left),IMM(1) | IMMROR(16),                      "CMP     r_xsize_spr_left,#&10000");
  ADD(R(r_Y),R(r_Y),OP2R(R(r_inc_Y_x)),                             "ADD     r_Y,r_Y,r_inc_Y_y");
  branch(ws, B | GE, L(loop_x_enter),                               "BGE     loop_x_enter");

  comment(ws,"Finished row");
  if(!DEST_32_BIT)
  {
    CMP(R(r_outword),IMM(128)|IMMROR(8),                            "CMP     r_outword,#&80000000");
    ins(ws, POP | (1<<15) | EQ,                                     "LDMEQFD sp!,{pc}");
    /* Loop until we have a full word of data */
    DEFINE_LABEL(x_misaligned,"Misaligned end word loop");
    MOV(R(r_outword),OP2R(R(r_outword)) | LSRI(1<<wp->Log2bpp) | S, "MOVS    r_outword,r_outword,LSR #1<<out_l2bpp ; (2)");
    MOV(R(r_outmask),OP2R(R(r_outmask)) | LSRI(1<<wp->Log2bpp),     "MOV     r_outmask,r_outmask,LSR #1<<out_l2bpp ; (2)");
    branch(ws, B | CC, L(x_misaligned),                             "BCC     x_misaligned");
    /* Perform plot action */
    sprtrans_plotaction(wp,ws);
    comment(ws,"Store last word");
    ins(ws, STR(R(r_outword),R(r_outptr)),                          "STR     r_outword,[r_outptr]");
  }
  ins(ws, POP | (1<<15),                                            "LDM     sp!,{pc}");
}

/**************************************************************************
*                                                                         *
*    The main compiler entry points.                                      *
*                                                                         *
**************************************************************************/

static blitter sprtrans_find_or_compile_code(asm_workspace *wp, workspace *ws)
{
  code_buffer *p;
  int key_word;

  key_word = get_key_word(wp,ws);

  tracef("Searching for compiled code for key_word=%x\n" _
    key_word);
  FOR_EACH_BUFFER(p)
    if (  p->key_word == key_word
       )
     {
       tracef("Found existing compiled code in buffer %x.\n" _ p);

       return (blitter)p->code;
     }
  p = &ws->buffers[ws->build_buffer];
  p->key_word = -1; /* Not set unless we complete the compilation - see below */
  tracef("Compiler initialised for buffer at %x.\n" _ p);
  compile_buffer_init(wp, ws);

  /* Now we actually do the compile */
  sprtrans_loop_x(wp, ws);

  compile_buffer_done(ws);
  p->key_word = key_word;

  /* Just did some dynamic code generation so flush the I cache */
  _swix(OS_SynchroniseCodeAreas, _IN(0) | _IN(1) | _IN(2), 1,
        (int)ws->compile_base, (int)ws->compile_base + ((BUFSIZE - 1 /* Inclusive */) * sizeof(int)));

  return (blitter)ws->compile_base;
}

blitter sprtrans_compiler(asm_workspace *wp, workspace *ws, workspace *ws_end, int gcol)
/* Main entrypoint from the assembler */
{
  blitter             result;
  int                 i,j;

  tracef("wp=%x ws=%x ws_end=%x.\n" _ wp _ ws _ ws_end);
  tracef("Size of assembler workspace: %i.\n" _ ((char*)ws) - ((char*)wp));
  tracef("Size of C workspace: %i.\n" _ ((char*)ws_end) - ((char*)ws));
  assert(ws_end > ws, ERROR_FATAL);
  check_workspace(ws);
  IFDEBUG(dump_asm_workspace(wp);)

  ws->gcol = gcol & 7;
  ws->masked = (gcol & 8) != 0;
  ws->mask1bpp = ws->masked & (((wp->save_mode) >> 27) != SpriteType_Old);
  ws->odither = FALSE;  
  tracef("gcol=%i (& 7 = %i)       %t32. GCOL action - 0 for plot, 1..7 for various others.\n" _ gcol _ gcol & 7);
  tracef("masked=%s                %t32. whether to use mask.\n" _ whether(ws->masked));
  tracef("1bpp mask=%s             %t32. whether mask is new format.\n" _ whether(ws->mask1bpp));

  /* JPEG not supported yet */
  assert(!wp->is_it_jpeg, ERROR_FATAL);

  ws->out_pixelformat = compute_pixelformat(wp->ncolour,wp->modeflags,wp->Log2bpp);
  
  {
    /* Pull apart the sprite mode word to deduce our pixel format value */
    int in_modeflags,in_ncolour;
    _swix(OS_ReadModeVariable,_INR(0,1)|_OUT(2),wp->save_mode,VduExt_ModeFlags,&in_modeflags);
    _swix(OS_ReadModeVariable,_INR(0,1)|_OUT(2),wp->save_mode,VduExt_NColour,&in_ncolour);
    ws->in_pixelformat = compute_pixelformat(in_ncolour,in_modeflags,wp->save_inlog2bpp);
  }

  /* Fudge - if input data >=32bpp (including JPEG), assume ColourTTR index values are 15bpp
     Else assume ColourTTR index values are same as source pixels, minus alpha
     Really the assembler code should tell us what format it is */
  if(wp->ColourTTR != 0)
  {
    if(wp->save_inlog2bpp >= 5)
      ws->ColourTTRFormat = PixelFormat_15bpp;
    else
      ws->ColourTTRFormat = ws->in_pixelformat & ~PixelFormat_Alpha;
  }

  ws->pixel_expansion_mask = ws->pixel_expansion_shift = 0;
  ws->pixel_expansion_in = ws->pixel_expansion_out = NULL;

  /* Calibration tables not supported */
  assert(!wp->cal_table, ERROR_FATAL);

  /* If using a palette, ignore any translation table */
  if (wp->trns_palette != 0) wp->ColourTTR = 0;

  /* Precise handling of double-pixel modes by the surrounding code is still unclear to me!
   * When it enters this code bpc!=bpp can still be the case, but it seems that the actual
   * value of bpc is best ignored, it has all been frigged into the scale factors. Avoid
   * this issue for now, but note that we must set the values back afterwards because they
   * can be reused on the next sprite plot, if the source sprite mode word is the same.
   */
  i = wp->BPC;
  j = wp->save_inlog2bpc;
  wp->BPC = wp->BPP;
  wp->save_inlog2bpc = wp->save_inlog2bpp;
  result = sprtrans_find_or_compile_code(wp, ws);
  wp->BPC = i;
  wp->save_inlog2bpc = j;

  return result;
}
#endif

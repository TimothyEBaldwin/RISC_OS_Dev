/*
 * Copyright (c) 2015, RISC OS Open Ltd
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/* romemmgr.c - Memory management for JPEG for use within RISC OS */

#include <stdlib.h>
#include <stdint.h>
#include "swis.h"

/**************************************************************************
*                                                                         *
*    JPEG memory functions.                                               *
*                                                                         *
**************************************************************************/

METHODDEF(void *) /* Small byte arrays */
alloc_small(j_common_ptr cinfo, int pool_id, size_t sizeofobject)
{
  j_decompress_ptr dinfo = (j_decompress_ptr)cinfo;
  struct jpeg_memory_mgr *mem = cinfo->mem;
  size_t free;
  void  *where;

  sizeofobject = (sizeofobject + 3) & ~3; /* Keep it all word aligned */
  free = dinfo->workspace_size - sizeof(struct jpeg_decompress_struct) - mem->high_watermark;
  if (free < sizeofobject)
  {
    size_t areasize;

    /* No room, try resizing it.
     * This makes the (valid) assumption that resizing a dynamic area
     * doesn't change its base address.
     */
    areasize = area_resize(dinfo->workspace_size + sizeofobject + 8192 /* Slop */);
    if (areasize == 0) ERREXIT(cinfo, JERR_OUT_OF_MEMORY); /* Give up */
    dinfo->workspace_size = areasize;
  }
  
  /* Grab from our simple allocate only heap */
  where = (void *)((uintptr_t)mem->small_pool + mem->high_watermark);
  mem->high_watermark += sizeofobject;
  UNUSED(pool_id);
  
  return where;
}

METHODDEF(void FAR *) /* Large byte arrays */
alloc_large(j_common_ptr cinfo, int pool_id, size_t sizeofobject)
{
  /* There's no distinction here, FAR pointers are a DOS concept */
  return alloc_small(cinfo, pool_id, sizeofobject);
}

METHODDEF(JSAMPARRAY) /* 2D sample arrays */
alloc_sarray(j_common_ptr cinfo, int pool_id,
             JDIMENSION samplesperrow, JDIMENSION numrows)
{
  JSAMPARRAY result;
  JSAMPROW workspace;
  JDIMENSION rowsperchunk, currow, i;
  long ltemp;

  /* Flat memory world, no chunk considerations */
  rowsperchunk = numrows;

  /* Get space for row pointers (small object) */
  result = (JSAMPARRAY)alloc_small(cinfo, pool_id, (size_t) (numrows * SIZEOF(JSAMPROW)));

  /* Get the rows themselves (large objects) */
  currow = 0;
  while (currow < numrows)
  {
    rowsperchunk = MIN(rowsperchunk, numrows - currow);
    workspace = (JSAMPROW)alloc_large(cinfo, pool_id, (size_t) ((size_t) rowsperchunk * (size_t) samplesperrow * SIZEOF(JSAMPLE)));
    for (i = rowsperchunk; i > 0; i--)
    {
      result[currow++] = workspace;
      workspace += samplesperrow;
    }
  }

  return result;
}

METHODDEF(JSAMPARRAY) /* 2D block coefficient arrays */
alloc_barray(j_common_ptr cinfo, int pool_id,
             JDIMENSION samplesperrow, JDIMENSION numrows)
{
  ERREXIT(cinfo, JERR_NOTIMPL);
  return NULL;
}

METHODDEF(void) /* Free an allocation */
free_pool(j_common_ptr cinfo, int pool_id)
{
  /* Should never be called, if it is then that's an error */
  ERREXIT(cinfo, JERR_NOTIMPL);
  UNUSED(cinfo);
  UNUSED(pool_id);
}

METHODDEF(void) /* End the session */
self_destruct(j_common_ptr cinfo)
{
  j_decompress_ptr dinfo = (j_decompress_ptr)cinfo;
  size_t areasize;

  /* Shrink the dynamic area back down to just contain the state struct.
   * This makes the (valid) assumption that resizing a dynamic area
   * doesn't change its base address.
   */
  areasize = area_resize(sizeof(struct jpeg_decompress_struct));
  dinfo->workspace_size = areasize;

  /* The memory management struct is at the end of the small pool too, so
   * doesn't need freeing, just shut up shop.
   */
  cinfo->mem = NULL;
}

GLOBAL(void) /* Start the session */
jinit_memory_mgr(j_common_ptr cinfo)
{
  j_decompress_ptr dinfo = (j_decompress_ptr)cinfo;

  /* Allocate memory management struct from itself */
  cinfo->mem = (struct jpeg_memory_mgr *)dinfo->small_pool;
  cinfo->mem->small_pool = (int *)((uintptr_t)cinfo->mem + sizeof(struct jpeg_memory_mgr));
  cinfo->mem->high_watermark = sizeof(struct jpeg_memory_mgr);

  /* Method pointers */
  cinfo->mem->alloc_small = (void *(*)(j_common_ptr, int, size_t))RELOCCODE(alloc_small);
  cinfo->mem->alloc_large = (void FAR *(*)(j_common_ptr, int, size_t))RELOCCODE(alloc_small);
  cinfo->mem->alloc_sarray = (JSAMPARRAY (*)(j_common_ptr, int, JDIMENSION, JDIMENSION))RELOCCODE(alloc_sarray);
  cinfo->mem->alloc_barray = (JBLOCKARRAY (*)(j_common_ptr, int, JDIMENSION, JDIMENSION))RELOCCODE(alloc_barray);
  cinfo->mem->free_pool = (void (*)(j_common_ptr, int))RELOCCODE(free_pool);
  cinfo->mem->self_destruct = (void (*)(j_common_ptr))RELOCCODE(self_destruct);
}

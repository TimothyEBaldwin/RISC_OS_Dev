/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* c.PutScaled - the bitblit compiler for PutSpriteScaled/PlotMaskScaled */

/**************************************************************************
*                                                                         *
*    Test main entry sequence, low level IO and code generation.          *
*                                                                         *
**************************************************************************/

#ifdef TESTDEBUG
blitter putscaled_compiler(asm_workspace *wp, workspace *ws, workspace *ws_end, int gcol)
{
  /* Test low-level output */
  writes(0, "Hello there!\nhi!\n");
  writech(0, 'X');
  writehex(0, 0x5732abcd, 8);
  writech(0, '_');
  tracef("Test tracef, esc:%%, string:'%s', char:'%c', int:'%i', hex:'%x'.\n",
    "hello", 'X', 1234567, 0x6789abcd);

  /* Check that the assembler has an adequate opinion of our workspace needs. */
  tracef("wp=%x ws=%x ws_end=%x.\n" _ wp _ ws _ ws_end);
  tracef("Size of assembler workspace: %i.\n" _ ((char*)ws) - ((char*)wp));
  tracef("Size of C workspace: %i.\n" _ ((char*)ws_end) - ((char*)ws));
  assert(ws_end > ws, ERROR_NO_MEMORY);
  check_workspace(ws);
  dump_workspace(ws);

  compile_buffer_init(wp, ws);

  /* Check compilation of all instruction forms. The resulting trace output can then
   * have its binary details stripped, be run through objasm, and the resulting listings
   * compared to check the bit patterns generated.
   */
  ADD(5, 6, GT | OP2R(7),                             "ADDGT   r5,r6,r7");
  branch(ws, B, L(loop_y_exit),                       "B       loop_y_exit");
  ORR(2, 3, S | IMM(23),                              "ORRS    r2,r3,#23");
  DEFINE_LABEL(test1, "test label")
  EOR(1, 2, EQ | IMM(255) | IMMROR(10),               "EOREQ   r1,r2,#(255:ROR:10)");
  comment(ws, "This is a comment");
  DEFINE_LABEL(test2, "test label")
  branch(ws, B + NE, L(loop_y_repeat),                "BNE     loop_y_repeat");
  branch(ws, BL + EQ, L(loop_y_repeat),               "BLEQ    loop_y_repeat");
  CMP(8, OP2R(9) | LSLI(12),                          "CMP     r8,r9,LSL #12");
  CMP(8, OP2R(9) | ASRR(6),                           "CMP     r8,r9,ASR r6");
  MOV(3, OP2R(4) | RORI(1),                           "MOV     r3,r4,ROR #1");
  MOV(R(pc)), OP2R(R(lr)),                            "MOV     pc,lr");

  ins(ws, LDR(8,3) | OFFSET(249),                     "LDR     r8,[r3,#249]");
  ins(ws, LDR(8,3) | OFFSET(0),                       "LDR     r8,[r3]");
  ins(ws, STR(1,2) | GT + NEGOFFSET(12),              "STRGT   r1,[r2,#-12]");
  ins(ws, LDRB(1,2) | PREINC(4),                      "LDRB    r1,[r2,#4]!");
  ins(ws, STRB(6,7) | POSTINC(4),                     "STRB    r6,[r7],#4");
  ins(ws, LDRB(1,2) | PREDEC(4),                      "LDRB    r1,[r2,#-4]!");
  ins(ws, STRB(6,7) | POSTDEC(4),                     "STRB    r6,[r7],#-4");
  ins(ws, LDRB(8,3) | INDEX(4,0),                     "LDRB    r8,[r3,r4]");
  ins(ws, LDR(8,3) | INDEX(4,2),                      "LDR     r8,[r3,r4,LSL #2]");

  ins(ws, PUSH | GT | (1<<4) | (1<<5) | (1<<6),       "STMGTDB sp!,{r4,r5,r6}");
  ins(ws, POP | (1<<4) | (1<<5) | (1<<6),             "LDMIA   sp!,{r4,r5,r6}");
  ins(ws, POP | (1<<4) | (1<<5) | (1<<6) | (1<<R(pc)),"LDMIA   sp!,{r4,r5,r6,pc}");

  {
    char a[256];
    char a2[256];
    int regmask = (1<<13) | (1<<15); /* pretty arbitrary silly one actually */

    ldm_reg_list(ws, a, regmask, FALSE);
    do_sprintf(a2, "LDMIA   lr,{%s}", a)
    ins(ws, LDMIA(lr) | regmask, a2);
    do_sprintf(a2, "STMIA   l4,{%s}", a)
    ins(ws, STMIA(lr) | regmask, a2);
  }

  branch(ws, BL + EQ, &ws->labels.loop_y_repeat,                        "BLEQ    loop_y_repeat");

  compile_buffer_done(ws);

  writes(0, "Exit.\n");
}
#else

/**************************************************************************
*                                                                         *
*    Bitblit: Evaluate conditions.                                        *
*                                                                         *
**************************************************************************/

static BOOL simple_x_scale(asm_workspace *wp, workspace *ws)
/* Return true if 1:1 along x */
{
  return (  wp->save_xadd - wp->save_xdiv == wp->save_xdiv
         && wp->save_xdiv <= wp->save_xcount
         && !PLOTMASK
         && ws->gcol == 0
         && !ws->odither /* CAN be done, but the code sequences get awfully big so let's cut it out for now. */
         ? TRUE : FALSE);
  /* Without the second test we MIGHT have to omit the first pixel, which the 1:1 code doesn't allow for. */
  /* The 2-at-a-time loop doesn't allow for PLOTMASK - not important enough. */
  /* The 2-at-a-time loop doesn't allow for any gcol but 0 - not important enough. */
}

static BOOL x_block_move(asm_workspace *wp, workspace *ws)
/* Returns true if the inner loop is the simple movement of a block of bits */
{
  return (  simple_x_scale(wp, ws)
         && wp->BPC == (1<<wp->save_inlog2bpc)
         && ws->gcol == 0
         && !SOURCE_MASK
         && !SOURCE_TABLE
         && wp->cal_table == 0
         && ws->in_pixelformat == ws->out_pixelformat
         ? TRUE : FALSE);
}

static BOOL simple_y_scale(asm_workspace *wp, workspace *ws)
/* Return true if 1:1 along y */
{
  UNUSED(ws);
  return wp->save_yadd == wp->save_ydiv;
}

static int palette_is_grey(int *palette, int entries)
/* Scan a palette looking how they increment to deduce if it's just greyscale */
{
  int loop;
  int entry;
  int ascending = 1;

  for (loop=0;loop<entries;loop++)
  {
    entry = palette[loop];

    if (((entry ^ (entry>>8)) & 0xffff00) != 0)
      return 0;
    if ((entry & 0xff00)>>8 != loop)
      ascending = 0;
  }
  if (ascending)
   return 2;
  return 1;
}

/**************************************************************************
*                                                                         *
*    Bitblit: Register allocation.                                        *
*                                                                         *
**************************************************************************/

static void ptrs_rn(asm_workspace *wp, workspace *ws)
/* Declare the pointer registers, which must be visible in both the x-loop and the y-loop */
{
  /* r_pixel is always needed, and need not be saved between loops.
   * So, we put it in r14 to remove the need for the register allocator
   * to worry about r14.
   */
  RN(r_pixel, 14, "fetched and translated pixel")

  /* In most cases there are not enough registers, and the control of
   * the outer (y) loop requires swapping two 'banks' of registers.
   * inptr, outptr (and maskinptr if it exists) are always registers
   * r0, r1, r2, and they are visible when the y registers are swapped in.
   */
  RN(r_inptr, -1, PLOTMASK ? "ECF pattern pointer" : "input word pointer")
  RN(r_outptr, -1, "word pointer to output")
  if (SOURCE_BPPMASK || PLOTMASK) RN(r_maskinptr, -1, "mask input word pointer")

  if (ws->odither) RN(r_oditheradd, -1, "ordered dither offset value")
  /* The initial dither add value needs to be changed for every output line,
   * so it helps to have r_oditheradd visible in the y loop
   */
}

static void xloop_rn(asm_workspace *wp, workspace *ws)
/* Other variables for the x-loop */
{
  int need_temps = 0; /* set to 1 or 2 if temp1 and temp2 are needed */
  if (x_block_move(wp, ws))
  {
    /* X loop is very very simple, and communicates with machine-code block-shift routine. */
    RN(r_inshift, -1, "Number of (most sig) bits of first input word to transfer, in 1..32")
    RN(r_outshift, -1, "Number of (most sig) bits of first output word to fill, in 1..32")
    RN(r_xsize, -1, "Number of bits to transfer per row")
    RN(r_blockroutine, -1, "Block transfer routine")
    /* Those registers had better be the same ones as the assembler code is expecting! */
    assert(ws->regnames.r_inptr.regno == 0, ERROR_FATAL);
    assert(ws->regnames.r_outptr.regno == 1, ERROR_FATAL);
    assert(ws->regnames.r_inshift.regno == 2, ERROR_FATAL);
    assert(ws->regnames.r_outshift.regno == 3, ERROR_FATAL);
    assert(ws->regnames.r_xsize.regno == 4, ERROR_FATAL);
  }
  else
  {
    /* Normal case - declare whatever other registers are needed for fetching and translating pixels. */
    if (PLOTMASK)
      RN(r_inword, -1, "ECF pattern input word")
    else if (!SOURCE_32_BIT) /* if not 32-bit source */
    {
      RN(r_inshift, -1, "bit shift of current pixel LSL #27")
      RN(r_inword, -1, "current input word")
    }
    if (SOURCE_MASK)
    {
      RN(r_maskinword, -1, "current mask word")
      if (SOURCE_BPPMASK || PLOTMASK)
        RN(r_maskinshift, -1, "bit shift of current mask pixel")
      else
        RN(r_masko, -1, "offset of mask data from sprite data")
    }
    if (  need_temps == 0
       && (ws->gcol != 0)
       && DEST_32_BIT       /* use in save_pixel */
       )
       need_temps = 1;

    if (PLOTMASK)
    {
      RN(r_ecfindex, -1, "index into ECF pattern")
      RN(r_bgcolour, -1, "background plotting colour")
    }
    else
    {
      if (SOURCE_TABLE || wp->cal_table) RN(r_table, -1, "translation table or palette")

      need_temps = translate_pixel_rn(wp,ws,need_temps);

      if ( need_temps == 0
        && (wp->save_xmag % wp->save_xdiv) == 0
        && (wp->save_xmag / wp->save_xdiv) > 4    /* used in optimised scale up */
         )
       need_temps = 1;
    }

    /* Declare whatever registers needed for saving the new pixel
     * into the current destination pixel.
     */
    if (!DEST_32_BIT)
    {
      RN(r_outword, -1, "current output word")
      RN(r_outshift, -1, "bit shift of current pixel in current output word LSL 27")
    }

    if (wp->save_inlog2bpp <= 3 && simple_x_scale(wp, ws))
      /* going to use 2-at-a-time loop - if 16bpp or more, don't need this register. */
      RN(r_in_pixmask, -1, "pixel mask for 2-at-a-time loop")

    /* Declare whatever registers are needed for control of
     * horizontal scaling. For some simple cases no scaling registers
     * are needed.
     */
    RN(r_xsize, -1, "number of output pixels per row")
    if (!simple_x_scale(wp, ws)) /* not 1:1 scale */
      RN(r_xcount, -1, "total for x scale")
      /* Adder and subractor values become constants in the code. */
  }

  /* The temporaries are shuffled to the end, so that if r12 (the assembler wp) is used then
   * it does not get loaded before the y loop variables are initialised.
   */
  if (need_temps >= 1) RN(r_temp1, -1, "temp1 for pixel transformation temporary values")
  if (need_temps >= 2) RN(r_temp2, -1, "temp2 for pixel transformation temporary values")

  /* MAX POSSIBLE REQUIREMENT - 13, if vcount stuff not done.
   * It may appear 15, but temp1 and temp2 are only needed if one of src/dst
   * is 32bpp, in which case we save elsewhere.
   * >>> AH not so, they are also needed if a palette is used, in which case
   * the source can be fewer bpp. Ooops. Can we ever overflow? Not sure.
   */
}

static int yloop_rn_count(asm_workspace *wp, workspace *ws)
/* Say how many registers yloop_rn will declare */
{
  int result = 2;                                        /* r_ysize, r_inoffset */
  if (wp->save_yadd != wp->save_ydiv) result++;          /* r_ycount */
  if (SOURCE_BPPMASK || PLOTMASK) result++;              /* r_maskinoffset */
  if (wp->is_it_jpeg) result++;                          /* r_fetchroutine */
  return result;
}

static void yloop_rn(asm_workspace *wp, workspace *ws)
/* Declare whatever registers are needed for control of
 * the vertical loop. These registers are part of a separate 'bank'
 * from those in the central loop.
 */
{
  RN(r_ysize, -1, "number of output rows");
  if (!simple_y_scale(wp, ws)) /* not 1:1 scale */
    RN(r_ycount, -1, "total for y scale")

  /* Adder and subractor values become constants in the code. */
  RN(r_inoffset, -1, "byte offset between input rows.")
  if (SOURCE_BPPMASK || PLOTMASK) RN(r_maskinoffset, -1, "byte offset between mask rows.")
  if (wp->is_it_jpeg)             RN(r_fetchroutine, -1, "routine for getting row of decompressed JPEG data.")

  /* MAX POSSIBLE REQUIREMENT - 5 registers */
}

/**************************************************************************
*                                                                         *
*    Bitblit: Register initialisation.                                    *
*                                                                         *
**************************************************************************/

static void get_in_shift(asm_workspace *wp, workspace *ws)
/* Used within fetch_pixel_init, to load r_inshift. The complication is
 * that if this is JPEG data then the save_inshift value was not calculated,
 * because SpriteExtend assembler stuff thought this was 32bit data. This
 * only matters if JPEG is being made to produce 8bpp or 16bpp data.
 */
{
  if (wp->is_it_jpeg && wp->save_inlog2bpp != 5)
  {
    LDR_WP_C(r_inshift, in_x, "input x coord (JPEG input data)")
    if (wp->save_inlog2bpp == 4)
    {
      AND(R(r_inshift), R(r_inshift), S | IMM(1),              "ANDS    r_inshift,r_inshift,#1          ; halfword offset (0 or 1)");
      MOV(R(r_inshift), EQ | IMM(2),                           "MOVEQ   r_inshift,#2                    ; halfword offset (1 or 2)");
      MOV(R(r_inshift), OP2R(R(r_inshift)) | LSLI(4),          "MOV     r_inshift,r_inshift,LSL #4      ; 16/32 bit offset");
    }
    else /* wp->save_inlog2bpp == 3 */
    {
      AND(R(r_inshift), R(r_inshift), S | IMM(3),              "ANDS    r_inshift,r_inshift,#3          ; byte offset as 0/1/2/3");
      RSB(R(r_inshift), R(r_inshift), IMM(4),                  "RSB     r_inshift,r_inshift,#4          ; byte offset as 4/3/2/1");
      MOV(R(r_inshift), OP2R(R(r_inshift)) | LSLI(3),          "MOV     r_inshift,r_inshift,LSL #3      ; 8/16/24/32 bit offset");
    }
  }
  else
  {
    LDR_WP_C(r_inshift, save_inshift, "input initial shift")
    RSB(R(r_inshift), R(r_inshift), IMM(32),                 "RSB     r_inshift,r_inshift,#32         ; pixels of first word to transfer, in 1..32");
  }
}

static void fetch_pixel_init(asm_workspace *wp, workspace *ws)
/* Initialise whatever registers are needed for fetching and translating
 * pixels.
 */
{
  /* The input word pointer */
  if (PLOTMASK)
  {
    LDR_WP_C(r_inptr, save_ecflimit, "base of ECF pattern")
  }
  else if (wp->is_it_jpeg)
  {
    LDR_WP_C(r_inptr, in_y, "initial y coordinate (for JPEG data)")
  }
  else /* normal data source for PutSpriteScaled */
  {
    LDR_WP_C(r_inptr, save_inptr, "input word pointer")
  }

  /* all other registers re fetching input data */
  if (x_block_move(wp, ws))
  {
    /* Prepare for machine code core to inner loop */
    get_in_shift(wp, ws);
    LDR_WP(r_blockroutine, ccompiler_bitblockmove)
  }
  else
  {
    /* initialise r_inptr */
    if (PLOTMASK)
    {
      LDR_WP(r_ecfindex, save_ecfptr) /* byte index into ECF pattern, not rounded */
      AND(R(r_pixel), R(r_ecfindex), IMM(0x18),              "AND     r_pixel,r_ecfindex,#&18         ; extract initial row offset in ECF");
      ADD(R(r_inptr), R(r_inptr), OP2R(R(r_pixel)),          "ADD     r_inptr,r_inptr,r_pixel         ; and add to initial ECF row address");
    }
    else
    {
      /* r_inword and r_inshift */
      if (!SOURCE_32_BIT) /* if not 32-bit source */
      {
        /* r_inword not initialised yet, done in inner loop */
        get_in_shift(wp, ws);
        MOV(R(r_inshift), OP2R(R(r_inshift)) | LSLI(27),     "MOV     r_inshift,r_inshift,LSL #27     ; keep up at top end of register");
      }
    }

    /* mask registers */
    if (SOURCE_MASK)
    {
      if (SOURCE_BPPMASK || PLOTMASK)
      {
        LDR_WP(r_maskinshift, save_maskinshift)
        if (SOURCE_BPPMASK)
        {
          LDR_WP(r_maskinptr, save_maskinptr)
        }
        else /* PLOTMASK and not BPPMASK */
        {
          LDR_WP_C(r_maskinptr, save_inptr, "mask pointer for PlotMaskScaled")
          LDR_WP(r_pixel, save_masko) /* temp use of r_pixel */
          ADD(R(r_maskinptr), R(r_maskinptr), OP2R(R(r_pixel)),"ADD     r_maskinptr,r_maskinptr,r_pixel ; mask pointer (for PlotMask)");
        }
        RSB(R(r_maskinshift), R(r_maskinshift), IMM(32),   "RSB     r_maskinshift,r_maskinshift,#32 ; pixels still to shift");
        MOV(R(r_maskinshift),
            OP2R(R(r_maskinshift)) | LSLI(27),             "MOV     r_maskinshift,r_maskinshift,LSL #27 ; keep up at top end of register");
      }
      else
        LDR_WP(r_masko, save_masko)
    }

    /* translation registers */
    if (wp->cal_table) LDR_WP(r_table, cal_table)
    else if (wp->trns_palette != 0) LDR_WP(r_table, trns_palette)
    else
    {
      if (wp->ColourTTR != 0)
      {
        LDR_WP(r_table, ColourTTR)
        if (  wp->BPP <= 8                  /* 256 colours or less on output */
           && wp->save_inlog2bpp >= 4       /* thousands or millions of input colours */
           )
        {
          ins(ws, LDR(R(r_table), R(r_table)) | OFFSET(4), "LDR     r_table,[r_table,#4]            ; load base of 32K table");
        }
      }
    }

    if (wp->save_inlog2bpp <= 3 && simple_x_scale(wp, ws))
      MOV(R(r_in_pixmask), IMM(ws->in_pixmask),           "MOV     r_in_pixmask,#in_pixmask        ; for use in 2-at-a-time loop");

    /* temp1 and temp2 need no initialisation. */

    dither_expansion_init(wp,ws);
  }
    
  newline();
}

static void save_pixel_init(asm_workspace *wp, workspace *ws)
/* Initialise whatever registers are needed for saving the new pixel
 * into the current destination pixel.
 */
{
  LDR_WP(r_outptr, save_outptr)

  if (x_block_move(wp, ws))
  {
    /* Very simple inner loop */
    LDR_WP_C(r_pixel, save_xcoord, "get initial output x coord in pixels") /* Measured in pixels */
    AND(R(r_outshift), R(r_pixel), IMM(ws->out_ppw-1),            "AND     r_outshift,r_pixel,#out_ppw-1   ; pix offset of start");
    MOV(R(r_outshift),OP2R(R(r_outshift)) | LSLI(wp->Log2bpc),  "MOV     r_outshift,r_outshift,LSL #out_l2bpc ; bit offset of start, in 0..31");
    RSB(R(r_outshift), R(r_outshift), IMM(32),                    "RSB     r_outshift,r_outshift,#32       ; pixels of space, in 1..32");
  }
  else
  {
    /* Normal cases */
    if (PLOTMASK || !DEST_32_BIT)
      LDR_WP_C(r_pixel, save_xcoord, "output x coord measured in pixels")

    if (PLOTMASK)
    {
      MOV(R(r_ecfindex), OP2R(IMM(0)),                          "MOV     r_ecfindex, #0               ; should always be 0 ?");
    }

    if (!DEST_32_BIT)
    {
      AND(R(r_outshift), R(r_pixel), IMM(ws->out_ppw-1),          "AND     r_outshift,r_pixel,#out_ppw-1 ; pixel offset of start");
      MOV(R(r_outshift),OP2R(R(r_outshift)) | LSLI(wp->Log2bpc),"MOV     r_outshift,r_outshift,LSL #out_l2bpc ; bit offset of start");
      RSB(R(r_outshift), R(r_outshift), IMM(32),                  "RSB     r_outshift,r_outshift,#32       ; pixels still to rotate");
      MOV(R(r_outshift), OP2R(R(r_outshift)) | LSLI(27),          "MOV     r_outshift,r_outshift,LSL #27   ; up at the top");
    }
  }
}

static void xloop_init(asm_workspace *wp, workspace *ws)
/* Initialise whatever registers are needed for control of
 * horizontal scaling. For some simple cases no scaling registers
 * are needed.
 */
{
  LDR_WP(r_xsize, save_xsize)
  if (!simple_x_scale(wp, ws)) /* not 1:1 scale */
  {
    if ((ws->odither) && (SOURCE_16_BIT))
    {
      LDR_WP(r_pixel, save_xcount); /* Changed by (GPS) to fix register spill bug*/
    }
    else
    {
      LDR_WP(r_xcount, save_xcount);
    }
  }
  if (x_block_move(wp, ws))
    MOV(R(r_xsize), OP2R(R(r_xsize)) | LSLI(wp->Log2bpc),       "MOV     r_xsize,r_xsize,LSL #out_l2bpc  ; size in bits");
}

static void yloop_init(asm_workspace *wp, workspace *ws)
/* Initialise whatever registers are needed for control of
 * the vertical loop. These registers are part of a separate 'bank'
 * from those in the central loop.
 */
{
  if (wp->is_it_jpeg) LDR_WP_C(r_fetchroutine, fetchroutine, "routine to call to get JPEG data line")
  LDR_WP(r_ysize, save_ysize)
  if (!simple_y_scale(wp, ws)) /* not 1:1 scale */ LDR_WP(r_ycount, save_ycount)
  if (!PLOTMASK)
  {
    if (wp->is_it_jpeg)
      /* We could save this register, but there's not all that much point - simpler to code like this. */
      MOV(R(r_inoffset),IMM(1),                                   "MOV     r_inoffset,#1                   ; JPEG coord offset on input");
    else
      LDR_WP(r_inoffset, save_inoffset)
  }
  if (SOURCE_BPPMASK) LDR_WP(r_maskinoffset, save_maskinoffset)
  else if (PLOTMASK) LDR_WP(r_maskinoffset, save_inoffset)
}

/**************************************************************************
*                                                                         *
*    Bitblit: Pixel loading, translation, saving.                         *
*                                                                         *
**************************************************************************/
static void fetch_pixel_unmasked(asm_workspace *wp, workspace *ws)
/* Assuming no mask, get the next input pixel and put it in r_pixel. This is separated
 * from fetch_pixel for the case of scaling up an ordered dither, where the same input
 * pixel is repeatedly fetched and translated.
 */
{
  if (PLOTMASK)
  {
    comment(ws, "Fetch an ECF pixel");
    if (DEST_32_BIT)
    {
      ins(ws, LDR(R(r_inword), R(r_inptr))
             | INDEX(R(r_ecfindex), 0),                      "LDR     r_inword,[r_inptr,r_ecfindex] 2222");
      ADD(R(r_ecfindex), R(r_ecfindex),
            IMM(4),                                          "ADD     r_ecfindex,r_ecfindex,#4  5t453");
      ins(ws, LDR(R(r_bgcolour), R(r_inptr))
            | INDEX(R(r_ecfindex), 0),                       "LDR     r_bgcolour,[r_inptr,r_ecfindex]   ; load next EOR word of ECF222");
      SUB(R(r_ecfindex), R(r_ecfindex),
            IMM(4),                                          "SUB     r_ecfindex,r_ecfindex,#4 1212");
    }
    else
    {
      if (DEST_16_BIT)
      {
          MOV(R(r_pixel), OP2R(R(r_inword)) | LSLI(16),     "MOV     r_pixel,r_inword,LSL #16        ; fetch 16 bit ECF pattern pixel");
          MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),      "MOV     r_pixel,r_pixel,LSR #16");
      }
    }
  }
  else
  {
    comment(ws, "Fetch a source pixel");
    if (SOURCE_32_BIT)
      ins(ws, LDR(R(r_pixel), R(r_inptr)) | OFFSET(0),    "LDR     r_pixel,[r_inptr]");
    else if (SOURCE_16_BIT)
    {
      MOV(R(r_pixel), OP2R(R(r_inword)) | LSLI(16),     "MOV     r_pixel,r_inword,LSL #16        ; fetch 16 bit pixel");
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),      "MOV     r_pixel,r_pixel,LSR #16");
      /* >>> Maybe we can leave it in the top 16 bits, and get by? Not yet. */
    }
    else
    {
      AND(R(r_pixel), R(r_inword), IMM(ws->in_pixmask), "AND     r_pixel,r_inword,#in_pixmask    ; fetch the pixel");
    }
  }
}

static BOOL fetch_pixel(asm_workspace *wp, workspace *ws, label *l_masked)
/* Check the mask, fetch the current pixel. If the current pixel is
 * transparent then branch out to l_masked. Return TRUE if the branch could be
 * taken, else FALSE.
 */
{
  IFDEBUG(char a[256];)

  if (SOURCE_MASK)
  {
    TST(R(r_maskinword), IMM(1),                      "TST     r_maskinword,#1");
    IFDEBUG(do_sprintf(a,                                "BEQ     %s", l_masked->name);)
    branch(ws, B | EQ, l_masked, a);
  }

  fetch_pixel_unmasked(wp, ws);

  return SOURCE_MASK;
}

static BOOL fetch_pixel2(asm_workspace *wp, workspace *ws, label *l_masked)
/* Check the mask, fetch the pixel after the current one. You are assured
 * that no word of input need be loaded between these two. If the pixel is
 * transparent then branch out to l_masked. Return TRUE if the branch could be
 * taken, else FALSE.
 */
{
#ifdef DEBUG
  char a[256];
#endif

  assert(!PLOTMASK, ERROR_FATAL); /* Doesn't do 2-at-a-time loop */

  if (SOURCE_MASK) /* Test the second pixel of mask */
  {
    if (SOURCE_BPPMASK) /* we may have reached the end of mask word if not doing an aligned plot */
    {
      MOV(R(r_maskinword), OP2R(R(r_maskinword))
                       | RORI(ws->mask_bpp),                 "x"/*MOV     r_maskinword,r_maskinword,ROR #mask_bpp"*/);
      SUB(R(r_maskinshift),R(r_maskinshift),
                       S | IMM(ws->mask_bpp*2) | IMMROR(6),  "x"/*SUBS    r_maskinshift,r_maskinshift,#mask_bpp:SHL:27"*/);
      ins(ws, LDR(R(r_maskinword), R(r_maskinptr))
          | EQ | WRITEBACK | OFFSET(4),                     "x"/* "LDREQ   r_maskinword,[r_maskinptr,#4]!     ; load more mask pixels (inc2)"*/);
      TST(R(r_maskinword), IMM(1),                           "TST     r_maskinword,#1");
    }
    else
    {
      TST(R(r_maskinword),
          ws->mask_bpc < 8
            ? IMM(1 << ws->mask_bpc)
            : IMM(1) | IMMROR(32 - ws->mask_bpc),       "TST     r_maskinword,#1:SHL:mask_bpc");
      IFDEBUG(do_sprintf(a,                                "BEQ     %s", l_masked->name);)
    }
    branch(ws, B | EQ, l_masked, a);
  }

  comment(ws, "Fetch the source pixel after the current one");
  if (SOURCE_32_BIT)
    ins(ws, LDR(R(r_pixel), R(r_inptr)) | OFFSET(4),  "LDR     r_pixel,[r_inptr,#4]");
  else if (SOURCE_16_BIT)
  {
    MOV(R(r_pixel), OP2R(R(r_inword)) | LSRI(16),     "MOV     r_pixel,r_inword,LSR #16");
    /* >>> Getting it into top 16bits harder in this case! */
  }
  else
    AND(R(r_pixel), R(r_in_pixmask),
        OP2R(R(r_inword)) | LSRI(ws->in_bpc),         "AND     r_pixel,r_in_pixmask,r_inword,LSR #in_bpc"
                                                      " ; fetch the next pixel");
  return SOURCE_MASK;
}

static void save_pixel(asm_workspace *wp, workspace *ws)
/* Save the new pixel into the current destination pixel. */
/* Recall GCOL actions:
 * 0 -> overwrite old pixel
 * 1 -> OR with old pixel
 * 2 -> AND with old pixel
 * 3 -> EOR with old pixel
 * 4 -> invert old pixel
 * 5 -> do nothing
 * 6 -> AND old pixel with NOT of new pixel
 * 7 -> OR old pixel with NOT of new pixel
 */
{
  comment(ws, "Put the pixel in the output stream.");
  if (PLOTMASK)
  {
    if (DEST_32_BIT)
    {
      ins(ws, LDR(R(r_pixel), R(r_outptr)) | OFFSET(0),              "LDR     r_pixel,[r_outptr] ;bkah");
      ORR(R(r_pixel), R(r_inword), OP2R(R(r_pixel)),                 "ORR     r_pixel,r_inword,r_pixel               ; 1OR gcol action");
      EOR(R(r_pixel), R(r_bgcolour), OP2R(R(r_pixel)),               "EOR     r_pixel,r_bgcolour,r_pixel            ; 1EOR gcol action");
      ins(ws, STR(R(r_pixel), R(r_outptr)) | OFFSET(0),              "STR     r_pixel,[r_outptr]                    ;blaq5h");
    }
    else
    {
      if (DEST_16_BIT)
      {
        MOV(R(r_pixel), OP2R(R(r_inword)) | LSLI(16),             "MOV     r_pixel,r_inword,LSL #16        ; fetch 16 bit ECF pattern pixel44 99");
        MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),              "MOV     r_pixel,r_pixel,LSR #16         ; 4444444");
        ORR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),         "ORR     r_outword,r_outword,r_pixel           ; ECF OR mask44 99");
        MOV(R(r_pixel), OP2R(R(r_bgcolour)) | LSLI(16),           "MOV     r_pixel,r_bgcolour,LSL #16        ; fetch 16 bit ECF pattern pixel 4499");
        MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),              "MOV     r_pixel,r_pixel,LSR #16           ;449");
        EOR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),         "EOR     r_outword,r_outword,r_pixel           ; ECF EOR mask 4499");
      }
      else
      {
        AND(R(r_pixel), R(r_inword), IMM(ws->out_pixmask),       "1AND     r_pixel,r_inword,#out_pixmask  ; blah blah");
        ORR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),          "ORR     r_outword,r_outword,r_pixel           ; ECF OR mask");
        AND(R(r_pixel), R(r_bgcolour), IMM(ws->out_pixmask),       "1AND     r_pixel,r_bgcolour,#out_pixmask    jthjg");
        EOR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "EOR     r_outword,r_outword,r_pixel           ; ECF EOR mask");
      }
    }
  }
  else
  {
    if (DEST_32_BIT)
    {
      if (ws->gcol != 0) /* Not just a simple store operation */
      {
        ins(ws, LDR(R(r_temp1), R(r_outptr)) | OFFSET(0),             "LDR     r_temp1,[r_outptr]");
        switch(ws->gcol)
        {
          case 7: MVN(R(r_pixel), OP2R(R(r_pixel)),                     "MVN     r_pixel,r_pixel                       ; OR with neg action");
          case 1: ORR(R(r_temp1), R(r_pixel), OP2R(R(r_temp1)),         "ORR     r_temp1,r_pixel,r_temp1               ; OR gcol action"); break;
          case 6: MVN(R(r_pixel), OP2R(R(r_pixel)),                     "MVN     r_pixel,r_pixel                       ; AND with neg action");
          case 2: AND(R(r_temp1), R(r_pixel), OP2R(R(r_temp1)),         "AND     r_temp1,r_pixel,r_temp1               ; AND gcol action"); break;
          case 3: EOR(R(r_temp1), R(r_pixel), OP2R(R(r_temp1)),         "EOR     r_temp1,r_pixel,r_temp1               ; EOR gcol action"); break;
          case 4: MVN(R(r_temp1), OP2R(R(r_temp1)),                     "MVN     r_temp1,r_temp1                       ; neg gcol action"); break;
          /* case 5: is a NOP */
        }
      ins(ws, STR(R(r_temp1), R(r_outptr)) | OFFSET(0),               "STR     r_temp1,[r_outptr]");
      if ((ws->gcol == 7) || (ws->gcol == 6)) /* put r_pixel back as we found it */
        MVN(R(r_pixel), OP2R(R(r_pixel)),                             "1MVN     r_pixel,r_pixel                       ; Put r_pixel back");
      }
      else
      {
        ins(ws, STR(R(r_pixel), R(r_outptr)) | OFFSET(0),             "STR     r_pixel,[r_outptr]");
      }
    }
    else
    {
      if (ws->gcol == 6 || ws->gcol == 7) /* and/or with NOT of incoming pixel */
      {
        if (DESTD_16_BIT)
        {
          EOR(R(r_pixel), R(r_pixel), IMM(255),                       "1EOR     r_pixel,r_pixel,#0x00ff               ; act with NOT of input pixel");
          EOR(R(r_pixel), R(r_pixel), IMM(255) | IMMROR(24),          "1EOR     r_pixel,r_pixel,#0xff00");
        }
        else
          EOR(R(r_pixel), R(r_pixel), IMM(ws->out_dpixmask),          "1EOR     r_pixel,r_pixel,#out_dpixmask         ; act with NOT of input pixel");
      }

      switch (ws->gcol)
      {
        case 0:
          if (SOURCE_MASK) /* if no mask, the pixels are clear already */
          {
            if (DESTD_16_BIT)
            {
              BIC(R(r_outword), R(r_outword), IMM(255),                 "BIC     r_outword,r_outword,#0x00ff");
              BIC(R(r_outword), R(r_outword), IMM(255) | IMMROR(24),    "BIC     r_outword,r_outword,#0xff00");
            }
            else
              BIC(R(r_outword), R(r_outword), IMM(ws->out_dpixmask),    "BIC     r_outword,r_outword,#out_dpixmask");
          }
          /* fall through */
        case 7:
        case 1: ORR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "ORR     r_outword,r_outword,r_pixel           ; gcol action"); break;
        case 6:
        case 2: AND(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "AND     r_outword,r_outword,r_pixel           ; AND gcol action"); break;
        case 3: EOR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "EOR     r_outword,r_outword,r_pixel           ; EOR gcol action"); break;
        case 4: if (DESTD_16_BIT)
                {
                  EOR(R(r_outword), R(r_outword), IMM(255),             "EOR     r_outword,r_outword,#0x00ff           ; negate existing pixel");
                  EOR(R(r_outword), R(r_outword), IMM(255) | IMMROR(24),"EOR     r_outword,r_outword,#0xff00");
                }
                else
                  EOR(R(r_outword), R(r_outword), IMM(ws->out_dpixmask),"EOR     r_outword,r_outword,#out_dpixmask     ; negate existing pixel");
                break;
        case 5: comment(ws, "no GCOL action"); break;
      }
      if (ws->gcol == 6 || ws->gcol == 7) /* put r_pixel back as we found it in case scaling > 1:1! */
      {
        if (DESTD_16_BIT)
        {
          EOR(R(r_pixel), R(r_pixel), IMM(255),                       "EOR     r_pixel,r_pixel,#0x00ff               ; put r_pixel back as it was");
          EOR(R(r_pixel), R(r_pixel), IMM(255) | IMMROR(24),          "EOR     r_pixel,r_pixel,#0xff00               ; put r_pixel back as it was");
        }
        else
          EOR(R(r_pixel), R(r_pixel), IMM(ws->out_dpixmask),          "EOR     r_pixel,r_pixel,#out_dpixmask         ;  put r_pixel back as it was");
      }
    }
  }
}

static void save_pixel_opt(asm_workspace *wp, workspace *ws)
/* Save pixel for use by optimised >5 scaling code. */
{
  if (DESTD_16_BIT)
  {
    BIC(R(r_outword), R(r_outword), IMM(255),                 "3BIC     r_outword,r_outword,#0x00ff");
    BIC(R(r_outword), R(r_outword), IMM(255) | IMMROR(24),    "4BIC     r_outword,r_outword,#0xff00");
  }
  else
  {
    BIC(R(r_outword), R(r_outword), IMM(ws->out_dpixmask),    "5BIC     r_outword,r_outword,#out_dpixmask");
  }
    ORR(R(r_outword), R(r_outword), OP2R(R(r_pixel)),       "6ORR     r_outword,r_outword,r_pixel           ; gcol action");
}

static void save_pixel2(asm_workspace *wp, workspace *ws)
/* Save the new pixel into the pixel after the current destination pixel. */
{
  comment(ws, "Put the pixel in the output stream, one after the 'current' pixel.");

  /* Current limitation */
  assert(ws->gcol == 0, ERROR_FATAL);

  if (DEST_32_BIT)
  {
    ins(ws, STR(R(r_pixel), R(r_outptr)) | OFFSET(4),         "STR     r_pixel,[r_outptr,#4]");
  }
  else
  {
    if (SOURCE_MASK)
    {
      if (wp->BPC == 16) /* DEST_16_BIT but includes double-pixel 256-colour mode 10 too */
      {
        BIC(R(r_outword), R(r_outword), IMM(255) | IMMROR(16),  "BIC     r_outword,r_outword,#0x00ff0000");
        BIC(R(r_outword), R(r_outword), IMM(255) | IMMROR(8),   "BIC     r_outword,r_outword,#0xff000000");
      }
      else
        BIC(R(r_outword), R(r_outword),
            wp->BPC == 1
              ? IMM(2) /* IMMROR arg must be an even number */
              : IMM(ws->out_dpixmask) | IMMROR(32 - wp->BPC),   "BIC     r_outword,r_outword,#out_dpixmask:SHL:out_bpc");
    }
    ORR(R(r_outword),R(r_outword),
        OP2R(R(r_pixel)) | LSLI(wp->BPC),                       "ORR     r_outword,r_outword,r_pixel,LSL #out_bpc");
  }
}

/**************************************************************************
*                                                                         *
*    Bitblit: Advancing the current pixel.                                *
*                                                                         *
**************************************************************************/

static void fetch_pixel_inc(asm_workspace *wp, workspace *ws)
/* Increment the pointer to the source pixel */
{
  comment(ws, "Advance source pointer");

  if (!PLOTMASK) /* The ECF pattern remains aligned to the destination */
  {
    if (SOURCE_32_BIT)
    {
      ADD(R(r_inptr), R(r_inptr), IMM(4),                      "ADD     r_inptr,r_inptr,#4");
    }
    else
    {
      MOV(R(r_inword), OP2R(R(r_inword)) | RORI(ws->in_bpc),   "MOV     r_inword,r_inword,ROR #in_bpc");
      if (SOURCE_MASK & !(SOURCE_BPPMASK))
        MOV(R(r_maskinword), OP2R(R(r_maskinword)) |
                             RORI(ws->in_bpc),                 "MOV     r_maskinword,r_maskinword,ROR #in_bpc");
      SUB(R(r_inshift), R(r_inshift),
          S | IMM(ws->in_bpc*2) | IMMROR(6),                   "SUBS    r_inshift,r_inshift,#in_bpc:SHL:27 ; auto-resets itself to 0");
      ins(ws, LDR(R(r_inword), R(r_inptr))
            | EQ | WRITEBACK | OFFSET(4),                      "LDREQ   r_inword,[r_inptr,#4]!");
    }
  }

  if (SOURCE_MASK)
  {
    if (SOURCE_BPPMASK || PLOTMASK)
    {
      MOV(R(r_maskinword), OP2R(R(r_maskinword))
                         | RORI(ws->mask_bpp),               "MOV     r_maskinword,r_maskinword,ROR #mask_bpp");
      SUB(R(r_maskinshift),R(r_maskinshift),
                         S | IMM(ws->mask_bpp*2) | IMMROR(6),"SUBS    r_maskinshift,r_maskinshift,#mask_bpp:SHL:27 ; auto-resets itself to 0");
      ins(ws, LDR(R(r_maskinword), R(r_maskinptr))
            | EQ | WRITEBACK | OFFSET(4),                    "LDREQ   r_maskinword,[r_maskinptr,#4]!");
    }
    else
    {
      assert(!SOURCE_32_BIT, ERROR_FATAL);
      ins(ws, LDR(R(r_maskinword),
              R(r_inptr)) | EQ | INDEX(R(r_masko), 0),       "LDREQ   r_maskinword,[r_inptr,r_masko]");
    }
  }
}

static void fetch_pixel_inc2(asm_workspace *wp, workspace *ws)
/* Increment the pointer to the source pixel by two - only used in the 2-at-a-time
 * optimised loop
 */
{
  comment(ws, "Advance source pointer by two pixels");
  if (SOURCE_32_BIT)
  {
    ADD(R(r_inptr), R(r_inptr), IMM(8),                      "ADD     r_inptr,r_inptr,#8                ; past 2 32-bit pixels");
  }
  else if (SOURCED_16_BIT)
  {
    /* Two pixels per word - assured of loading a new word */
    ins(ws, LDR(R(r_inword), R(r_inptr))
          | WRITEBACK | OFFSET(4),                           "LDR     r_inword,[r_inptr,#4]!             ; past 2 16-bit pixels");
  }
  else
  {
    MOV(R(r_inword), OP2R(R(r_inword)) | RORI(ws->in_bpc*2), "MOV     r_inword,r_inword,ROR #in_bpc*2");
    if (SOURCE_MASK & !(SOURCE_BPPMASK))
      MOV(R(r_maskinword), OP2R(R(r_maskinword)) |
                           RORI(ws->in_bpc*2),               "MOV     r_maskinword,r_maskinword,ROR #in_bpc*2");
    SUB(R(r_inshift), R(r_inshift),
        S | IMM(ws->in_bpc) | IMMROR(4),                     "SUBS    r_inshift,r_inshift,#in_bpc:SHL:28 ; auto-resets itself to 0");
    ins(ws, LDR(R(r_inword), R(r_inptr))
          | EQ | WRITEBACK | OFFSET(4),                      "LDREQ   r_inword,[r_inptr,#4]!             ; load more input pixels (inc2)");
  }

  if (SOURCE_MASK)
  {
    if (SOURCE_BPPMASK)
    {
      MOV(R(r_maskinword), OP2R(R(r_maskinword))
                         | RORI(ws->mask_bpp),               "MOV     r_maskinword,r_maskinword,ROR #mask_bpp");
      SUB(R(r_maskinshift),R(r_maskinshift),
                         S | IMM(ws->mask_bpp*2) | IMMROR(6),"SUBS    r_maskinshift,r_maskinshift,#mask_bpp:SHL:27");
      ins(ws, LDR(R(r_maskinword), R(r_maskinptr))
            | EQ | WRITEBACK | OFFSET(4),                    "LDREQ   r_maskinword,[r_maskinptr,#4]!     ; load more mask pixels (inc2)");
    }
    else
    {
      assert(!SOURCE_32_BIT, ERROR_FATAL);
      ins(ws, LDR(R(r_maskinword), R(r_inptr))
              | EQ | INDEX(R(r_masko), 0),                   "LDREQ   r_maskinword,[r_inptr,r_masko]      ; load more mask pixels (inc2)");
    }
  }
}

#if 1
static void skip_current_output_words(asm_workspace *wp, workspace *ws)
/* Skip over masked out words. r_xcount = output pixels to skip
 *                             r_temp1   = pixels left in current word.
 */
{
  comment(ws, "4Skipping masked words.");
  if (DEST_32_BIT)
  {
    ADD(R(r_outptr), R(r_outptr), R(r_xcount) | LSLI(2),          "4~ADD     r_outptr,r_outptr,r_xcount,LSL #2        ; skip 4*pixels bytes");
    MOV(R(r_xcount), IMM(0),                                      "41MOV     r_xcount,#0");
  }
  else
  {
    SUB(R(r_xcount), R(r_xcount), OP2R(R(r_temp1)),               "4~SUB     r_xcount, r_xcount, r_temp1");
    MOV(R(r_temp1),  OP2R(R(r_temp1)) | LSLI(wp->Log2bpc),      "4~MOV     r_temp1, t_temp1, LSL #out_log2bpc");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORR(R(r_temp1)),      "4~MOV     r_outword,r_outword,ROR r_temp1");
    ins(ws, STR(R(r_outword), R(r_outptr)) | POSTINC(4),          "4~STR     r_outword,[r_outptr],#4");
    MOV(R(r_outshift), IMM(0),                                    "4~MOV     r_outshift, #0");

    MOV(R(r_temp1), OP2R(R(r_xcount)) | S |LSRI(ws->out_l2ppw),   "4~~MOVS     r_temp1,r_xcount,LSR #out_log2ppw            ; whole words to skip");
    ADD(R(r_outptr), R(r_outptr), NE | R(r_temp1) | LSLI(2),      "4~ADDNE    r_outptr,r_outptr,r_temp1,LSL #2             ; skip 4*pixels bytes");

    ins(ws, LDR(R(r_outword), R(r_outptr)) | OFFSET(0),           "4~~LDR     r_outword,[r_outptr]");
    SUB(R(r_xcount), R(r_xcount),
                      OP2R(R(r_temp1)) | LSLI(ws->out_l2ppw),     "4~SUB     r_xcount, r_xcount, r_temp1 LSL #out_log2ppw ; pixels left to skip");
  }
}

static void skip_some_pixels(asm_workspace *wp, workspace *ws)
/* Adjust outword and outshift back to start */
{
    MOV(R(r_temp1),  OP2R(R(r_xcount)) | LSLI(wp->Log2bpc),    "2~~MOV     r_temp1, r_xcount, LSL #out_log2bpc");
    MOV(R(r_outword), OP2R(R(r_outword)) | RORR(R(r_temp1)),     "2~MOV     r_outword,r_outword,ROR r_temp1");
    SUB(R(r_outshift), R(r_outshift),
        OP2R(R(r_temp1)) | LSLI(27),                                   "2~~SUB    r_outshift,r_outshift,r_temp1,SHL #27");
    MOV(R(r_xcount), IMM(0),                                      "31MOV     r_xcount,#0");
    UNUSED(wp);
}
#endif

static void save_pixel_inc(asm_workspace *wp, workspace *ws)
/* Increment the pointer to the destination pixel */
{
  comment(ws, "Advance destination pointer");
  if (DEST_32_BIT)
  {
    ADD(R(r_outptr), R(r_outptr), IMM(4),                    "ADD     r_outptr,r_outptr,#4 323232");
  }
  else
  {
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),    "MOV     r_outword,r_outword,ROR #out_bpc    545454");
    if (PLOTMASK)
    {
      MOV(R(r_inword), OP2R(R(r_inword)) | RORI(wp->BPC),    "MOV     r_inword,r_inword,ROR #out_bpc         ; advance ECF pattern    5");
      MOV(R(r_bgcolour), OP2R(R(r_bgcolour)) | RORI(wp->BPC),    "MOV     r_bgcolour,r_bgcolour,ROR #out_bpc ; advance ECF eeyore pattern    5");
    }
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                      "SUBS    r_outshift,r_outshift,#out_bpc:SHL:27        5");
    ins(ws, STR(R(r_outword), R(r_outptr)) | EQ | POSTINC(4),"STREQ   r_outword,[r_outptr],#4        4");
    if (ws->gcol == 0 && !SOURCE_MASK && !PLOTMASK)
      MOV(R(r_outword), EQ | IMM(0),                         "MOVEQ   r_outword,#0                    ; setting pixels and no mask      4");
    else
      ins(ws, LDR(R(r_outword), R(r_outptr)) | EQ | OFFSET(0), "LDREQ   r_outword,[r_outptr]        4");
  }
  odither_inc(wp, ws, 0);
}

static void save_pixel_inc2(asm_workspace *wp, workspace *ws)
/* Increment the pointer to the destination pixel by two. You are assured that
 * a word fetch won't be necessary after the first of these. Only used in the
 * optimised 2-at-a-time inner loop. You are assured that gcol==0.
 */
{
  comment(ws, "Advance destination pointer by two pixels");
  if (DEST_32_BIT)
    ADD(R(r_outptr), R(r_outptr), IMM(8),                    "ADD     r_outptr,r_outptr,#8");
  else if (DESTD_16_BIT)
  {
    /* Two pixels per word - assured of saving a word, assured that gcol==0 and !SOURCE_MASK*/
    ins(ws, STR(R(r_outword), R(r_outptr)) | POSTINC(4),     "STR     r_outword,[r_outptr],#4         ; store two pixels");
    if (!SOURCE_MASK)
      MOV(R(r_outword), IMM(0),                              "MOV     r_outword,#0                    ; setting pixels and no mask");
    else
      ins(ws, LDR(R(r_outword), R(r_outptr)) | OFFSET(0),    "LDR     r_outword,[r_outptr]            ; load dest data (in case of mask)");
  }
  else
  {
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC*2),  "MOV     r_outword,r_outword,ROR #out_bpc*2");
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC) | IMMROR(4),                        "SUBS    r_outshift,r_outshift,#out_bpc:SHL:28");
    ins(ws, STR(R(r_outword), R(r_outptr)) | EQ | POSTINC(4),"STREQ   r_outword,[r_outptr],#4         ; store pixels (inc2)");
    if (!SOURCE_MASK)
      MOV(R(r_outword), EQ | IMM(0),                         "MOVEQ   r_outword,#0                    ; setting pixels and no mask (inc2)");
    else
      ins(ws, LDR(R(r_outword), R(r_outptr)) | EQ | OFFSET(0), "LDREQ   r_outword,[r_outptr]            ; get dest data (in case of mask)");
    /* If entirely replacing pixels, no need to fetch the old ones.
     * The last word has to be patched up carefully, see x_loop.
     */
  }
  odither_inc(wp, ws, 0); /* assume this has also been called once after the first pixel has been translated */
}

static void plot_current_output_words(asm_workspace *wp, workspace *ws, int scale)
/* plot multiple words of one pixel. r_xcount = output pixels to skip
 *                                   r_temp1   = pixels left in current word.
 *                                   r_pixel = pixel to output.
 */
{
  int loop;
  comment(ws, "2Optimised plotting of scaled sprite.");
  if (DEST_32_BIT)
  {
#if 1
    ins(ws, STR(R(r_pixel),  R(r_outptr)) | POSTINC(4),      "32STR     r_pixel,[r_outptr],#4");
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                         "14SUBS    r_xcount,r_xcount,#1");
    if (scale < 21)
    {
      for (loop = 1;loop<scale;loop++)
      {
        ins(ws, STR(R(r_pixel), R(r_outptr)) | NE | POSTINC(4),      "32STRNE   r_pixel,[r_outptr],#4");
        SUB(R(r_xcount), R(r_xcount),
              S | NE | IMM(1),                                    "14SUBNES    r_xcount,r_xcount,#1");
      }
    }
    else
    {
      CMP(R(r_xcount), IMM(10),                                    "CMP     r_xcount, #10");
      branch(ws, B | LE, L(plot_loop1b),                           "BLE     plot_loop1b");
      DEFINE_LABEL(plot_loop1a, "loop for every ten pixels")
      for (loop = 0;loop<10;loop++)
      {
        ins(ws, STR(R(r_pixel), R(r_outptr)) | POSTINC(4),         "32STR   r_pixel,[r_outptr],#4");
      }
      SUB(R(r_xcount), R(r_xcount),
          IMM(10),                                                 "14SUB    r_xcount,r_xcount,#10");
      CMP(R(r_xcount), IMM(10),                                    "CMP     r_xcount, #10");
      branch(ws, B | GT, L(plot_loop1a),                           "BGT     plot_loop1a");
      DEFINE_LABEL(plot_loop1b, "branch here when LH side obscured")
      CMP(R(r_xcount), IMM(0),                                     "CMP     r_xcount, #0");
      for (loop = 0;loop<10;loop++)
      {
        ins(ws, STR(R(r_pixel), R(r_outptr)) | NE | POSTINC(4),      "4STRNE   r_pixel,[r_outptr],#4");
        SUB(R(r_xcount), R(r_xcount),
              S | NE | IMM(1),                                    "16SUBNES    r_xcount,r_xcount,#1");
      }
    }
#else
    for (loop = 0;loop<scale;loop++)
      ins(ws, STR(R(r_pixel), R(r_outptr)) | POSTINC(4),      "32STR   r_outword,[r_outptr],#4");
#endif
  }
  else
  {
    SUB(R(r_xcount), R(r_xcount), OP2R(R(r_temp1)),             "52SUB     r_xcount, r_xcount, r_temp1");

    DEFINE_LABEL(plot_loop1, "1???")
    save_pixel_opt(wp, ws);
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "015MOV     r_outword,r_outword,ROR #out_bpc");
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                         "7SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    branch(ws, B | EQ, L(plot_loop1a),                           "BEQ     plot_loop1a");

    save_pixel_opt(wp, ws);
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "115MOV     r_outword,r_outword,ROR #out_bpc");
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                         "17SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    branch(ws, B | EQ, L(plot_loop1b),                           "BEQ     plot_loop1b");

    save_pixel_opt(wp, ws);
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "215MOV     r_outword,r_outword,ROR #out_bpc");
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                         "27SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    branch(ws, B | EQ, L(plot_loop1c),                           "BEQ     plot_loop1c");

    save_pixel_opt(wp, ws);
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "315MOV     r_outword,r_outword,ROR #out_bpc");
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                         "37SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");

    branch(ws, B | NE, L(plot_loop1),                           "8BNE     plot_loop1");
    DEFINE_LABEL(plot_loop1a, "plot loop 1a - coz only one forward referance allowed")
    DEFINE_LABEL(plot_loop1b, "plot loop 1b - coz only one forward referance allowed")
    DEFINE_LABEL(plot_loop1c, "plot loop 1c - coz only one forward referance allowed")

    ins(ws, STR(R(r_outword), R(r_outptr)) | POSTINC(4),          "9STR     r_outword,[r_outptr],#4");

    MOV(R(r_temp1), OP2R(R(r_xcount)) | S |LSRI(ws->out_l2ppw),   "0MOVS    r_temp1,r_xcount,LSR #out_log2ppw            ; whole words to skip");

    branch(ws, B | EQ, L(plot_loop3),                             "1BEQ     plot_loop3");

    for (loop = wp->BPP;loop<32;loop*=2)
      ORR(R(r_pixel), R(r_pixel), OP2R(R(r_pixel)) | LSLI(loop),  "2ORR     r_pixel,r_pixel,r_pixel, LSL #somenumber");
    DEFINE_LABEL(plot_loop2, "2???")
    ins(ws, STR(R(r_pixel), R(r_outptr)) | POSTINC(4),            "3STR     r_pixel,[r_outptr],#4");
    SUB(R(r_xcount), R(r_xcount),
        IMM(ws->out_ppw),                                         "4SUB     r_xcount,r_xcount,#out_ppw");
    SUB(R(r_temp1), R(r_temp1),
        S | IMM(1),                                               "5SUBS    r_temp1,r_temp1,#1");
    branch(ws, B | NE, L(plot_loop2),                             "6BNE     plot_loop2");

    if (DESTD_16_BIT)
    {
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSLI(16),                "7MOV     r_pixel, r_pixel, LSL #16            ; whole words to skip");
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(16),                "8MOV     r_pixel, r_pixel, LSR #16            ; whole words to skip");
    }
    else
      AND(R(r_pixel), R(r_pixel), IMM(ws->out_dpixmask),          "9AND     r_pixel,r_pixel,#dpix_mask");
    DEFINE_LABEL(plot_loop3, "3???")


    ins(ws, LDR(R(r_outword), R(r_outptr)) | OFFSET(0),           "0LDR     r_outword,[r_outptr]");
  }
}

static void plot_some_pixels(asm_workspace *wp, workspace *ws)
/* Non complete word pixel plot */
{
    DEFINE_LABEL(plot_loop4, "4???")
    save_pixel_opt(wp, ws);
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "14MOV     r_outword,r_outword,ROR #out_bpc");
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                          "15SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                             "16SUBS    r_xcount, r_xcount, #1");
    branch(ws, B | EQ, L(plot_loop4a),                          "17BEQ     plot_loop4a");

    save_pixel_opt(wp, ws);
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "214MOV     r_outword,r_outword,ROR #out_bpc");
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                          "215SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                             "216SUBS    r_xcount, r_xcount, #1");
    branch(ws, B | EQ, L(plot_loop4b),                          "17BEQ     plot_loop4b");

    save_pixel_opt(wp, ws);
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "314MOV     r_outword,r_outword,ROR #out_bpc");
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                          "315SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                             "316SUBS    r_xcount, r_xcount, #1");
    branch(ws, B | EQ, L(plot_loop4c),                          "17BEQ     plot_loop4c");

    save_pixel_opt(wp, ws);
    MOV(R(r_outword), OP2R(R(r_outword)) | RORI(wp->BPC),       "414MOV     r_outword,r_outword,ROR #out_bpc");
    SUB(R(r_outshift), R(r_outshift),
        S | IMM(wp->BPC*2) | IMMROR(6),                          "415SUBS    r_outshift,r_outshift,#out_bpc:SHL:27");
    SUB(R(r_xcount), R(r_xcount),
        S | IMM(1),                                             "416SUBS    r_xcount, r_xcount, #1");

    branch(ws, B | NE, L(plot_loop4),                           "17BNE     plot_loop4");
    DEFINE_LABEL(plot_loop4a, "plot loop 4a - coz only one forward referance allowed")
    DEFINE_LABEL(plot_loop4b, "plot loop 4b - coz only one forward referance allowed")
    DEFINE_LABEL(plot_loop4c, "plot loop 4c - coz only one forward referance allowed")
}

/**************************************************************************
*                                                                         *
*    Bitblit: Overall construction of the X loop.                         *
*                                                                         *
**************************************************************************/

static void init_word_registers(asm_workspace *wp, workspace *ws)
/* Initialise inword, outword, maskinword from their respective pointers
 * and shift values.
 */
{
  comment(ws, "Load initial values of word registers");

  /* Set up inword */
  if (!PLOTMASK) /* PLOTMASK case handled below, because helped by setting up r_outword */
  {
    if (!SOURCE_32_BIT)
    {
      ins(ws, LDR(R(r_inword), R(r_inptr)) | OFFSET(0),         "LDR     r_inword,[r_inptr]              ; fetch first input pixels");
      MOV(R(r_pixel), OP2R(R(r_inshift)) | LSRI(27),            "MOV     r_pixel,r_inshift,LSR #27       ; get real shift distance");
      RSB(R(r_pixel), R(r_pixel), IMM(32),                      "RSB     r_pixel,r_pixel,#32             ; temporary use of r_pixel");
      MOV(R(r_inword), OP2R(R(r_inword)) | RORR(R(r_pixel)),    "MOV     r_inword,r_inword,ROR r_pixel   "
                                                              "; current input pixel now in least sig bit[s]");
    }
  }

  if (SOURCE_MASK) /* Set up maskinword */
  {
    if (SOURCE_BPPMASK || PLOTMASK)
    {
      ins(ws, LDR(R(r_maskinword), R(r_maskinptr)) | OFFSET(0), "LDR     r_maskinword,[r_maskinptr]        ; fetch first mask word");
      MOV(R(r_pixel), OP2R(R(r_maskinshift)) | LSRI(27),      "MOV     r_pixel,r_maskinshift,LSR #27     ; get real shift distance");
      RSB(R(r_pixel), R(r_pixel), IMM(32),                    "RSB     r_pixel,r_pixel,#32         ; mask shift");
    }
    else
      ins(ws, LDR(R(r_maskinword),
              R(r_inptr)) | INDEX(R(r_masko), 0),             "LDR     r_maskinword,[r_inptr,r_masko]    ; fetch first mask word");
    MOV(R(r_maskinword), OP2R(R(r_maskinword)) | RORR(R(r_pixel)),"MOV     r_maskinword,r_maskinword,ROR r_pixel "
                                                              "; current mask pixel now in least sig bit[s]");
  }

  if (!DEST_32_BIT) /* Set up outword */
  {
    if (ws->gcol == 0 && !SOURCE_MASK && !PLOTMASK)
    {
      /* Faster in the inner loop, but the unneeded pixels must be cleared out first */
      MOV(R(r_pixel), S | OP2R(R(r_outshift)) | LSRI(27),     "MOVS    r_pixel,r_outshift,LSR #27      ; get real shift distance");
      ins(ws, NE | LDR(R(r_outword), R(r_outptr)) | OFFSET(0),  "LDRNE   r_outword,[r_outptr]            ; load up output word");
      MOV(R(r_outword), NE | OP2R(R(r_outword))
                      | LSLR(R(r_pixel)),                     "MOVNE   r_outword,r_outword,LSL r_pixel "
                                                              "; set untouched pixels to correct places, clear the others");
      MOV(R(r_outword), EQ | IMM(0),                          "MOVEQ   r_outword,#0                    ; if r_pixel=0, make them all clear");
    }
    else
    {
      ins(ws, LDR(R(r_outword), R(r_outptr)) | OFFSET(0),     "LDR     r_outword,[r_outptr]            ; load up output word");
      MOV(R(r_pixel), OP2R(R(r_outshift)) | LSRI(27),         "MOV     r_pixel,r_outshift,LSR #27      ; get real shift distance");
      RSB(R(r_pixel), R(r_pixel), IMM(32),                    "RSB     r_pixel,r_pixel,#32             ; temp use of r_pixel");
      MOV(R(r_outword), OP2R(R(r_outword)) | RORR(R(r_pixel)),"MOV     r_outword,r_outword,ROR r_pixel "
                                                              "; current output pixel now in least sig bit[s]");
      /* Set up inword from ECF pattern - uses r_pixel value */
      if (PLOTMASK)
      {
        ins(ws, LDR(R(r_inword), R(r_inptr))
              | INDEX(R(r_ecfindex), 0),                      "LDR     r_inword,[r_inptr,r_ecfindex]   ; get ECF pattern word");
        MOV(R(r_inword), OP2R(R(r_inword)) | RORR(R(r_pixel)),"MOV     r_inword,r_inword,ROR r_pixel  1 "
                                                              "; current ECF pixel now in least sig bit[s]");
        ADD(R(r_ecfindex), R(r_ecfindex),
              IMM(4),                                           "ADD     r_ecfindex,r_ecfindex,#4        ; to load EOR word 1");
        ins(ws, LDR(R(r_bgcolour), R(r_inptr))
              | INDEX(R(r_ecfindex), 0),                        "LDR     r_bgcolour,[r_inptr,r_ecfindex]   ;fetch next EOR word of ECF1");
        SUB(R(r_ecfindex), R(r_ecfindex),
              IMM(4),                                           "SUB     r_ecfindex,r_ecfindex,#4        ;blah1");
        MOV(R(r_bgcolour), OP2R(R(r_bgcolour)) | RORR(R(r_pixel)),"MOV     r_bgcolour,r_bgcolour,ROR r_pixel  1 ");
      }
    }
  }
}

static void loop_x(asm_workspace *wp, workspace *ws)
/* The variables are set up - perform the inner loop that processes a
 * single line. Fall out of the bottom of the loop when complete.
 */
{
  BOOL mask_possible;

  comment(ws, "The inner loop: iterating along a row of pixels.");
  if (x_block_move(wp, ws))
  {
    comment(ws, "Very simple inner loop - we use an existing block-move primitive");
    if(wp->CPUFlags & CPUFlag_BLX)
    {
      BLX(R(r_blockroutine),                                   "BLX     r_blockroutine                  ; block move");
    }                 
    else
    {
      MOV(R(lr), OP2R(R(pc)),                                  "MOV     lr,pc                           ; remember return address");
      MOV(R(pc), OP2R(R(r_blockroutine)),                      "MOV     pc,r_blockroutine               ; block move");
    }
    /* It would be a little bit more efficient to do state saving here rather than inside the routine,
     * and so only save registers that need to be saved - not a big saving, and only per-line.
     */
  }
  else
  {
    init_word_registers(wp, ws);

    if (simple_x_scale(wp, ws)) /* 1:1 scaling */
    {
      comment(ws, "1:1 scaling along x, so each source pixel is painted once");

#if 0
      align16(wp, ws);
      DEFINE_LABEL(loop_x_repeat, "Loop around for each source/dest pixel")
      mask_possible = fetch_pixel(wp, ws, &ws->labels.l_masked);
      translate_pixel(wp, ws);
      save_pixel(wp, ws);
      if (mask_possible) DEFINE_LABEL(l_masked, "This pixel masked out")
      fetch_pixel_inc(wp, ws);
      save_pixel_inc(wp, ws);
      SUB(R(r_xsize), R(r_xsize), S | IMM(1),                    "SUBS    r_xsize,r_xsize,#1");
      branch(ws, B | NE, L(loop_x_repeat),                       "BNE     loop_x_repeat");
#else

      /* We generate a loop that does two pixels at a time, only advancing pointers, counts, shifts
       * etc. every two pixels. There are two versions of this loop, one where the in and out shifts
       * are 'in phase' (ie initially both even or both odd), one where they are out of phase. There
       * is also some initial stuff to get the outshift to be even if necessary when entering either
       * of these, and some final stuff to patch up the end.
       */
      comment(ws, "Optimised 2-at-a-time loop");
      if (!DEST_32_BIT)
      {
        TST(R(r_outshift), IMM(wp->BPC*2) | IMMROR(6),           "TST     r_outshift,#out_bpc:SHL:27      ; start at odd or even pixel shift?");
        branch(ws, B | EQ, L(x_evenstart),                       "BEQ     x_evenstart                     ; B if even");
        comment(ws, "r_outshift an odd number of pixels - process just one of these");
        mask_possible = fetch_pixel(wp, ws, &ws->labels.x_oddmask);
        translate_pixel(wp, ws);
        save_pixel(wp, ws);
        if (mask_possible) DEFINE_LABEL(x_oddmask, "This pixel masked out")
        fetch_pixel_inc(wp, ws);
        save_pixel_inc(wp, ws);
        SUB(R(r_xsize), R(r_xsize), S | IMM(1),                  "SUBS    r_xsize,r_xsize,#1              ; count towards overall width");
        branch(ws, B | EQ, L(loop_x_exit),                       "BEQ     loop_x_exit                     ; check for just one pixel wide");
        DEFINE_LABEL(x_evenstart, "r_outshift is an even number of pixels")
      }
      if (!SOURCE_32_BIT)
      {
        TST(R(r_inshift), IMM(ws->in_bpc*2) | IMMROR(6),         "TST     r_inshift,#in_bpc:SHL:27        ; input at odd or even pixel shift?");
        branch(ws, B | NE, L(x_misaligned),                      "BNE     x_misaligned                    ; B if odd");
      }
      branch(ws, B, L(x_aligned_enter),                          "B       x_aligned_enter                 ; else, in phase with output - start loop");
      newline();

      align16(wp, ws);
      DEFINE_LABEL(x_aligned_loop, "The 2-at-a-time inner loop, aligned case")
      mask_possible = fetch_pixel(wp, ws, &ws->labels.x_alignmask1);
      translate_pixel(wp, ws);
      save_pixel(wp, ws);
      if (mask_possible) DEFINE_LABEL(x_alignmask1, "First pixel masked out")
      odither_inc(wp, ws, 0);
      mask_possible = fetch_pixel2(wp, ws, &ws->labels.x_alignmask2);
      translate_pixel(wp, ws);
      save_pixel2(wp, ws);
      if (mask_possible) DEFINE_LABEL(x_alignmask2, "Second pixel masked out")
      fetch_pixel_inc2(wp, ws);
      save_pixel_inc2(wp, ws);
      DEFINE_LABEL(x_aligned_enter, "Entering the aligned 2-at-a-time inner loop")
      SUB(R(r_xsize), R(r_xsize), S | IMM(2),                    "SUBS    r_xsize,r_xsize,#2              ; done 2 pixels");
      branch(ws, B | GE, L(x_aligned_loop),                      "BGE     x_aligned_loop                  ; loop until 0 or 1 left");
      if (!SOURCE_32_BIT)
      {
        branch(ws, B, L(x_2atatime_exit),                        "B       x_2atatime_exit                 ; final patchup code");
        newline();

        DEFINE_LABEL(x_misaligned, "The 2-at-a-time inner loop, misaligned case, entry sequence")
        /* A bit delicate - we have to prepare the input stream for an inc2 call,
         * by effectively winding it back by a pixel. We know this won't go back a word,
         * however, because r_inshift is an odd number of pixels.
         */
        comment(ws, "Wind input stream back by a pixel");
        if (SOURCE_32_BIT)
          SUB(R(r_inptr), R(r_inptr), IMM(4),                    "SUB     r_inptr,r_inptr,#4              ; wind back a pixel");
        else
        {
          MOV(R(r_inword), OP2R(R(r_inword)) | LSLI(ws->in_bpp), "MOV     r_inword,r_inword,LSL #in_bpp   ; wind back a pixel");
          ADD(R(r_inshift), R(r_inshift),
              IMM(ws->in_bpp*2) | IMMROR(6),                     "ADD     r_inshift,r_inshift,#in_bpp:SHL:27");
        }
        if (SOURCE_MASK)
        {
          MOV(R(r_maskinword), OP2R(R(r_maskinword))
                             | LSLI(ws->mask_bpp),               "MOV     r_maskinword,r_maskinword,LSL #mask_bpp");
          if (SOURCE_BPPMASK)
            ADD(R(r_maskinshift), R(r_maskinshift),
                IMM(ws->mask_bpp*2) | IMMROR(6),                 "ADD     r_maskinshift,r_maskinshift,#mask_bpp:SHL:27");
        }
        branch(ws, B, L(x_misaligned_enter),                     "B       x_misaligned_enter              ; start misaligned loop");
        align16(wp, ws);
        DEFINE_LABEL(x_misaligned_loop, "The 2-at-a-time inner loop, misaligned case")
        mask_possible = fetch_pixel2(wp, ws, &ws->labels.x_misalignmask1);
        translate_pixel(wp, ws);
        save_pixel(wp, ws);
        if (mask_possible) DEFINE_LABEL(x_misalignmask1, "A pixel masked out")
        fetch_pixel_inc2(wp, ws);
        odither_inc(wp, ws, 0);
        mask_possible = fetch_pixel(wp, ws, &ws->labels.x_misalignmask2);
        translate_pixel(wp, ws);
        save_pixel2(wp, ws);
        if (mask_possible) DEFINE_LABEL(x_misalignmask2, "Another pixel masked out")
        save_pixel_inc2(wp, ws);
        DEFINE_LABEL(x_misaligned_enter, "Entering the misaligned 2-at-a-time inner loop")
        SUB(R(r_xsize), R(r_xsize), S | IMM(2),                  "SUBS    r_xsize,r_xsize,#2              ; count towards overall size");
        branch(ws, B | GE, L(x_misaligned_loop),                 "BGE     x_misaligned_loop               ; and loop until done");
        fetch_pixel_inc(wp, ws);
        newline();

        DEFINE_LABEL(x_2atatime_exit, "Final patchup for 2-at-a-time inner loop")
      }
      else
        newline();
      ADD(R(r_xsize), R(r_xsize), S | IMM(2),                    "ADDS    r_xsize,r_xsize,#2              ; up to 0 or 1");
      branch(ws, B | EQ, L(loop_x_exit1),                        "BEQ     loop_x_exit1                    ; No last pixel to be done\n");
      mask_possible = fetch_pixel(wp, ws, &ws->labels.x_lastmask);
      translate_pixel(wp, ws);
      save_pixel(wp, ws);
      if (mask_possible) DEFINE_LABEL(x_lastmask, "Last pixel masked out")
      fetch_pixel_inc(wp, ws);
      save_pixel_inc(wp, ws);

      DEFINE_LABEL(                                     loop_x_exit1, "End of input pixel line (1)")
#endif
    }
    else
    {
      comment(ws, "Control of scaling along x");
      if (ws->odither && wp->save_xadd - wp->save_xdiv > wp->save_xdiv)
      {
        /* If dithering and scaling we have to be very careful about where we do fetch_pixel_inc, because when replicating
         * a pixel we must repeatedly fetch_pixel it.
         */
        SUB_A(r_xcount, wp->save_xadd)
        DEFINE_LABEL(                                       loop_x_repeat, "Loop around for each source pixel (ordered dither)")
        ADD_A(r_xcount, wp->save_xadd)  /*(GPS)*/

        mask_possible = fetch_pixel(wp, ws, &ws->labels.l_masked);
        SUBS_A(r_xcount, wp->save_xdiv)  /* Stop dither from printing 1 too many pixels... (GPS) */
        DEFINE_LABEL(                                       loop_put_pixel_repeat, "Repeatedly paint and ordered-dither a source pixel");
        translate_pixel(wp, ws);
        save_pixel(wp, ws);
        save_pixel_inc(wp, ws);
        SUB(R(r_xsize), R(r_xsize), S | IMM(1),                    "SUBS    r_xsize,r_xsize,#1              ; count output ordered dither pixels");
        branch(ws, B | EQ, L(loop_x_exit),                         "BEQ     loop_x_exit                     ; painted enough pixels");
        /* We must not paint the same pixel repeatedly - we must reextract and retranslate it, otherwise
         * the dithering on scaled up pixels will not occur.
         */
        fetch_pixel_unmasked(wp, ws); /* reextract the pixel into r_pixel */
        SUBS_A(r_xcount, wp->save_xdiv)  /* Decrement count (GPS) */
        branch(ws, B | PL, L(loop_put_pixel_repeat),               "BPL     loop_put_pixel_repeat           ; recalculate and repaint");
        fetch_pixel_inc(wp, ws); /* moved by (GPS) */
        branch(ws, B, L(loop_x_repeat),                            "B       loop_x_repeat                   ; next input pixel");
      }
      else
      {
        if ( !PLOTMASK && (wp->save_xmag % wp->save_xdiv) == 0 && ((wp->save_xmag / wp->save_xdiv) > 4) && ws->gcol == 0)
                 /* do optimised code */
        {
          register int toskip = wp->save_xmag / wp->save_xdiv;

          tracef("in optimised scale\nxmag = %d, xdiv = %d, xmag mod xdiv = %d\n" _ wp->save_xmag _ wp->save_xdiv _ wp->save_xmag % wp->save_xdiv);
          SUB_A(r_xcount, toskip)
          DEFINE_LABEL(                                       loop_x_repeat, "3Loop around for each source pixel")
          TEQ(R(r_xsize), IMM(0),                                       "3TEQ     r_xsize, #0");
          DEFINE_LABEL(loop_x_exitskip,          "3Kludge to avoid multiple forward references");
          branch(ws, B | EQ, L(loop_x_exit),                      "3BEQ     loop_x_exit");
          ADD_A(r_xcount, toskip)
          mask_possible = fetch_pixel(wp, ws, &ws->labels.l_masked);
          translate_pixel(wp, ws); /* If we're about the discard the pixel this is in fact wasted work - we could reorganise
                                    * this whole loop to improve that situation, but it doesn't really seem worthwhile, the gain
                                    * is not enormous.
                                    */
          fetch_pixel_inc(wp, ws);

          comment(ws, "3calculating number of times to plot pixel 1");
          MOV(R(r_temp1), OP2R(R(r_xsize)),                            "3MOV     r_temp1, r_xsize               ; store r_xsize");
          SUB(R(r_xsize), R(r_xsize), S | OP2R(R(r_xcount)),            "3SUBS    r_xsize, r_xsize, r_xcount  ; count output pixels");
          MOV(R(r_xsize), MI | IMM(0),                                  "3MOVMI   r_xsize, #0                                          ");
          MOV(R(r_xcount), MI | OP2R(R(r_temp1)),                       "3MOVMI   r_xcount, r_temp1                                          ");

          if (!DEST_32_BIT)
          {
            MOV(R(r_temp1), S | OP2R(R(r_outshift)) | LSRI(27),           "3MOVS    r_temp1, r_outshift, LSR #27");
            MOV(R(r_temp1), EQ | IMM(32),                                 "3MOVEQ   r_temp1, #32                    ; 0 in r_outshift => 32 bits left");
            if (!DEST_1_BIT)
              MOV(R(r_temp1), OP2R(R(r_temp1)) | LSRI(wp->Log2bpc),       "3MOV     r_temp1, r_temp1, LSR #out_log2bpc");
            CMP(R(r_xcount), OP2R(R(r_temp1)),                            "3CMP     r_xcount, r_temp1");
            branch(ws, B + LT, L(loop2),                                  "3BLT     loop2                   ; end of this masked input pixel");
          }

          plot_current_output_words(wp, ws, toskip);

          if (DEST_32_BIT)
          {
            branch(ws, B, L(loop_x_repeat),                          "11B     loop_x_repeat                   ; end of this masked input pixel");
          }
          else
          {
            TEQ(R(r_xcount), IMM(0),                                      "1TEQ     r_xcount, #0");
            branch(ws, B + EQ, L(loop_x_repeat),                         "1BEQ     loop_x_repeat                   ; end of this masked input pixel");

            DEFINE_LABEL(loop2, "Last word to plot")
            plot_some_pixels(wp, ws);
            branch(ws, B, L(loop_x_repeat),                              "1B       loop_x_repeat                   ; end of this masked input pixel");
          }

        }
        else
        {
          /* >>> There's not all that much point in this being separate from the odither case - could really
           * abandon this one and use the ditering one all the time, with tiny variants. Not done.
           */
          SUB_A(r_xcount, wp->save_xadd)
          DEFINE_LABEL(                                       loop_x_repeat, "Loop around for each source pixel")
          ADD_A(r_xcount, wp->save_xadd)
          mask_possible = fetch_pixel(wp, ws, &ws->labels.l_masked);
          translate_pixel(wp, ws); /* If we're about the discard the pixel this is in fact wasted work - we could reorganise
                                    * this whole loop to improve that situation, but it doesn't really seem worthwhile, the gain
                                    * is not enormous.
                                    */
          fetch_pixel_inc(wp, ws);
          DEFINE_LABEL(loop_put_pixel_repeat, "Loop around to repeatedly paint a source pixel");
          SUBS_A(r_xcount, wp->save_xdiv)
          branch(ws, B | MI, L(loop_x_repeat),                       "BMI     loop_x_repeat                   ; discard this pixel");
          save_pixel(wp, ws);
          save_pixel_inc(wp, ws);
          SUB(R(r_xsize), R(r_xsize), S | IMM(1),                    "SUBS    r_xsize,r_xsize,#1              ; count for each output pixel");
          branch(ws, B | NE, L(loop_put_pixel_repeat),               "BNE     loop_put_pixel_repeat");
          branch(ws, B, L(loop_x_exit),                              "B       loop_x_exit              ; skip code for masked pixels");/* moved from next if (GPS) */
        }
      }
      if (mask_possible)
      {
        DEFINE_LABEL(l_masked, "This source pixel masked out")
        if (!PLOTMASK && (wp->save_xmag % wp->save_xdiv) == 0 && ((wp->save_xmag / wp->save_xdiv) > 4) && ws->gcol == 0)
        {
#if 1
          fetch_pixel_inc(wp, ws);

          comment(ws, "calculating number of times to plot pixel");
          MOV(R(r_temp1), OP2R(R(r_xsize)),                             "@MOV     r_xtemp1, r_xsize               ; store r_xsize");
          SUB(R(r_xsize), R(r_xsize), S | OP2R(R(r_xcount)),             "@SUBS    r_xsize, r_xsize, r_xcount  ; count output pixels");
          MOV(R(r_xsize), MI | IMM(0),                                  "@MOVMI   r_xsize, #0                                          ");
          MOV(R(r_xcount), MI | OP2R(R(r_temp1)),                       "@MOVMI   r_xcount, r_temp1                                          ");

          if (!DEST_32_BIT)
          {
            MOV(R(r_temp1), S | OP2R(R(r_outshift)) | LSRI(27),           "@@MOVS    r_temp1, r_outshift, LSR #27");
            MOV(R(r_temp1), EQ | IMM(32),                              "@@MOVEQ   r_temp1, #32                    ; 0 in r_outshift => 32 bits left");
            if (!DEST_1_BIT)
              MOV(R(r_temp1), OP2R(R(r_temp1)) | LSRI(wp->Log2bpc),       "@@MOV     r_temp1, r_temp1, LSR #log2bpc");
            CMP(R(r_xcount), OP2R(R(r_temp1)),                            "@@CMP     r_xcount, r_temp1");
            branch(ws, B + LT, L(loop1),                                  "@@BLT     loop1                   ; end of this masked input pixel");
          }

          skip_current_output_words(wp, ws);

          if (DEST_32_BIT)
          {
            branch(ws, B, L(loop_x_repeat),                         "1@B     loop_x_repeat                   ; end of this masked input pixel");
          }
          else
          {
            TEQ(R(r_xcount), IMM(0),                                     "1@TEQ     r_xcount, #0");
            branch(ws, B + EQ, L(loop_x_repeat),                        "1@BEQ     loop_x_repeat                   ; end of this masked input pixel");
            DEFINE_LABEL(loop1, "Last word to skip")
            skip_some_pixels(wp, ws);

            branch(ws, B, L(loop_x_repeat),                            "1@@B       loop_x_repeat                   ; end of this masked input pixel");
          }
#else
          int loop;

          fetch_pixel_inc(wp, ws);
          for (loop = 0;loop < (wp->save_xmag / wp->save_xdiv);loop++)
          {
            save_pixel_inc(wp, ws);
            SUB(R(r_xsize), R(r_xsize), S | IMM(1),                    "SUBS    r_xsize,r_xsize,#1              ; count output pixels");
            branch(ws, B | EQ, L(loop_x_exitskip),              "BEQ     loop_x_exitskip");
          }
          branch(ws, B, L(loop_x_repeat),                       "B       loop_x_repeat                   ; end of this masked input pixel");
#endif
        }
        else
        {
          fetch_pixel_inc(wp, ws);
          DEFINE_LABEL(loop_put_masked_repeat, "Loop around to skip over dest pixels");
          SUBS_A(r_xcount, wp->save_xdiv)
          branch(ws, B | MI, L(loop_x_repeat),                       "BMI     loop_x_repeat                   ; end of this masked input pixel");
          save_pixel_inc(wp, ws);
          SUB(R(r_xsize), R(r_xsize), S | IMM(1),                    "SUBS    r_xsize,r_xsize,#1              ; count output pixels");
          branch(ws, B | NE, L(loop_put_masked_repeat),              "BNE     loop_put_masked_repeat");
        }
      }
    }
    DEFINE_LABEL(                                     loop_x_exit, "End of input pixel line")
    newline();

    if (!DEST_32_BIT)
    {
      comment(ws, "End of x loop - ensure any contents of r_outword are written out.");
      MOV(R(r_outshift), S | OP2R(R(r_outshift)) | LSRI(27),     "MOVS    r_outshift,r_outshift,LSR #27   ; get real output shift distance");
      MOV(R(r_outshift), EQ | IMM(32),                           "MOVEQ   r_outshift,#32                  "
                                                                 "; number of useful new bits in r_outword");
      if (ws->gcol == 0 && !SOURCE_MASK)
      {
        /* If setting pixels we must pick up the word we're about to
         * partially overwrite, and combine the new and old pixels.
         */
        comment(ws, "The top 32-r_outshift bits of r_outword are new pixels.");
        MOV(R(r_outword), OP2R(R(r_outword)) | LSRR(R(r_outshift)),"MOV     r_outword,r_outword,LSR r_outshift ; get new pixels in correct place");
        ins(ws, LDR(R(r_pixel), R(r_outptr)) | OFFSET(0),        "LDR     r_pixel,[r_outptr]              ; temporary use of r_pixel");
        RSB(R(r_outshift), R(r_outshift), IMM(32),               "RSB     r_outshift,r_outshift,#32");
        MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRR(R(r_outshift)),  "MOV     r_pixel,r_pixel,LSR r_outshift  ; shift to clear out old pixels");
        ORR(R(r_outword), R(r_outword),
              OP2R(R(r_pixel)) | LSLR(R(r_outshift)),            "ORR     r_outword,r_outword,r_pixel, LSL r_outshift ; combine old and new");
        ins(ws, STR(R(r_outword), R(r_outptr)) | OFFSET(0),      "STR     r_outword,[r_outptr]            ; store updated word");
      }
      else
      {
        MOV(R(r_outword), OP2R(R(r_outword)) | RORR(R(r_outshift)),"MOV     r_outword,r_outword,ROR r_outshift");
        ins(ws, STR(R(r_outword), R(r_outptr)) | OFFSET(0),        "STR     r_outword,[r_outptr]");
      }
    }
  }
}

/**************************************************************************
*                                                                         *
*    Bitblit: Overall construction of the Y loop.                         *
*                                                                         *
**************************************************************************/

static void loop_y(asm_workspace *wp, workspace *ws, decompress_info_ptr cinfo)
/* Overall control of the code and outer loop */
{
  /* Declare the registers */
  int yrn;
  int x_loop_save_mask;
  int y_loop_save_mask;
  int ptrs_save_mask;    /* r_inptr, r_outptr, and (if it exists) r_maskinptr */
  int x_loop_save_size;
  int ptrs_save_size;
  BOOL onebank; /* one bank of registers, or two */
#ifdef DEBUG
  char xregs[256];
  char yregs[256];
  char ptrregs[256];
  char a[256];
#endif

  /* Various useful constants not provided directly by wp. */
  newline();
  comment(ws, "Various useful constants");
  if (DPIXEL_INPUT)
    comment(ws, "Double-pixel input - pixels are not the same as double-pixels");
  else
    comment(ws, "Not double-pixel input - pixels are exactly the same as double-pixels");
  ws->in_bpp         = 1 << wp->save_inlog2bpp;
  ws->in_bpc         = 1 << wp->save_inlog2bpc;
  ws->in_pixmask     = (1 << ws->in_bpp) - 1;
  tracef("%t20.in_bpp  *       %i %t68; bits per input pixel\n" _ ws->in_bpp);
  tracef("%t20.in_bpc  *       %i %t68; bits per input double-pixel ('character')\n" _ ws->in_bpc);
  if (ws->in_bpp <= 8) tracef("%t20.in_pixmask *    %i %t68; input pixel mask\n" _ ws->in_pixmask);

  if (SOURCE_MASK)
  {
    if (SOURCE_BPPMASK) /* a bit mask */
    {
      ws->mask_bpp     = 1;
      ws->mask_bpc     = 1;
      ws->mask_pixmask = 1;
    }
    else
    {
      ws->mask_bpp     = ws->in_bpp;
      ws->mask_bpc     = ws->in_bpc;
      ws->mask_pixmask = ws->in_pixmask;
    }
    tracef("%t20.mask_bpp *      %i %t68; bits per mask pixel\n" _ ws->mask_bpp);
    tracef("%t20.mask_bpc *      %i %t68; bits per mask double-pixel\n" _ ws->mask_bpc);
    tracef("%t20.mask_pixmask *  %i %t68; mask pixel mask\n" _ ws->mask_pixmask);
  }
  else
    comment(ws, "No input mask");

  if (DPIXEL_OUTPUT)
    comment(ws, "Double-pixel output - pixels are not the same as double-pixels");
  else
    comment(ws, "Not double-pixel output - pixels are exactly the same as double-pixels");
  ws->out_l2ppw      = 5 - wp->Log2bpc;
  ws->out_ppw        = 1 << ws->out_l2ppw;
  ws->out_pixmask    = (1 << wp->BPP) - 1;
  ws->out_dpixmask   = (1 << wp->BPC) - 1;
  tracef("%t20.out_bpp *       %i %t68; bits per output pixel\n" _ wp->BPP);
  tracef("%t20.out_bpc *       %i %t68; bits per output double-pixel\n" _ wp->BPC);
  tracef("%t20.out_l2bpp *     %i %t68; log base 2 of bits per output pixel\n" _ wp->Log2bpp);
  tracef("%t20.out_l2bpc *     %i %t68; log base 2 of bits per output double-pixel\n" _ wp->Log2bpc);
  tracef("%t20.out_ppw *       %i %t68; double-pixels per output word\n" _ ws->out_ppw);
  tracef("%t20.out_l2ppw *     %i %t68; log base 2 of double-pixels per output word\n" _ ws->out_l2ppw);
  if (wp->BPC <= 8)
  {
    tracef("%t20.out_pixmask *   %i %t68; output pixel mask\n" _ ws->out_pixmask);
    tracef("%t20.out_dpixmask *  %i %t68; output double-pixel mask\n" _ ws->out_dpixmask);
  }

  /* Setting up ordered dither, if required */
  if (ws->odither)
  {
    tracef("in dither_truecolour = %x\n" _ wp->dither_truecolour);
    comment(ws, "Ordered dither being used");
    /* If not 0 then ws->odither is the number of bits - 1 being truncated from 8-bit source colour values */
    if(wp->Log2bpp > 3)
    {
      /* Use the number of blue bits in the output as our guide */
      ws->odither = 7-pixelformat_info(ws->out_pixelformat)->bits[0];
    }
    else
    {
      /* dithering down to 1/2/4/8 bit. */
      if (wp->Log2bpp == 3) /* 8bpp */
      {
        if (wp->is_it_jpeg && cinfo->jpeg_color_space == CS_GRAYSCALE)
          ws->odither = 3; /* dither assuming 4 bits of grey represented */
        else
          ws->odither = 4; /* seems to work better for colour than 3, which is what you might expect if
                            * you were assuming 4 bits of colour per gun. In other words, the tint is NOT
                            * effective enough at representing the next two bits of colour output!
                            * If the source is known to be greyscale then 3 is a better value.
                            */
      }
      else
        ws->odither = 6 - wp->Log2bpp; /* 6, 5 or 4 for 2, 4, or 16 colour output (2, 4 or 8 grey level) */
    }
    tracef("%t20.odither_eorvalue * 1:SHL:(24+%i) %t68; value to EOR into r_oditheradd each pixel" _ ws->odither);
  }
    tracef("out dither_truecolour = %x\n" _ wp->dither_truecolour);

  newline();
  ins(ws, PUSH | 0x5fff,                                    "STMDB   sp!,{r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,lr} ; save entry registers");
  newline();

  comment(ws, "Register declarations");
  if (wp->is_it_jpeg)
  {
    ws->leave_r12_alone = TRUE;
    comment(ws, "Leave r12 unallocated, it contains the assembler module workspace pointer");
  }
  ptrs_rn(wp, ws);
  ptrs_save_mask = (1<<ws->next_free_reg) - 1;
  IFDEBUG(ldm_reg_list(ws, ptrregs, ptrs_save_mask, FALSE);)
  ptrs_save_size = SOURCE_BPPMASK || PLOTMASK ? 12 : 8;
  if (ws->odither) ptrs_save_size += 4;

  xloop_rn(wp, ws);
  x_loop_save_mask = ((1<<ws->next_free_reg) - 1) & ~ptrs_save_mask;
  x_loop_save_size = 4 * ws->next_free_reg - ptrs_save_size;      /* size in bytes, used right at the end */
  /* Of the x-loop variables, no need to save r_inword/outword/maskinword/temp1/temp2 - set up every time round */
  if (ws->regnames.r_inword.regno != -1) {x_loop_save_mask &= ~(1 << ws->regnames.r_inword.regno); x_loop_save_size -= 4;}
  if (ws->regnames.r_outword.regno != -1) {x_loop_save_mask &= ~(1 << ws->regnames.r_outword.regno); x_loop_save_size -= 4;}
  if (ws->regnames.r_maskinword.regno != -1) {x_loop_save_mask &= ~(1 << ws->regnames.r_maskinword.regno); x_loop_save_size -= 4;}
  if (ws->regnames.r_temp1.regno != -1) {x_loop_save_mask &= ~(1 << ws->regnames.r_temp1.regno); x_loop_save_size -= 4;}
  if (ws->regnames.r_temp2.regno != -1) {x_loop_save_mask &= ~(1 << ws->regnames.r_temp2.regno); x_loop_save_size -= 4;}
  IFDEBUG(ldm_reg_list(ws, xregs, x_loop_save_mask, FALSE);)

  yrn = yloop_rn_count(wp, ws);
  onebank = yrn + ws->next_free_reg + ws->leave_r12_alone <= 13;
  comment(ws, onebank ? "The y loop variables will fit in registers too"
                      : "The y loop variables are overlaid on the x ones");
  if (!onebank) ws->next_free_reg = 4; /* Overlay the x-loop register allocations - but not ptr registers */
  yloop_rn(wp, ws);
  if (!onebank) /* If two banks, be prepared to do LDM/STM for the y-loop bank */
  {
    y_loop_save_mask = ((1<<ws->next_free_reg) - 1) & 0xfffffff0; /* not regs 0..3 */
    IFDEBUG(ldm_reg_list(ws, yregs, y_loop_save_mask, TRUE);)
  }
  newline();

  comment(ws, "Load up initial values of x-loop variables");
  fetch_pixel_init(wp, ws);
  save_pixel_init(wp, ws);
  xloop_init(wp, ws);

  tracef("%t20.x_loop_save_size * %t28%i %t68.; Bytes of stack for x-loop variables\n" _ x_loop_save_size);
  tracef("%t20.ptrs_save_size * %t28%i %t68.; Bytes of stack for ptr variables\n" _ ptrs_save_size);
  comment(ws, "Save x-loop and pointer variables on the stack");
  IFDEBUG(do_sprintf(a, "STMDB   sp!,{%s,%s}", ptrregs,xregs);)
  /* Added by (GPS) to get round spilled reg bug. */
  if(ws->odither && SOURCE_16_BIT)
  {
    tracef("x_loop_save_mask = %x\n" _ x_loop_save_mask);
    x_loop_save_mask &= ~(1<<(ws->regnames.r_xcount.regno));
    x_loop_save_mask |= (1<<(ws->regnames.r_pixel.regno));
    tracef("x_loop_save_mask = %x\n" _ x_loop_save_mask);
    ins(ws, PUSH | x_loop_save_mask | ptrs_save_mask, a);
    x_loop_save_mask |= (1<<(ws->regnames.r_xcount.regno));
    x_loop_save_mask &= ~(1<<(ws->regnames.r_pixel.regno));
    comment(ws, "r_pixel pushed instead of x-count");
#ifdef DEBUG
    tracef("x_loop_save_mask = %x\n" _ x_loop_save_mask);
#endif
  }
  else
  {
    ins(ws, PUSH | x_loop_save_mask | ptrs_save_mask, a);
  }
  /* end added code...*/

  newline();

  comment(ws, "Load up initial values of y-loop variables");
  yloop_init(wp, ws);

  if(ws->odither && SOURCE_16_BIT)
  {
    MOV(R(r_xcount), OP2R(R(r_pixel)),                              "MOV     r_xcount,r_pixel                           ; set r_xcount to correct value");
  }

  if (!simple_y_scale(wp, ws)) /* If not simple scaling, might not paint the first row */
    branch(ws, B, L(y_loop_enter),                          "B       y_loop_enter                    ; enter the main loop");

  /* Top of the y-loop */
  newline();
  DEFINE_LABEL(y_loop,                        "Loop around for each row")

  if (!simple_y_scale(wp, ws))
  {
    comment(ws, "At this point the ptr registers have been updated but not saved");
    IFDEBUG(do_sprintf(a,                                      "STMIA   sp,{%s}", ptrregs);)
    ins(ws, STMIA(R(sp)) | ptrs_save_mask, a);
  }

  if (wp->is_it_jpeg)
  {
    comment(ws, "r_inptr is the source y coord for JPEG data: convert to data pointer");
    comment(ws, "fetchroutine uses r_inptr(=r0), r12. On output r_inptr=source result pointer");
    if(wp->CPUFlags & CPUFlag_BLX)
    {
      BLX(R(r_fetchroutine),                                  "BLX     r_fetchroutine                  ; get source address");
    }
    else
    {
      MOV(R(lr), OP2R(R(pc)),                                 "MOV     lr,pc                           ; remember return address from fetchroutine");
      MOV(R(pc), OP2R(R(r_fetchroutine)),                     "MOV     pc,r_fetchroutine               ; get source address");
    }
    LDR_WP_C(lr, in_x, "returned value is for base of line - add initial offset")
    if (wp->save_inlog2bpp < 5)
    {
      if (wp->save_inlog2bpp == 3)
        ADD(R(r_inptr),R(r_inptr),OP2R(R(lr)),                "ADD     r_inptr,r_inptr,lr              ; add in_x as byte offset");
      else
        ADD(R(r_inptr),R(r_inptr),OP2R(R(lr)) | LSLI(1),      "ADD     r_inptr,r_inptr,lr,LSL#1        ; add in_x as halfword offset");
      BIC(R(r_inptr),R(r_inptr),IMM(3),                     "BIC     r_inptr,r_inptr,#3              ; r_inptr is a word pointer");
    }
    else
      ADD(R(r_inptr),R(r_inptr),OP2R(R(lr)) | LSLI(2),      "ADD     r_inptr,r_inptr,lr,LSL#2        ; add in_x as word offset");
  }

  if (!onebank)
  {
    /* the x-loop variables are already set up, with inptr/outptr/maskinptr saved at new values */
    ADD(R(lr), R(sp), IMM(ptrs_save_size),                  "ADD     lr,sp,#ptrs_save_size");
    IFDEBUG(do_sprintf(a,                                      "STMDB   sp!,{%s} %t40; push y-loop variables", yregs);)
    ins(ws, PUSH | y_loop_save_mask, a);
    IFDEBUG(do_sprintf(a,                                      "LDMIA   lr,{%s} %t40; load x-loop variables", xregs);)
    ins(ws, LDMIA(R(lr)) | x_loop_save_mask, a); /* Reload the x-loop variables */
  }
  newline();

  /* Generate the inner loop. */
  loop_x(wp, ws);

  /* Suitable register 'bank' swapping. */
  if (onebank)
  {
    IFDEBUG(do_sprintf(a,                                      "LDMIA   sp,{%s,%s} %t40; reload x-loop and ptr registers", ptrregs, xregs);)
    ins(ws, LDMIA(R(sp)) | x_loop_save_mask | ptrs_save_mask, a);
  }
  else
  {
    IFDEBUG(do_sprintf(a,                                      "LDMIA   sp!,{%s} %t40; pop y-loop variables", yregs);)
    ins(ws, POP | y_loop_save_mask, a);
    newline();
    comment(ws, "Reload pointers to the start of a row");
    IFDEBUG(do_sprintf(a,                                      "LDMIA   sp,{%s} %t40; reload ptr registers", ptrregs);)
    ins(ws, LDMIA(R(sp)) | ptrs_save_mask, a);
  }

  /* Control of scaling in the y direction */
  if (simple_y_scale(wp, ws))
  {
    comment(ws,                                      "1:1 scaling in y direction - each source row appears once");
    if (!PLOTMASK)
    {
      if (wp->is_it_jpeg)
        ADD(R(r_inptr), R(r_inptr), IMM(1),                 "ADD     r_inptr,r_inptr,#1               ; inc y coord of input JPEG data");
      else
        SUB(R(r_inptr), R(r_inptr), OP2R(R(r_inoffset)),    "SUB     r_inptr,r_inptr,r_inoffset");
    }
    SUB_A(r_outptr,wp->save_outoffset)                     /*SUB     r_outptr,r_outptr,#outoffset*/
    odither_inc(wp, ws, 1); /* advance to next coord */
    odither_inc(wp, ws, 0); /* ensure X coord phase alternates on alternate lines */
    if (SOURCE_BPPMASK || PLOTMASK)
      SUB(R(r_maskinptr), R(r_maskinptr),
          OP2R(R(r_maskinoffset)),                          "SUB     r_maskinptr,r_maskinptr,r_maskinoffset");
    IFDEBUG(do_sprintf(a,                                      "STMIA   sp,{%s} %t40.; Save updated ptr registers", ptrregs);)
    ins(ws, STMIA(R(sp)) | ptrs_save_mask, a);
    SUB(R(r_ysize), R(r_ysize), S | IMM(1),                 "SUBS    r_ysize,r_ysize,#1              ; decrement output pixel size");
    branch(ws, B | GT, L(y_loop),                           "BGT     y_loop");
  }
  else
  {
    SUB(R(r_ysize), R(r_ysize), S | IMM(1),                 "SUBS    r_ysize,r_ysize,#1");
    branch(ws, B | LE, L(y_loop_exit),                      "BLE     y_loop_exit");
    SUB_A(r_outptr,wp->save_outoffset)                     /*SUB     r_outptr,r_outptr,#outoffset*/
    odither_inc(wp, ws, 1);
    odither_inc(wp, ws, 0);

    if (PLOTMASK)
    {
      comment(ws,                                    "Advance ECF pointer");
      LDR_WP(r_pixel, save_ecflimit);                      /*LDR     r_pixel,save_ecflimit*/
      CMP(R(r_inptr), OP2R(R(r_pixel)),                     "CMP     r_inptr,r_pixel                 ; check for bottom of ECF");
      ADD(R(r_inptr), R(r_inptr), EQ | IMM(64),             "ADDEQ   r_inptr,r_inptr,#64             ; and if reached, reset to top");
      SUB(R(r_inptr), R(r_inptr), IMM(8),                   "SUB     r_inptr,r_inptr,#8              ; points to base of current row of ECF");
    }
    comment(ws,                                      "Control of scaling in y direction");
    DEFINE_LABEL(                                    y_loop_enter,  "Initial entry into the loop")
    SUBS_A(r_ycount, wp->save_ydiv)                        /*SUBS    r_ycount,r_ycount,#ydiv*/
    branch(ws, B | PL, L(y_loop),                           "BPL     y_loop                          ; if count>=0 then B else next source row");
    if (!PLOTMASK)
    {
      if (wp->is_it_jpeg)
        ADD(R(r_inptr), R(r_inptr), IMM(1),                 "ADD     r_inptr,r_inptr,#1              ; inc y coord of source JPEG data");
      else
        SUB(R(r_inptr), R(r_inptr), OP2R(R(r_inoffset)),    "SUB     r_inptr,r_inptr,r_inoffset      ; next source row");
    }
    if (SOURCE_BPPMASK || PLOTMASK)
      SUB(R(r_maskinptr), R(r_maskinptr),
          OP2R(R(r_maskinoffset)),                          "SUB     r_maskinptr,r_maskinptr,r_maskinoffset ; advance input mask pointer");
    ADD_A(r_ycount, wp->save_ydiv + wp->save_yadd)         /*ADD     r_ycount,r_ycount,#(ydiv+yadd)*/
    branch(ws, B, L(y_loop_enter),                          "B       y_loop_enter                    ; reenter the main loop");
    DEFINE_LABEL(y_loop_exit,                  "Exit from y loop")
  }
  newline();
  comment(ws, "Discard workspace, restore registers, and exit");

  ADD(R(sp), R(sp), IMM(x_loop_save_size+ptrs_save_size),   "ADD     sp,sp,#x_loop_save_size+ptrs_save_size ; discard saved x-loop variables");

  ins(ws, POP | 0x5fff,                                     "LDMIA   sp!,{r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,lr} ; restore, exit");

  MOV(R(pc), OP2R(R(lr)),         "MOV   pc, lr");
}

/**************************************************************************
*                                                                         *
*    Bitblit: The main compiler entry points.                             *
*                                                                         *
**************************************************************************/

static blitter find_or_compile_code(asm_workspace *wp, workspace *ws, decompress_info_ptr cinfo)
/* Based on the workspace variables look through existing compiled buffers for an existing match */
{
  code_buffer *p;
  int key_word;

  key_word = get_key_word(wp,ws);

#ifdef ASMjpeg
  if (wp->is_it_jpeg) key_word |= 1<<23;
  if (wp->is_it_jpeg && cinfo->jpeg_color_space == CS_GRAYSCALE) key_word |= 1<<24;
#endif
  if (wp->cal_table)
  {
    key_word |= 1<<25;
    if (ws->cal_table_simple) key_word |= 1<<26;
    if (wp->cal_table->tablecount == 3) key_word |= 1<<27;
  }
#ifdef ASMjpeg
  if (wp->is_it_jpeg && (wp->dither_truecolour & 1)) key_word |= 1<<28;
  if (wp->is_it_jpeg && (wp->dither_truecolour & 2)) key_word |= 1<<29;
#endif
  if (  !PLOTMASK                        /* if plotting sprite */
     && wp->save_inlog2bpp >= 4          /* from true colour source */
     && wp->Log2bpp < wp->save_inlog2bpp /* and losing resolution (note; dithering 16bpp down to 15/12bpp not supported, so checking these values instead of PixelFormat values is OK) */
     && (wp->dither_truecolour & 1)      /* and dithering requested */
     && !(wp->is_it_jpeg && (wp->dither_truecolour & 2)) /* And not JPEG scaled error diffused dither */
     )
  {
    ws->odither = 1; /* Flag that ordered dithering is required */
    key_word |= 1<<30; /* And flag this routine as containing dither code */
  }
  tracef("Searching for compiled code for key_word=%x, scale=%i:%i,%i:%i outoffset=%x.\n" _
    key_word _ wp->save_xadd - wp->save_xdiv _ wp->save_xdiv _ wp->save_yadd _ wp->save_ydiv _ wp->save_outoffset);
  tracef("simple_x_scale=%s x_block_move=%s jpeg=%s calibration table=0x%x dither_truecolour=%i\n"
        _ whether(simple_x_scale(wp, ws))
        _ whether(x_block_move(wp, ws))
        _ whether(wp->is_it_jpeg)
        _ wp->cal_table
        _ wp->dither_truecolour);
  FOR_EACH_BUFFER(p)
    if (  p->key_word == key_word
       && p->xadd == wp->save_xadd
       && p->xdiv == wp->save_xdiv
       && p->yadd == wp->save_yadd
       && p->ydiv == wp->save_ydiv
       && p->outoffset == wp->save_outoffset
       )
     {
       tracef("Found existing compiled code in buffer %x.\n" _ p);

       return (blitter)p->code;
     }
  p = &ws->buffers[ws->build_buffer];
  p->key_word = -1; /* Not set unless we complete the compilation - see below */
  p->xadd = wp->save_xadd;
  p->xdiv = wp->save_xdiv;
  p->yadd = wp->save_yadd;
  p->ydiv = wp->save_ydiv;
  p->outoffset = wp->save_outoffset;
  tracef("Compiler initialised for buffer at %x.\n" _ p);
  compile_buffer_init(wp, ws);

  /* Now we actually do the compile */
  loop_y(wp, ws, cinfo);

  compile_buffer_done(ws);
  p->key_word = key_word;

  /* Just did some dynamic code generation so flush the I cache */
  _swix(OS_SynchroniseCodeAreas, _IN(0) | _IN(1) | _IN(2), 1,
        (int)ws->compile_base, (int)ws->compile_base + ((BUFSIZE - 1 /* Inclusive */) * sizeof(int)));

  return (blitter)ws->compile_base;
}

blitter putscaled_compiler(asm_workspace *wp, workspace *ws, workspace *ws_end, int gcol)
/* Main entrypoint from the assembler */
{
  decompress_info_ptr cinfo = NULL;
  int                 i, j;
  blitter             result;

  /* Check that the assembler has an adequate opinion of our workspace needs. */
  tracef("wp=%x ws=%x ws_end=%x.\n" _ wp _ ws _ ws_end);
  tracef("Size of assembler workspace: %i.\n" _ ((char*)ws) - ((char*)wp));
  tracef("Size of C workspace: %i.\n" _ ((char*)ws_end) - ((char*)ws));
  assert(ws_end > ws, ERROR_FATAL);
  check_workspace(ws);
  IFDEBUG(dump_asm_workspace(wp);)

  ws->gcol = gcol & 7;
  ws->masked = (gcol & 8) != 0;/* || PLOTMASK;*/
  ws->mask1bpp = ws->masked & (((wp->save_mode) >> 27) != SpriteType_Old);
  ws->odither = FALSE; /* Set more carefully later. */
  tracef("gcol=%i (& 7 = %i)       %t32. GCOL action - 0 for plot, 1..7 for various others.\n" _ gcol _ gcol & 7);
  tracef("masked=%s                %t32. whether to use mask.\n" _ whether(ws->masked));
  tracef("1bpp mask=%s             %t32. whether mask is new format.\n" _ whether(ws->mask1bpp));

#ifdef ASMjpeg
  if (wp->is_it_jpeg)
  {
    sprite_header *s = wp->save_sprite;
    int  *compress_id_word = (int*)((char*) s + s->image); /* The first word of the sprite data */
    const JOCTET *jpeg_data;
    int   jpeg_data_size, jpeg_ws_size;
    int   opt, err, xmax;
    
    assert(compress_id_word[0] == -1, ERROR_BAD_JPEG);
    tracef("This JPEG sprite was constructed by PutJPEGScaled\n");
    jpeg_data = (const JOCTET *)compress_id_word[1];
    jpeg_data_size = compress_id_word[2];
    jpeg_ws_size = compress_id_word[3];
    check_jpeg_workspace(wp, jpeg_ws_size);
    cinfo = wp->jpeg_info_ptr;

    assert(wp->save_inlog2bpp == 5, ERROR_FATAL);          /* 32bpp source */
    assert(!SOURCE_MASK, ERROR_FATAL);                     /* no mask */
    tracef("JPEG, initial source coords are %i,%i.\n" _ wp->in_x _ wp->in_y);
    if ((wp->save_mode >> 27) == 0)
    {
      /* Old-style mode - make sure no translation table present. */
      wp->ColourTTR = 0;                                   /* >>>> mainly for JPEG on RO3 */
      wp->trns_palette = 0;                                /* >>>> mainly for JPEG on RO3 */
    }

    /* Deduce the decompression options */
    opt = jpeg_decompressor_opts(cinfo, wp);
    
    /* Reverse scaling calculation */ 
    xmax = wp->in_x + 2 + (wp->save_xsize * wp->save_xdiv) / (wp->save_xadd - wp->save_xdiv);
    if (xmax < 0) xmax = s->width; /* set safe xmax if reverse scale calculation overflowed */

    /* Initialise the decompressor */
    err = jpeg_scan_file(cinfo, jpeg_data, jpeg_data_size, wp->in_x, xmax, -1, -1, opt);
    assert(err == 0, ERROR_BAD_JPEG);

    /* Check the decompressor agreed with proposed output options */
    if (cinfo->error_argument1 & (jopt_OUTBPP_8 | jopt_OUTBPP_8YUV | jopt_OUTBPP_8GREY)) /* we asked for it, and we got it - 8bpp output pixels */
    {
      tracef("actually doing new shiny 8BPP plotting technique\n");
      wp->save_inlog2bpp = wp->save_inlog2bpc = 3;
      wp->ColourTTR = 0;
    }
    else
    {
      if (cinfo->error_argument1 & jopt_OUTBPP_16) /* we asked for it, and we got it - 16bpp output pixels */
        wp->save_inlog2bpp = wp->save_inlog2bpc = 4;
    }

    /* If error diffusion isn't supported, clear the flag so that we'll fall back to ordered dither */
    if(!(cinfo->options & jopt_DIFFUSE))
      wp->dither_truecolour &= ~2;
  }
#endif

  ws->out_pixelformat = compute_pixelformat(wp->ncolour,wp->modeflags,wp->Log2bpp);

#ifdef ASMjpeg
  if (wp->is_it_jpeg)
  {
    /* Work out what format we're being given
       This is deduced by following the same logic in do_3_component_band and jpeg_find_line */
    if(cinfo->options & jopt_DIFFUSE)
    {
      /* Error diffusion means we should have data in either an 8bpp or 32bpp container, and that data will be 8bpp (or lower) palette indices matching the required output format */
      ws->in_pixelformat = ws->out_pixelformat;
    }
    else if(cinfo->options & jopt_OUTBPP_8GREY)
    {
      /* 8bpp greyscale values packed in 8 bits. Should only be possible if destination is 8bpp with 0=black, 255=white. */
      assert(ws->out_pixelformat == PixelFormat_8bpp, ERROR_FATAL);
      ws->in_pixelformat = PixelFormat_8bpp;
    }
    else if(cinfo->options & jopt_GREY)
    {
      /* 24bpp greyscale values packed in 32 bits */
      ws->in_pixelformat = PixelFormat_24bpp_Grey;
    }
    else if(cinfo->options & jopt_OUTBPP_16)
    {
#ifdef ASMCOLOR
      /* Assembler version should produce exactly what we need */
      ws->in_pixelformat = ws->out_pixelformat;
#else
      /* Only 15bpp &BGR colour for C version */
      ws->in_pixelformat = PixelFormat_15bpp;
#endif
      /* 16bpp output is only enabled when JPEG is handling the dithering */
      wp->dither_truecolour &= ~3; 
    }
    else if(cinfo->options & jopt_OUTBPP_8YUV)
    {
      /* 8bpp colour in VIDC1 format. This should match the output format (i.e. screen format). */
      ws->in_pixelformat = PixelFormat_8bpp;
    }
    else
    {
      /* 24bpp colour, &BGR */
      ws->in_pixelformat = PixelFormat_32bpp;
    }
  }
  else
#endif
  {
    /* Pull apart the sprite mode word to deduce our pixel format value */
    int in_modeflags,in_ncolour;
    _swix(OS_ReadModeVariable,_INR(0,1)|_OUT(2),wp->save_mode,VduExt_ModeFlags,&in_modeflags);
    _swix(OS_ReadModeVariable,_INR(0,1)|_OUT(2),wp->save_mode,VduExt_NColour,&in_ncolour);
    ws->in_pixelformat = compute_pixelformat(in_ncolour,in_modeflags,wp->save_inlog2bpp);
  }

  /* Fudge - if input data >=32bpp (including JPEG), assume ColourTTR index values are 15bpp
     Else assume ColourTTR index values are same as source pixels, minus alpha
     Really the assembler code should tell us what format it is */
  if(wp->ColourTTR != 0)
  {
    if(wp->save_inlog2bpp >= 5)
      ws->ColourTTRFormat = PixelFormat_15bpp;
    else
      ws->ColourTTRFormat = ws->in_pixelformat & ~PixelFormat_Alpha;
  }

  ws->pixel_expansion_mask = ws->pixel_expansion_shift = 0;
  ws->pixel_expansion_in = ws->pixel_expansion_out = NULL;

#ifdef DEBUG
  /* Additional mask tracing */
  if (PLOTMASK)
  {
    char *p;
    int  *ecf = (int*) wp->save_ecflimit;

    tracef("Sprite data:\n");
    p = (char*) wp->save_inptr;
    for (i = 0; i < 16; i++)
    {
      tracef("%x" _ p);
      for (j = 0; j < 16; j++) tracef(" %2x" _ p[j]);
      newline();
      p -= wp->save_inoffset; /* convert from byte offset to int offset */
    }

    tracef("Mask data:\n");
    p = (char*) (SOURCE_BPPMASK ? wp->save_maskinptr : (int) wp->save_inptr + wp->save_masko);
    for (i = 0; i < 16; i++)
    {
      tracef("%x" _ p);
      for (j = 0; j < 16; j++) tracef(" %2x" _ p[j]);
      newline();
      p -= wp->save_inoffset;
    }

    tracef("ECF pattern:\n");
    for (i = 0; i <= 8; i++)
      tracef("%x: %c %x %x\n" _ ecf + 2*i _ (ecf+2*i == (int*)wp->save_ecfptr ? '>' : ' ') _ ecf[2*i] _ ecf[2*i + 1]);
  }
#endif

  if (wp->cal_table)
  {
    calibration_table *t = wp->cal_table;

    ws->cal_table_simple = t->idealblack == 0 && t->idealwhite == 0xffffff00 && t->postprocessSWI == 0;
#ifdef DEBUG
    tracef("Calibration table at 0x%x: version=%i idealblack=0x%x idealwhite=0x%x postprocessSWI=0x%x tablecount=%i simple=%s.\n"
      _ t->version _ t->idealblack _ t->idealwhite _ t->postprocessSWI _ t->tablecount _ whether(ws->cal_table_simple));
    for (i = 0; i < 256; i++) tracef(" %i" _ t->redtable[i]); newline();
    if (t->tablecount == 3) for (i = 0; i < 256; i++) tracef(" %i" _ t->greentable[i]); newline();
    if (t->tablecount == 3) for (i = 0; i < 256; i++) tracef(" %i" _ t->bluetable[i]); newline();
#endif
    assert(wp->BPP == 32, ERROR_FATAL);              /* only to 32 bit dest */
    assert(wp->save_inlog2bpp >= 4, ERROR_FATAL);    /* only from 16 or 32 bit source */
    assert(!SOURCE_TABLE, ERROR_FATAL);              /* there isn't room for a calibration table and another table - they share r_table */
    assert(t->version == 0, ERROR_FATAL);            /* check version number of lookup table */
  }

  /* If using a palette, ignore any translation table */
  if (wp->trns_palette != 0) wp->ColourTTR = 0;

  /* Simplify scale factors - >>> is this useful? Helps spot 1:1 scaling I guess? */
  assert(wp->save_xadd > 0, ERROR_FATAL);
  assert(wp->save_xdiv > 0, ERROR_FATAL);
  assert(wp->save_ydiv > 0, ERROR_FATAL);
  assert(wp->save_ydiv > 0, ERROR_FATAL);
  while ((wp->save_xadd & 1) == 0 &&
         (wp->save_xdiv & 1) == 0 &&
         (wp->save_xcount & 1) == 0 &&
         (wp->save_xmag & 1) == 0)
  {
    wp->save_xadd >>= 1; wp->save_xdiv >>= 1;
    wp->save_xcount >>= 1; wp->save_xmag >>=1;
  }
  while ((wp->save_yadd & 1) == 0 &&
         (wp->save_ydiv & 1) == 0 &&
         (wp->save_ycount & 1) == 0)
  {
    wp->save_yadd >>= 1; wp->save_ydiv >>= 1;
    wp->save_ycount >>= 1;
  }

  /* Look for unit translation table */
#ifdef DEBUG
  if (wp->ColourTTR != 0 && wp->BPP == (1<<wp->save_inlog2bpp)) /* only if table, and depth matches */
  {
    char *t = (char*) wp->ColourTTR;
    BOOL  same = TRUE;
    int   size = 1 << (1 << (wp->save_inlog2bpp == 5 ? 4 : wp->save_inlog2bpp));

    if (wp->save_xsize * wp->save_ysize > size) /* Unless huge table for tiny sprite */
    {
      for (i = 0; i < size; i++)
        if (t[i] != i) {same = FALSE; break;}
      if (same)
      {
        tracef("Unit translation table - discarded\n");
        wp->ColourTTR = 0;
        assert(0, ERROR_FATAL); /* These are now zapped by the assembler, so they shouldn't ever turn up. */
      }
    }
  }
#endif

  /* Precise handling of double-pixel modes by the surrounding code is still unclear to me!
   * When it enters this code bpc!=bpp can still be the case, but it seems that the actual
   * value of bpc is best ignored, it has all been frigged into the scale factors. Avoid
   * this issue for now, but note that we must set the values back afterwards because they
   * can be reused on the next sprite plot, if the source sprite mode word is the same.
   */
  i = wp->BPC;
  j = wp->save_inlog2bpc;
  wp->BPC = wp->BPP;
  wp->save_inlog2bpc = wp->save_inlog2bpp;
  result = find_or_compile_code(wp, ws, cinfo);
  wp->BPC = i;
  wp->save_inlog2bpc = j;

  return result;
}
#endif

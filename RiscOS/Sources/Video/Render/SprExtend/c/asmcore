/* Copyright 2013 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Common code for dealing with code generation and pixel format conversion

   The code here is used by both PutScaled and SprTrans

 */

#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include "swis.h"
#include "commondefs.h"
#include "jinclude.h"
#include "putscaled.h"
#include "Global/Sprite.h"
#include "Global/VduExt.h"

/**************************************************************************
*                                                                         *
*    Macros.                                                              *
*                                                                         *
**************************************************************************/

#define SOURCE_32_BIT  (wp->save_inlog2bpp == 5)
#define SOURCE_16_BIT  (wp->save_inlog2bpp == 4)
#define SOURCED_16_BIT (wp->save_inlog2bpc == 4) /* like SOURCE_16_BIT but includes 16-bit double-pixels */
#define SOURCE_MASK    (ws->masked)
#define SOURCE_BPPMASK (ws->mask1bpp)
#define SOURCE_TABLE   ((wp->ColourTTR != 0) || (wp->trns_palette != 0))

#define DPIXEL_INPUT   (wp->save_inlog2bpp != wp->save_inlog2bpc)
#define DPIXEL_OUTPUT  (wp->BPP != wp->BPC)

#define PLOTMASK       ((wp->spritecode & 255) == SpriteReason_PlotMaskScaled)
#define TRANSMASK       ((wp->spritecode & 255) == SpriteReason_PlotMaskTransformed)
#define ISTRANS        (TRANSMASK || ((wp->spritecode & 255) == SpriteReason_PutSpriteTransformed))

#define DEST_32_BIT    (wp->BPP == 32)
#define DEST_16_BIT    (wp->BPP == 16)
#define DEST_1_BIT     (wp->BPC == 1)
#define DESTD_16_BIT   (wp->BPC == 16) /* like DEST_16_BIT but includes 16-bit double-pixels */

/**************************************************************************
*                                                                         *
*    Low-level debugging output.                                          *
*                                                                         *
**************************************************************************/

#ifdef DEBUG
#define tracef(args)     do_sprintf(0, args)
#define assert(x, y)     do_assert(__LINE__, x, y, NULL)
#define newline()        tracef("\n");
#define comment(ws,text) do_comment(text)
#define IFDEBUG(a) a
#include "tracing.c"
#define COMPONENT_NAME(i) ((i==0?"red":(i==1?"green":(i==2?"blue":"alpha"))))
#else
#define tracef(args)     /* Nothing */
#define assert(x, y)     {if (!(x)) exit_erl(y, __LINE__);}
#define newline()        /* Nothing */
#define comment(ws,text) /* Nothing */
#define IFDEBUG(a)       /* Nothing */
#endif

/* Make a string constant unique to avoid Norcroft messing it up
   This is something we can fall back to if we decide calling __RelocCode is a
   bad thing (but it would involve touching lots of strings to add the call, so
   for now laziness wins) */
#define UQ(X) (X "\000" RUNMACRO(__LINE__,TOSTRING))
#define TOSTRING(X) #X
#define RUNMACRO(X,Y) Y(X)

/**************************************************************************
*                                                                         *
*    C Workspace declarations.                                            *
*                                                                         *
**************************************************************************/

/* Code buffers */
#define NBUFFERS 8       /* Number of code buffers */
#define BUFSIZE 256      /* words per buffer */
typedef struct
{
  int key_word;              /* descriptor for this code, or -1 if empty */
  int xadd;                  /* precise scale factors compiled into this code */
  int xdiv;
  int yadd;
  int ydiv;
  int outoffset;             /* output row offset compiled into this code */
  int code[BUFSIZE];         /* the code itself */
} code_buffer;
#define FOR_EACH_BUFFER(ptr) for (ptr = &ws->buffers[0]; ptr < &ws->buffers[NBUFFERS]; ptr++)

/* Labels - there's one of these for each label in the source we generate. */
typedef struct
{
  int *def;          /* where the label is, or 0 if not yet defined. */
  int *ref;          /* a reference to the label, to be filled in when it's defined. */
#ifdef DEBUG
  char *name;        /* textual name of the label - same as field name */
#endif
} label;

/* Each label must be added as a field to this structure. */
typedef struct
{
  #define FIRST_LABEL loop_y_repeat
  label loop_y_repeat;
#ifdef TESTDEBUG
  label test1;
  label test2;
#endif
  label loop_x_enter;
  label loop_x_repeat;
  label loop_x_exit;
  label l_masked;
  label loop_put_pixel_repeat;
  label loop_put_masked_repeat;
  label y_loop;
  label y_loop_enter;
  label y_loop_exit;
  label loop_delay;

  label x_evenstart;
  label x_oddmask;
  label x_aligned_loop;
  label x_aligned_enter;
  label x_alignmask1;
  label x_alignmask2;
  label x_misaligned;
  label x_misaligned_loop;
  label x_misaligned_enter;
  label x_misalignmask1;
  label x_misalignmask2;
  label x_2atatime_exit;
  label x_lastmask;
  label loop_x_exit1;
  label loop_x_exitskip;
  label loop1;
  label loop2;
  label plot_loopa;
  label plot_loop1;
  label plot_loop1a;
  label plot_loop1b;
  label plot_loop1c;
  label plot_loop2;
  label plot_loop3;
  label plot_loop4;
  label plot_loop4a;
  label plot_loop4b;
  label plot_loop4c;

  label last;
  #define LAST_LABEL last
  /* If you add a label, add giving it a name in check_workspace */
} labels_rec;
#define FOR_EACH_LABEL(ptr) for (ptr = &ws->labels.FIRST_LABEL; ptr <= &ws->labels.LAST_LABEL; ptr++)
#define L(name) (&(ws->labels.name))

/* Register names - one for each register name (the register numbers are allocated at compile time) */
typedef struct
{
  int regno;     /* the physical register number */
#ifdef DEBUG
  char *name;    /* the name, for trace output */
#endif
} regname;

/* Each register name must be added as a field to this structure. */
typedef struct
{
  #define FIRST_REGISTER r_pixel

  /* Common registers */
  regname r_pixel;         /* In/out pixel value */
  regname r_temp1;         /* Temp regs for pixel format conversion */
  regname r_temp2;
  regname r_expansionmask; /* Constant for BPP expansion */
  regname r_oditheradd;    /* Current dither pattern */
  regname r_table;         /* Palette/colour translation table ptr */

  /* PutScaled registers */
  regname r_inptr;
  regname r_inshift;
  regname r_inword;
  regname r_maskinptr;
  regname r_maskinword;
  regname r_maskinshift;
  regname r_masko;
  regname r_blockroutine;
  regname r_ecfindex;
  regname r_bgcolour;
  regname r_fetchroutine;
  regname r_outptr;
  regname r_outword;
  regname r_outshift;
  regname r_outmask;
  regname r_xsize;
  regname r_xcount;
  regname r_ysize;
  regname r_ycount;
  regname r_inoffset;
  regname r_maskinoffset;
  regname r_in_pixmask;    /* only used by 2-at-a-time loop */

  /* SprTrans registers */
  regname r_xsize_spr_left;
  regname r_X;
  regname r_Y;
  regname r_inc_X_x;
  regname r_inc_Y_x;
  regname r_byte_width;
  regname r_spr_height_right;
  regname r_out_x;

  /* Generic registers */
  regname wp;
  regname sp;
  regname lr;
  regname pc;
  #define LAST_REGISTER pc
} regnames_rec;
#define FOR_EACH_REGISTER_NAME(ptr) for (ptr = &ws->regnames.FIRST_REGISTER; ptr <= &ws->regnames.LAST_REGISTER; ptr++)

#define R(reg) rr(ws->regnames.reg.regno)
static int rr(int r)
{
  /* Assert that the register is at least set */
  assert(r != -1, ERROR_FATAL);
  return r;
}

/* Must be kept in sync with corresponding definitions in Sources.PutScaled! */
typedef enum
{
  /* This block is assumed to match the mode log2bpp */
  PixelFormat_1bpp=0,
  PixelFormat_2bpp=1,
  PixelFormat_4bpp=2,
  PixelFormat_8bpp=3,

  /* I can't remember if this needs to be in the middle! */
  PixelFormat_24bpp_Grey=4,

  /* This block is assumed to be in order of increasing bit count */
  PixelFormat_12bpp=5,
  PixelFormat_15bpp=6,
  PixelFormat_16bpp=7,
  PixelFormat_24bpp=8,
  PixelFormat_32bpp=9,
  PixelFormat_32bpp_Hi=10, /* &BBGGRR00, i.e. palette entry */

  PixelFormat_BPPMask = 15,

  /* Extra flags, only for the true colour entries */
  PixelFormat_RGB = 16, /* &RGB order, not &BGR */
  PixelFormat_Alpha = 32, /* Alpha, not supremacy/transfer */
} PixelFormat;

/* Must be kept in sync with corresponding definitions in Sources.PutScaled! */
typedef struct
{
  char bits[4]; /* Number of bits in this channel */
  char top[4]; /* The bit above the end of the channel */
  char hints;
  char unused_pad;
  unsigned short alphaimm12;
} PixelFormatInfo;

#define HINT_HIGHEST 1

/* The structure containing all workspace - essentially our static variables. */
#define CHECK_CODE 123456789
typedef struct
{
  /* Initialisation */
  int  check_code;

  /* Code buffer management */
  int  build_buffer;             /* Buffer currently being built, or next to build */
  int *compile_base;
  int *compile_ptr;              /* where to put next instruction */
  int *compile_lim;

  /* Label control and allocation */
  labels_rec labels;             /* each label, and where it is in the generated code */

  /* Register control and allocation */
  regnames_rec regnames;         /* physical assignment of each register name */
  int  next_free_reg;            /* allocator of physical registers, as they are needed. */
  BOOL leave_r12_alone;          /* Leave assembler 'wp' in place during compiled code */

  int  gcol;                     /* GCOL action */
  BOOL masked;                   /* whether to use mask */
  BOOL mask1bpp;                 /* whether mask is 1bpp mask */

  int  odither;                  /* If 0, then there's no ordered dither. If non-0, number of bits - 1 being truncated by dither. */

  int  pixel_expansion_mask;     /* Computed mask that gets loaded into r_expansionmask */
  int  pixel_expansion_shift;    /* Required shift amount */
  const PixelFormatInfo *pixel_expansion_in,*pixel_expansion_out; /* Input & output formats the mask was generated for; it will be applied when performing this and only this type of conversion */

  /* Assemble-time constants */
  int  in_bpp;
  int  in_bpc;                   /* Same as bpp unless double-pixel, in which case double bpp */
  int  in_pixmask;
  PixelFormat in_pixelformat;
  int  mask_bpp;
  int  mask_bpc;
  int  mask_pixmask;
  int  out_pixmask;              /* mask for one pixel */
  int  out_dpixmask;
  int  out_ppw;                  /* pixels per word */
  int  out_l2ppw;
  PixelFormat out_pixelformat;
  BOOL cal_table_simple;         /* If true, a simple table lookup is possible */
  PixelFormat ColourTTRFormat;   /* Input format of ColourTTR (output format assumed to be out_pixelformat) */
  int  compiled_routine_stacked; /* Offset to apply to LDR_SP/STR_SP */

  /* Space for compiled code, near the end so most field accesses have only a small offset. */
  code_buffer buffers[NBUFFERS];

  /* Check for workspace overwritten */
  int  check_code2;
} workspace;

static void check_workspace(workspace *ws)
/* Basic validity checks, and initialise if this is the first time. */
{
  assert(ws != 0, ERROR_NO_MEMORY);
  if (ws->check_code != CHECK_CODE)
  {
    code_buffer *p;
    tracef("Initialising workspace.\n");
    ws->check_code = CHECK_CODE;
    ws->check_code2 = CHECK_CODE;
    ws->build_buffer = 0;
    FOR_EACH_BUFFER(p) p->key_word = -1;

#ifdef DEBUG
    {
      label *l;

      /* Set up textual names of all the labels */
      FOR_EACH_LABEL(l) l->name = 0;
      #define LN(lname) ws->labels.lname.name = #lname;
      LN(loop_y_repeat)
#ifdef TESTDEBUG
      LN(test1)
      LN(test2)
#endif
      LN(loop_x_enter)
      LN(loop_x_repeat)
      LN(loop_x_exit)
      LN(l_masked)
      LN(loop_put_pixel_repeat)
      LN(loop_put_masked_repeat)
      LN(y_loop)
      LN(y_loop_enter)
      LN(y_loop_exit)
      LN(loop_delay)

      LN(x_evenstart)
      LN(x_oddmask)
      LN(x_aligned_loop)
      LN(x_aligned_enter)
      LN(x_alignmask1)
      LN(x_alignmask2)
      LN(x_misaligned)
      LN(x_misaligned_loop)
      LN(x_misaligned_enter)
      LN(x_misalignmask1)
      LN(x_misalignmask2)
      LN(x_2atatime_exit)
      LN(x_lastmask)
      LN(loop_x_exit1)
      LN(loop_x_exitskip)
      LN(loop1)
      LN(loop2)
      LN(plot_loopa)
      LN(plot_loop1)
      LN(plot_loop1a)
      LN(plot_loop1b)
      LN(plot_loop1c)
      LN(plot_loop2)
      LN(plot_loop3)
      LN(plot_loop4)
      LN(plot_loop4a)
      LN(plot_loop4b)
      LN(plot_loop4c)

      LN(last)
      /* Check he's got them all */
      FOR_EACH_LABEL(l) assert(l->name != 0, ERROR_FATAL);
    }
    {
      regname *r;

      FOR_EACH_REGISTER_NAME(r) r->name = 0;
      #define RNN(rname) ws->regnames.rname.name = #rname;
      RNN(r_pixel)
      RNN(r_temp1)
      RNN(r_temp2)
      RNN(r_expansionmask)
      RNN(r_oditheradd)

      RNN(r_inptr)
      RNN(r_inshift)
      RNN(r_inword)
      RNN(r_maskinptr)
      RNN(r_maskinword)
      RNN(r_maskinshift)
      RNN(r_masko)
      RNN(r_blockroutine)
      RNN(r_ecfindex)
      RNN(r_bgcolour)
      RNN(r_fetchroutine)
      RNN(r_outptr)
      RNN(r_outword)
      RNN(r_outshift)
      RNN(r_outmask)
      RNN(r_table)
      RNN(r_xsize)
      RNN(r_xcount)
      RNN(r_ysize)
      RNN(r_ycount)
      RNN(r_inoffset)
      RNN(r_maskinoffset)
      RNN(r_in_pixmask)

      RNN(r_xsize_spr_left)
      RNN(r_X)
      RNN(r_Y)
      RNN(r_inc_X_x)
      RNN(r_inc_Y_x)
      RNN(r_byte_width)
      RNN(r_spr_height_right)
      RNN(r_out_x)

      RNN(wp)
      RNN(sp)
      RNN(lr)
      RNN(pc)
      FOR_EACH_REGISTER_NAME(r) assert(r->name != 0, ERROR_FATAL);
      ws->leave_r12_alone = FALSE;
    }
#endif
  }
  assert(ws->check_code2 == CHECK_CODE, ERROR_FATAL);
}

#ifdef DEBUG
static void dump_asm_workspace(asm_workspace *wp)
{
  /* Oddly spaced out to allow it to be easily lined up with the structure definition */
  tracef("Assembler workspace at %x:\n" _ wp);
  tracef("save_outoffset=%i        %t32. byte offset between output rows - SUBTRACT for next row.\n" _ wp->save_outoffset);
  tracef("save_inoffset=%i         %t32. byte offset between input rows - SUBTRACT for next row.\n" _ wp->save_inoffset);
  tracef("save_inptr=0x%x          %t32. word address of input pixels.\n" _ wp->save_inptr);
  tracef("save_outptr=0x%x         %t32. address of word containing first output pixel.\n" _ wp->save_outptr);
  tracef("save_ydiv=%i             %t32. subtracter value for y scale.\n" _ wp->save_ydiv);
  tracef("save_yadd=%i             %t32. adder value for y scale.\n" _ wp->save_yadd);
  tracef("save_ysize=%i            %t32. number of output rows.\n" _ wp->save_ysize);
  tracef("save_ycount=%i           %t32. total of ymag/ydiv sum, for y scale factor\n" _ wp->save_ycount);
  newline();
  
  tracef("save_inshift=%i          %t32. bit shift of first pixel.\n" _ wp->save_inshift);


  tracef("save_xsize=%i            %t32. number of output pixels per row.\n" _ wp->save_xsize);
  tracef("save_xcount=%i           %t32. total of xmag/xdiv sum, for x scale factor\n" _ wp->save_xcount);
  tracef("save_ecfptr=0x%x         %t32. ECF pointer - only useful if plotting the mask.\n" _ wp->save_ecfptr);
  tracef("save_ecflimit=0x%x       %t32. ECF limit - only useful if plotting the mask.\n" _ wp->save_ecflimit);

  tracef("save_xdiv=%i             %t32. subtracter value for x scale.\n" _ wp->save_xdiv);
  tracef("save_xadd=%i             %t32. adder value for x scale\n" _ wp->save_xadd);
  newline();
  tracef("save_masko=%i            %t32. if not 1bpp mask then this is mask data offset from inptr. Otherwise...\n" _ wp->save_masko);
  tracef("save_xcoord=%i           %t32. pixel x coordinate of first output pixel.\n" _ wp->save_xcoord);
  tracef("save_ycoord=%i           %t32. pixel y coordinate of first output pixel.\n" _ wp->save_ycoord);





  tracef("save_xmag=%i             %t32. adder value for x scale?\n" _ wp->save_xmag);
  tracef("save_ymag=%i             %t32. adder value for y scale?\n" _ wp->save_ymag);
  newline();

  tracef("save_inlog2bpp=%i        %t32. log 2 bits per pixel of input.\n" _ wp->save_inlog2bpp);
  tracef("save_inlog2bpc=%i        %t32. log 2 bits per character of input (only different for double-pixels).\n"
                                   _ wp->save_inlog2bpc);
  tracef("save_mode=%i (>>27 = %i) %t32. mode number/pointer of sprite - 1bpp sprites have hi bits set.\n" _ wp->save_mode _ wp->save_mode >> 27);
  newline();

  tracef("save_maskinshift=%i      %t32. initial bit shift within mask word.\n" _ wp->save_maskinshift);
  tracef("save_maskinptr=0x%x      %t32. word address of mask (or 0 if there isn't one).\n" _ wp->save_maskinptr);
  tracef("save_maskinoffset=%i     %t32. byte offset between mask rows - SUBTRACT for next row.\n" _ wp->save_maskinoffset);
  newline();

  tracef("BPP=%i                   %t32. bits per pixel of output.\n" _ wp->BPP);
  tracef("BPC=%i                   %t32. bits per character of output (only different for double pixels).\n" _ wp->BPC);
  tracef("ColourTTR=0x%x           %t32. translation table or palette.\n" _ wp->ColourTTR);
  tracef("trns_palette=0x%x        %t32. if non-0 ignore TTR and use this palette instead.\n" _ wp->trns_palette);
  tracef("spritecode=%i (& 255 = %i) %t32. SpriteOp - 52 for PutSpriteScaled, 50 for PlotMaskScaled.\n" _ wp->spritecode _ wp->spritecode & 255);
  newline();
}
#endif

#ifdef TESTDEBUG
static void dump_workspace(workspace *ws)
{
  code_buffer *p;

  tracef("Dumping workspace.\n");
  #define DUMPINT(field) tracef("%s = %i.\n" _ #field _ ws->field);
  DUMPINT(build_buffer)
  FOR_EACH_BUFFER(p) tracef("buffer->keyword = %i.\n" _ p->key_word);
}
#endif

/**************************************************************************
*                                                                         *
*    Low-level instruction generation.                                    *
*                                                                         *
**************************************************************************/

/* Condition codes */
#define EQ 0xf0000000      /* It's 0 really - frigged so that 0 can be 'always' - the usual case. */
#define NE 0x10000000
#define CS 0x20000000
#define CC 0x30000000
#define MI 0x40000000
#define PL 0x50000000
#define VS 0x60000000
#define VC 0x70000000
#define HI 0x80000000
#define LS 0x90000000
#define GE 0xa0000000
#define LT 0xb0000000
#define GT 0xc0000000
#define LE 0xd0000000
#define AL 0xe0000000

/* Branches */
#define B  0x0a000000
#define BL 0x0b000000
#define B_OFFSET_MASK 0x00ffffff /* and with this for negative offsets */
#define BLX(reg,str) ins(ws,0x012FFF30 | reg,str)

/* ALU ops */
#define S  (1<<20)
#define AND(dst,op1,rest,str)      ins(ws,(0x0 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define EOR(dst,op1,rest,str)      ins(ws,(0x1 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define SUB(dst,op1,rest,str)      ins(ws,(0x2 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define RSB(dst,op1,rest,str)      ins(ws,(0x3 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define ADD(dst,op1,rest,str)      ins(ws,(0x4 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define ADC(dst,op1,rest,str)      ins(ws,(0x5 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define SBC(dst,op1,rest,str)      ins(ws,(0x6 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define RSC(dst,op1,rest,str)      ins(ws,(0x7 << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define TST(op1,rest,str)          ins(ws,(0x8 << 21) | S | OP1R(op1) | (rest), str)
#define TEQ(op1,rest,str)          ins(ws,(0x9 << 21) | S | OP1R(op1) | (rest), str)
#define CMP(op1,rest,str)          ins(ws,(0xa << 21) | S | OP1R(op1) | (rest), str)
#define CMN(op1,rest,str)          ins(ws,(0xb << 21) | S | OP1R(op1) | (rest), str)
#define ORR(dst,op1,rest,str)      ins(ws,(0xc << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define MOV(dst,rest,str)          ins(ws,(0xd << 21) | DSTR(dst) | (rest), str)
#define BIC(dst,op1,rest,str)      ins(ws,(0xe << 21) | DSTR(dst) | OP1R(op1) | (rest), str)
#define MVN(dst,rest,str)          ins(ws,(0xf << 21) | DSTR(dst) | (rest), str)

#define MUL(dst,op1,op2,rest,str)  ins(ws,(9<<4) | ((dst)<<16) | (op1) | ((op2)<<8) | (rest), str)
#define MOVW(dst,rest,str)         ins(ws,(3<<24) | DSTR(dst) | (rest), str)

#define ADD_OPCODE (0x4 << 21)
#define SUB_OPCODE (0x2 << 21)
#define MOV_OPCODE (0xd << 21)

#define DSTR(x) ((x) << 12)          /* destination - ignored by TST/TEQ/CMP/CMN */
#define OP1R(x) ((x) << 16)          /* first operand */
#define OP2R(x) ((x) << 0)           /* if !IMM */
#define IMM(x) ((x) | (1<<25))       /* an 8-bit unsigned field */
#define IMMROR(x) ((x) << 7)         /* an EVEN number to rotate right IMM by */

static int IMM12(unsigned int imm)   /* generate immediate constant for ALU ops */
{
  int ror = 0;
  while(imm > 256)
  {
    assert(ror < 32, ERROR_FATAL);
    imm = (imm<<2) | (imm>>30);
    ror += 2;
  }
  return IMM(imm) | IMMROR(ror);
}

#define IMM16(x) (((x) & 0xFFF) | (((x) & 0xF000)<<4)) /* encode 16 bit immediate constant for MOVW */ 

#define LSLI(x) (((x) << 7) | 0x00)   /* 5-bit immed shift applied to OP2R */
#define LSRI(x) (((x) << 7) | 0x20)
#define ASRI(x) (((x) << 7) | 0x40)
#define RORI(x) (((x) << 7) | 0x60)

#define LSLR(x) (((x) << 8) | 0x10)   /* shift register applied to OP2R */
#define LSRR(x) (((x) << 8) | 0x30)
#define ASRR(x) (((x) << 8) | 0x50)
#define RORR(x) (((x) << 8) | 0x70)

/* Load and store ops */
#define LDR(reg,basereg)  (0x04100000 | ((reg) << 12)| ((basereg) << 16))
#define STR(reg,basereg)  (0x04000000 | ((reg) << 12)| ((basereg) << 16))
#define LDRB(reg,basereg) (0x04500000 | ((reg) << 12)| ((basereg) << 16))
#define STRB(reg,basereg) (0x04400000 | ((reg) << 12)| ((basereg) << 16))

#define WRITEBACK (1 << 21)
#define ADDOFFSET (1 << 23) /* else subtract */
#define PREADD (1 << 24) /* else post */

#define OFFSET(x) (PREADD | ADDOFFSET | (x))        /* normal simple index */
#define NEGOFFSET(x) (PREADD | (x))                 /* subtract offset */
#define PREINC(x) (WRITEBACK | ADDOFFSET | PREADD | (x))
#define PREDEC(x) (WRITEBACK | PREADD | (x))
#define POSTINC(x) (ADDOFFSET | (x))                /* The manual says, do not set WRITEBACK if doing post-addition */
#define POSTDEC(x) ((x))                            /* writeback will always occur, setting it is does LDRT/LDRBT */

#define PUSH (0x08000000 | (13<<16) /* register 13 */ \
                         | (1<<21) /* write-back */ \
                         | (1<<24) /* add offset before transfer */)
#define POP  (0x08000000 | (13<<16) /* register 13 */ \
                         | (1<<20) /* load from memory */ \
                         | (1<<21) /* write-back */ \
                         | (1<<23) /* add, not subtract */ )

#define LDMIA(reg) (0x08000000 | (reg<<16) /* register to load from */ \
                               | (1<<20) /* load from memory */ \
                               | (1<<23) /* add, not subtract */ )

#define STMIA(reg) (0x08000000 | (reg<<16) /* register to load from */ \
                               | (1<<23) /* add, not subtract */ )

/* Supervisor call */
#define SWI(swino) (0x0F000000 | swino)

/* Indexed load - LSL shift assumed - writeback or negative not covered */
#define INDEX(reg, shift) ((1<<25) | OFFSET(0) | OP2R(reg) | LSLI(shift))

/* Indexed load - LSR shift - writeback or negative not covered */
#define INDEX_LSR(reg, shift) ((1<<25) | OFFSET(0) | OP2R(reg) | LSRI(shift))

/* Offset in assembler workspace */
#define WP_OFFSET(field) OFFSET(((char*)&(wp->field)) - ((char*)&(wp->WP_FIRST_FIELD)))

/* Offset in stack workspace */
#define SP_OFFSET(field) OFFSET((int) (((char*)&(((stack_ws *)0)->field)) + ws->compiled_routine_stacked))

/* Define an assembler register */
#define RN(name,no,describe) set_regname(ws, &ws->regnames.name, no, describe);

#ifdef DEBUG
static void ldm_reg_list(workspace *ws, char *a, int regmask, BOOL lastname)
/* Construct a string in a which can be placed in curly brackets, describing
 * a LDM/STM instruction. If lastname then find the last such register name in
 * the case of duplicates - eg. the y-loop name rather than the x-loop name
 * for the same physical register.
 */
{
  int i;
  regname *r;
  BOOL found;
  char *aptr;

  a[0] = 0;
  for (i = 0; i <= 15; i++) /* for each physical register */
  {
    if ((regmask & (1<<i)) != 0) /* find a name for this register */
    {
      found = FALSE;
      aptr = a;
      while (*aptr != 0) aptr++; /* points at the null at the end of the string */
      FOR_EACH_REGISTER_NAME(r)
      {
        if (r->regno == i)
        {
          *aptr = 0; /* If lastname and finding it again, delete last one */
          if (a[0] != 0) strcat(aptr, ",");
          strcat(aptr, r->name);
          found = TRUE;
          if (!lastname) break;
        }
      }
      assert(found, ERROR_FATAL);
    }
  }
}
#endif

#ifdef DEBUG
static void ins(workspace *ws, int w, char *description)
#else
#define ins(ws,w,description) do_ins(ws,w)
static void do_ins(workspace *ws, int w)
#endif
/* Put an instruction into the output buffer.
 * When debugging an assembler listings is generated too. These can be fed through
 * objasm, and the results compared with the opcodes that I generate.
 * Columns of assembler output:
 * addressX  opcodeXX  label   opcodes regs                            comment
 * ^0        ^10       ^20     ^28     ^36                             ^68
 */
{
  int ccode = w & 0xf0000000;

  /* Handle the AL/EQ condition codes being wrong, so that 0 can be AL elsewhere. */
  if (ccode == 0xf0000000) w = w & 0x0fffffff;   /* EQ code */
  else if (ccode == 0) w = w | 0xe0000000;       /* AL code */
  /* All others are per the ARM expects */
  tracef("%x  %x  %t28.%s\n" _
    (ws->compile_ptr - ws->compile_base) * sizeof(int) _
    w _ description); /* pseudo-assembler format of output */

  assert(ws->compile_ptr < ws->compile_lim, ERROR_NO_MEMORY); /* Check the buffer is big enough */
  *(ws->compile_ptr)++ = w; /* Store at then increment P% */
}

#ifdef DEBUG
#define DEFINE_LABEL(lab,describe) define_label(ws, L(lab), describe);
static void define_label(workspace *ws, label *lab, char *description)
#else
#define DEFINE_LABEL(lab,describe) define_label(ws, L(lab));
static void define_label(workspace *ws, label *lab)
#endif
/* Define a label, and fill in a forward reference to it if necessary. */
{
   assert(lab->def == 0, ERROR_FATAL); /* Check not defined twice */
   lab->def = ws->compile_ptr;
   tracef("%t20.%s%t68.; %s\n" _ lab->name _ description);
   if (lab->ref != 0)
   {
     int newvalue = *(lab->ref) | (B_OFFSET_MASK & (lab->def - (lab->ref + 2))); /* compute offset */
     tracef("%t20.; Zapping forward ref instruction at %x to be %x.\n" _
       sizeof(int) * (lab->ref - ws->compile_base) _ newvalue);
     *(lab->ref) = newvalue;
     lab->ref = 0;
   }
}

#ifdef DEBUG
static void branch(workspace *ws, unsigned int opcode, label *lab, char *description)
#else
#define branch(ws,opcode,lab,description) do_branch(ws,opcode,lab)
static void do_branch(workspace *ws, unsigned int opcode, label *lab)
#endif
/* Compile a branch instruction to a label. The opcode includes the condition code. */
{
  if (lab->def == 0) /* Forward reference */
  {
#ifdef DEBUG
    if (lab->ref != 0)
      tracef("Already referenced at 0x%x\n" _ sizeof(int) * (lab->ref - ws->compile_base));
#endif
    assert(lab->ref == 0, ERROR_FATAL); /* Check for two forward refs to same label */
    lab->ref = ws->compile_ptr;
    ins(ws, opcode, description); /* Just give as offset 0 for now */
  }
  else
  {
    assert(lab->ref == 0, ERROR_FATAL);
    ins(ws,
      opcode | (B_OFFSET_MASK & (lab->def - (ws->compile_ptr + 2))), description);
  }
}

#ifdef DEBUG
static void set_regname(workspace *ws, regname *r, int regno, char *describe)
#else
#define set_regname(ws,r,regno,describe) do_set_regname(ws,r,regno)
static void do_set_regname(workspace *ws, regname *r, int regno)
#endif
/* Allocate a physical register number. If regno is -1 then allocate an
 * as-yet-unused one, otherwise it's a specific register number.
 */
{
  if (regno == -1) /* allocate a number, one of 0..12 */
  {
    regno = ws->next_free_reg;
    ws->next_free_reg++;
    assert(regno >= 0 && regno <= 12, ERROR_FATAL); /* Check for register overflow */
    if (regno == 12) assert(!ws->leave_r12_alone, ERROR_FATAL);
  }
  r->regno = regno;
  tracef("%t20.%s%t27 RN %t36.%i %t68.; %s\n" _ r->name _ r->regno _ describe);
}

static void align16(asm_workspace *wp, workspace *ws)
/* Align next instruction to quadword boundary */
{
  UNUSED(wp);
  while (((int) ws->compile_ptr) & 15 != 0)
    MOV(R(r_pixel), OP2R(R(r_pixel)),                        "MOV     r_pixel,r_pixel                 ; align to 16-byte boundary");
}

#if defined(DEBUG_TML) && defined(DEBUG)
static void write_reg(workspace *ws, regname *reg)
/* Sppol the register to the TML hardware */
{
    comment(ws, "Write Register to TML card");
    tracef("Register to be output is... %s\n" _ reg->name);
    ins(ws, PUSH | (1<<10) | (1<<11) | 1 | (1<<1) | (1<<14),        "STMDB   sp!,{r0,r1,r10,r11,r14}          ; prepare to call SWI");
    ins(ws, MOV_OPCODE | DSTR(1) | OP2R(reg->regno),                "MOV     r1,r_somereg");
    ins(ws, MOV_OPCODE | DSTR(0) | OP2R(1),                         "MOV     r0,r1");
    AND(0, 0, IMM(0xff),                                            "AND     r0,r0,#255 ");
    ins(ws, SWI(HostFS_WriteC),                                     "SWI     HostFS_WriteC                    ; convert r1 value");
    ins(ws, MOV_OPCODE | DSTR(0) | OP2R(1) | LSRI(8),               "MOV     r0,r1 LSR #8");
    AND(0, 0, IMM(0xff),                                            "AND     r0,r0,#255                               ");
    ins(ws, SWI(HostFS_WriteC),                                     "SWI     HostFS_WriteC                    ; convert r1 value");
    ins(ws, MOV_OPCODE | DSTR(0) | OP2R(1) | LSRI(16),              "MOV     r0,r1 LSR #16");
    AND(0, 0, IMM(0xff),                                            "AND     r0,r0,#255                               ");
    ins(ws, SWI(HostFS_WriteC),                                     "SWI     HostFS_WriteC                    ; convert r1 value");
    ins(ws, MOV_OPCODE | DSTR(0) | OP2R(1) | LSRI(24),              "MOV     r0,r1 LSR #24");
    AND(0, 0, IMM(0xff),                                            "AND     r0,r0,#255                               ");
    ins(ws, SWI(HostFS_WriteC),                                     "SWI     HostFS_WriteC                    ; convert r1 value");
    ins(ws, POP | (1<<10) | (1<<11) | 1 | (1<<1) | (1<<14),         "LDMIA   sp!,{r0,r1,r10,r11,r14}          ; restore after calling SWI");
    comment(ws, "");
}
#endif

/* Loading a constant index from the workspace pointer */
#define LDR_WP(reg,value) ins(ws, LDR(R(reg),R(wp)) + WP_OFFSET(value), \
                              "LDR     " #reg "," #value);

#ifdef DEBUG
  #define LDR_WP_C(reg,value, comment)                                \
  {                                                                   \
    char a[256];                                                      \
    do_sprintf(a, "LDR     " #reg "," #value " %t40.; " comment);        \
    ins(ws, LDR(R(reg),R(wp)) + WP_OFFSET(value), a);                 \
  }
#else
  #define LDR_WP_C(reg,value, comment) ins(ws, LDR(R(reg),R(wp)) + WP_OFFSET(value), 0);
#endif

/* Loading a constant index from a register */
#ifdef DEBUG
  #define LDR_INDEX(destreg,indexreg,offset,comment)                                      \
  {                                                                                       \
    char a[256];                                                                          \
    do_sprintf(a, "LDR     " #destreg ",[" #indexreg ", #%i] %t40.; " comment, offset);      \
    ins(ws, LDR(R(destreg),R(indexreg)) | OFFSET(offset), a);                             \
  }
#else
  #define LDR_INDEX(destreg,indexreg,offset,comment) ins(ws, LDR(R(destreg),R(indexreg)) | OFFSET(offset), 0);
#endif

/* Loading/storing a constant index from the stack */
#define LDR_SP(reg,value) ins(ws, LDR(R(reg),R(sp)) + SP_OFFSET(value), \
                              "LDR     " #reg "," #value " + compiled_routine_stacked");
#define STR_SP(reg,value) ins(ws, STR(R(reg),R(sp)) + SP_OFFSET(value), \
                              "STR     " #reg "," #value " + compiled_routine_stacked");

#define ADD_A(reg,value) arbitrary_add(ws, TRUE, FALSE, &ws->regnames.reg, value);
#define ADDS_A(reg,value) arbitrary_add(ws, TRUE, TRUE, &ws->regnames.reg, value);
#define SUB_A(reg,value) arbitrary_add(ws, FALSE, FALSE, &ws->regnames.reg, value);
#define SUBS_A(reg,value) arbitrary_add(ws, FALSE, TRUE, &ws->regnames.reg, value);

static void arbitrary_add(workspace *ws, BOOL add, BOOL s, regname *r, int value)
/* Add/subtract an arbitrary constant to a register - could be more than 8 bits. */
{
  IFDEBUG(char a[256];)

  if (value < 0) {value = -value; add = !add;}
  if (value == 0) /* special case with 0 constant */
  {
    if (s)
    {
      IFDEBUG(do_sprintf(a, "CMP     %s,#0", r->name);)
      CMP(r->regno, IMM(0), a);
    }
    /* else, nothing */
  }
  else
  {
    int opcode = add ? ADD_OPCODE : SUB_OPCODE;
    int sopcode = s ? S : 0;
    int shift_it = 0;

    while (value != 0)
    {
      BOOL last;
      int valuebyte;

      if (value > 255)
        while ((value & 3) == 0) {value >>= 2; shift_it += 2;}
      valuebyte = value & 0xff;
      value &= 0xffffff00;
      last = value == 0; /* the last instruction needed */
      IFDEBUG(
        do_sprintf(a,
          (last && sopcode ? "%sS%t8.%s,%s,#&%x" : "%s%t8.%s,%s,#&%x") _
          (add ? "ADD" : "SUB") _ r->name _ r->name _ valuebyte << shift_it);)
      ins(ws, opcode | (last ? sopcode : 0)
            | DSTR(r->regno) | OP1R(r->regno)
            | IMM(valuebyte) | IMMROR ((32 - shift_it) & 0x1e),
            a);
    }
  }
}

/**************************************************************************
*                                                                         *
*    Pixel format information                                             *
*                                                                         *
**************************************************************************/

extern const PixelFormatInfo *pixelformat_info(int format);

static int PIXELFORMAT_ALPHA_MASK(int format)
{
  const PixelFormatInfo *pf=pixelformat_info(format);
  return ((1<<pf->bits[3])-1)<<(pf->top[3]-pf->bits[3]);
}

#define PIXELFORMAT_ALPHA_IMM(format) (pixelformat_info(format)->alphaimm12 | (1<<25))

static PixelFormat compute_pixelformat(int ncolour,int modeflags,int log2bpp)
{
  tracef("compute_pixelformat: %x %x %d\n" _ ncolour _ modeflags _ log2bpp);
  if(log2bpp <= 3)
    return (PixelFormat) log2bpp;
  PixelFormat baseformat;
  if(log2bpp == 4)
  {
    if(modeflags & ModeFlag_64k)
    {
      baseformat = PixelFormat_16bpp;
      modeflags &= ~ModeFlag_DataFormatSub_Alpha;
    }
    else if(ncolour < 4096)
      baseformat = PixelFormat_12bpp;
    else
      baseformat = PixelFormat_15bpp;
  }
  else if(log2bpp == 6)
  {
    baseformat = PixelFormat_24bpp;
    modeflags &= ~ModeFlag_DataFormatSub_Alpha;
  }
  else
  {
    /* Assume 32bpp */
    baseformat = PixelFormat_32bpp;
  }
  if(modeflags & ModeFlag_DataFormatSub_RGB)
    baseformat = (PixelFormat) (baseformat | PixelFormat_RGB);
  if(modeflags & ModeFlag_DataFormatSub_Alpha)
    baseformat = (PixelFormat) (baseformat | PixelFormat_Alpha);
  return baseformat;
}

/**************************************************************************
*                                                                         *
*    Register allocation                                                  *
*                                                                         *
**************************************************************************/

static int convert_pixel_rn(asm_workspace *wp, workspace *ws,PixelFormat pixelformat,const PixelFormat out_pixelformat,int need_temps)
/* Allocate registers for translating r_pixel from pixelformat to
 * out_pixelformat, without using any lookup tables etc.
 *
 * Requirements:
 * wp->is_it_jpeg valid
 */
{
  if(pixelformat == out_pixelformat)
    return need_temps;
  if((pixelformat == PixelFormat_24bpp_Grey) && (out_pixelformat <= PixelFormat_4bpp))
  {
    assert(wp->is_it_jpeg, ERROR_FATAL);
    /* Hack for JPEG data in RISC OS 3
       JPEG has produced greyscale output, but we don't have a ColourTTR to
       map it to the current palette.
       Assuming default Wimp palettes, convert the output manually */
    pixelformat = out_pixelformat;
  }
  else if((pixelformat == PixelFormat_32bpp) && (out_pixelformat == PixelFormat_8bpp))
  {
    assert(wp->is_it_jpeg, ERROR_FATAL);
    need_temps = 2;
    pixelformat = PixelFormat_8bpp;
  }
  else if((pixelformat == PixelFormat_24bpp_Grey) && (out_pixelformat >= PixelFormat_12bpp))
  {
    /* 24bpp grey is equivalent 24bpp/32bpp colour with out_pixelformat RGB order */

    /* Minor optimisation, pick 24bpp/32bpp to allow the giant if() block below to be skipped */
    if((out_pixelformat & PixelFormat_BPPMask) == PixelFormat_24bpp)
      pixelformat = PixelFormat_24bpp;
    else
      pixelformat = PixelFormat_32bpp;

    /* And pick right RGB order */
    pixelformat = (PixelFormat) (pixelformat | (out_pixelformat & PixelFormat_RGB));

    /* TODO - 24 grey handling should be folded into the if() below, so that reducing 24 grey to <=16bpp can be optimised */
  }
  
  if(pixelformat != out_pixelformat)
  {
    assert((pixelformat > PixelFormat_8bpp) && (out_pixelformat > PixelFormat_8bpp), ERROR_FATAL);
    int flags = pixelformat & (PixelFormat_Alpha | PixelFormat_RGB);
    pixelformat = (PixelFormat) (pixelformat & PixelFormat_BPPMask);
    int out_flags = out_pixelformat & (PixelFormat_Alpha | PixelFormat_RGB);
    PixelFormat out_format = (PixelFormat) (out_pixelformat & PixelFormat_BPPMask);
    assert(out_format != PixelFormat_32bpp_Hi, ERROR_FATAL);
    if((pixelformat != out_format) && (pixelformat >= PixelFormat_24bpp) && (out_format >= PixelFormat_24bpp))
    {
      /* Source & dest are both 24bpp/32bpp, but need converting between subformats */
      switch(pixelformat)
      {
      case PixelFormat_24bpp:
        pixelformat = PixelFormat_32bpp;
        break;
      case PixelFormat_32bpp:
        if(flags & PixelFormat_Alpha)
        {
          flags -= PixelFormat_Alpha;
        }
        pixelformat = PixelFormat_24bpp;
        break;
      case PixelFormat_32bpp_Hi:
        assert(!(flags & PixelFormat_Alpha), ERROR_FATAL);
        pixelformat = out_format;
        break;
      }
    }
    if(pixelformat == out_format)
    {
      /* Only RGB order or alpha fixup needed */
      if((flags & PixelFormat_RGB) != (out_flags & PixelFormat_RGB))
      {
        switch(pixelformat)
        {
        case PixelFormat_12bpp:
        case PixelFormat_15bpp:
        case PixelFormat_16bpp:
          if(!need_temps)
            need_temps = 1;
          flags ^= PixelFormat_RGB;
          break;
        case PixelFormat_32bpp:
          if(flags & PixelFormat_Alpha)
          {
            if(out_flags & PixelFormat_Alpha)
            {
              if(!need_temps)
                need_temps = 1;
              flags ^= PixelFormat_RGB;
              break;
            }
            flags -= PixelFormat_Alpha;
          }
          /* Else fall through to 24bpp case */
        case PixelFormat_24bpp:
          if(!need_temps)
            need_temps = 1;
          flags ^= PixelFormat_RGB;
          break;
        }
      }
      /* RGB order should be good. Now deal with alpha. */
      if((flags & PixelFormat_Alpha) != (out_flags & PixelFormat_Alpha))
      {
        flags ^= PixelFormat_Alpha;
      }
    }
    else if((pixelformat == PixelFormat_15bpp) && (out_format == PixelFormat_16bpp) && !((flags ^ out_flags) & PixelFormat_RGB))
    {
      /* Trivial case - 15bpp to 16bpp */
      if(!need_temps)
        need_temps = 1;
      pixelformat = out_format;
      flags = out_flags;
    }
    else if((pixelformat == PixelFormat_16bpp) && (out_format == PixelFormat_15bpp) && !((flags ^ out_flags) & PixelFormat_RGB))
    {
      /* Trivial case - 16bpp to 15bpp */
      if(!need_temps)
        need_temps = 1;
      pixelformat = out_format;
      flags = out_flags;
    }
    else
    {
      /* Full processing needed, so 2 temp regs */
      need_temps = 2;
  
      const PixelFormatInfo *in_fmt = pixelformat_info(pixelformat | flags);
      const PixelFormatInfo *out_fmt = pixelformat_info(out_format | out_flags);
      IFDEBUG(tracef("in format: %x { %i, %i, %i, %i }, { %i, %i, %i, %i }, %x, %x\n" _ in_fmt _ in_fmt->bits[0] _ in_fmt->bits[1] _ in_fmt->bits[2] _ in_fmt->bits[3] _ in_fmt->top[0] _ in_fmt->top[1] _ in_fmt->top[2] _ in_fmt->top[3] _ in_fmt->hints _ in_fmt->alphaimm12);)
      IFDEBUG(tracef("out format: %x { %i, %i, %i, %i }, { %i, %i, %i, %i }, %x, %x\n" _ out_fmt _ out_fmt->bits[0] _ out_fmt->bits[1] _ out_fmt->bits[2] _ out_fmt->bits[3] _ out_fmt->top[0] _ out_fmt->top[1] _ out_fmt->top[2] _ out_fmt->top[3] _ out_fmt->hints _ out_fmt->alphaimm12);)

      /* Work out if we need r_expansionmask, and if so, what it should be */
      int pixel_expansion_mask = 0;
      int pixel_expansion_shift = 0;
      int uses = 0;
      int failures = 0;
      
      for(int i=0;i<4;i++)
      {
        /* Skip alpha channel if it doesn't exist in one or the other */
        if(!out_fmt->bits[i] || !in_fmt->bits[i])
        {
          assert(i == 3, ERROR_FATAL);
          continue;
        }
        /* If we have 1 bit alpha, and we're wanting to expand it, it's better to store it in the PSR than to mask-and-shift (especially for this first channel)
           The same technique is also worthwhile when we're shrinking down to 1bpp alpha. But not with any formats we currently support, so ignore that potential optimisation for now. */
        if((i == 3) && (in_fmt->bits[i] == 1) && (out_fmt->bits[i] >= 1))
        {
          continue;          
        }
        if(in_fmt->bits[i] < out_fmt->bits[i])
        {
          /* This is a candidate for expansion */
          if(!pixel_expansion_shift || (pixel_expansion_shift == in_fmt->bits[i]))
          {
            int bits = out_fmt->bits[i]-in_fmt->bits[i];
            int mask = (1<<bits)-1;
            int shift = out_fmt->top[i]-bits;
            pixel_expansion_mask |= mask<<shift;
            pixel_expansion_shift = in_fmt->bits[i];
            uses++;
          }
          else
            failures |= 1<<i;
        }
      }
      assert(!(failures & 5), ERROR_FATAL); /* We don't cope with red or blue being unable to use it */
      /* Was it used enough times to make setting it up worthwhile? */
      if(uses > 1)
      {
        if(!ws->pixel_expansion_mask)
        {
          RN(r_expansionmask, -1, "constant for colour channel expansion")
          ws->pixel_expansion_mask = pixel_expansion_mask;
          ws->pixel_expansion_shift = pixel_expansion_shift;
          ws->pixel_expansion_in = in_fmt;
          ws->pixel_expansion_out = out_fmt;
        }
        else
        {
          /* Currently we only support one set of expansion mask settings. Make sure this new conversion is an exact match for the previous one (since the code generator has no other way of knowing if the expansion should be performed or not) */
          assert((ws->pixel_expansion_in == in_fmt) && (ws->pixel_expansion_out == out_fmt),ERROR_FATAL);
        }
      }
      /* And that should be it */
      pixelformat = out_format;
      flags = out_flags;
    }
    /* Recombine pixelformat */
    pixelformat = (PixelFormat) (pixelformat | flags);
  }

  assert(pixelformat == out_pixelformat, ERROR_FATAL); /* If this hasn't happened, we haven't completed the transformation. */

  return need_temps;
}

static int translate_pixel_rn(asm_workspace *wp, workspace *ws, int need_temps)
{
  /* Work out whether we need 16->32 or 32->16 transformations, with their temp registers
   * So, mirror the structure of translate_pixel
   */

  PixelFormat pixelformat = ws->in_pixelformat;
  if(wp->trns_palette != 0)
  {
    assert(pixelformat <= PixelFormat_8bpp, ERROR_FATAL);
    if(wp->BPP == 16)
    {
      pixelformat = ws->out_pixelformat;
    }
    else
    {
      pixelformat = PixelFormat_32bpp_Hi;
    }
  }
  if(wp->ColourTTR != 0)
  {
    if(wp->Log2bpp <= 3)
    {
      if(pixelformat != ws->ColourTTRFormat)
        need_temps = convert_pixel_rn(wp,ws,pixelformat,ws->ColourTTRFormat,need_temps);
    }
    else
    {
      assert(pixelformat <= PixelFormat_8bpp, ERROR_FATAL); /* up to 256 entries in word table */
      assert(pixelformat == ws->ColourTTRFormat, ERROR_FATAL);
    }
    pixelformat = ws->out_pixelformat;
  }

  /* Do any extra conversion necessary */
  if(pixelformat != ws->out_pixelformat)
  {
    need_temps = convert_pixel_rn(wp,ws,pixelformat,ws->out_pixelformat,need_temps);
    pixelformat = ws->out_pixelformat;
  }

  return need_temps;
}

/**************************************************************************
*                                                                         *
*    Register initialisation.                                             *
*                                                                         *
**************************************************************************/

static void dither_expansion_init(asm_workspace *wp, workspace *ws)
/* Initialise the ordered dither & pixel format expansion registers
 *
 * Requirements:
 * convert_pixel_rn() called
 * ws->odither valid
 * r_oditheradd allocated if necessary
 */
{
  if (ws->regnames.r_expansionmask.regno != -1) /* Generate binary constant ws->pixel_expansion_mask */
  {
#ifdef DEBUG
    char a[256];
    do_sprintf(a,"Generate expansion mask &%x",ws->pixel_expansion_mask);
    comment(ws,a);
#endif
    if(ws->pixel_expansion_mask == 0xF0F0F0F0)
    {
      /* We can do this in two or three instructions */
      if(wp->CPUFlags & CPUFlag_MOVW)
      {
        MOVW(R(r_expansionmask), IMM16(0xF0F0),                                        "MOVW    r_expansionmask,#&f0f0");
      }
      else
      {
        MOV(R(r_expansionmask), IMM(15) | IMMROR(28),                                  "MOV     r_expansionmask,#&f0");
        ORR(R(r_expansionmask), R(r_expansionmask), OP2R(R(r_expansionmask)) | LSLI(8),"ORR     r_expansionmask,r_expansionmask, LSL #8");
      }
      ORR(R(r_expansionmask), R(r_expansionmask), OP2R(R(r_expansionmask)) | LSLI(16), "ORR     r_expansionmask,r_expansionmask, LSL #16");
    }
    else
    {
      /* Other masks may be anywhere between one and three instructions, do it a byte at a time */
      assert(ws->pixel_expansion_mask & 0xff, ERROR_FATAL); /* We expect red & blue to need expansion, and for one of them to tbe in the bottom byte */
      assert(!(ws->pixel_expansion_mask & 0xff000000), ERROR_FATAL); /* We don't expect 32bpp alpha to need expansion. We'll either be coming from 4bpp (in which case we'll use 0xF0F0F0F0) or from 1bpp (in which case we'll use TST) */
      if(wp->CPUFlags & CPUFlag_MOVW)
      {
        IFDEBUG(do_sprintf(a,                                                  "MOVW    r_expansionmask,#&%x",ws->pixel_expansion_mask & 0xffff);)
        MOVW(R(r_expansionmask), IMM16(ws->pixel_expansion_mask),a);
      }
      else
      {
        IFDEBUG(do_sprintf(a,                                                  "MOV     r_expansionmask,#&%x",ws->pixel_expansion_mask & 0xff);)
        MOV(R(r_expansionmask), IMM(ws->pixel_expansion_mask & 0xff),a);
        if(ws->pixel_expansion_mask & 0xff00)
        {
          IFDEBUG(do_sprintf(a,                                                "ORR     r_expansionmask,r_expansionmask,#&%x",ws->pixel_expansion_mask & 0xff00);)
          ORR(R(r_expansionmask), R(r_expansionmask), IMM((ws->pixel_expansion_mask>>8)&0xff) | IMMROR(24),a);
        }
      }
      if(ws->pixel_expansion_mask & 0xff0000)
      {
        IFDEBUG(do_sprintf(a,                                                "ORR     r_expansionmask,r_expansionmask,#&%x",ws->pixel_expansion_mask & 0xff0000);)
        ORR(R(r_expansionmask), R(r_expansionmask), IMM((ws->pixel_expansion_mask>>16)&0xff) | IMMROR(16),a);
      }
    }
  }

  if (ws->odither)
  {
    /* We use ordered dither to attempt to increase the output resolution by almost two bits.
     * This only happens for a 16bpp or 32bpp source that's being truncated somewhat.
     * A square of output pixels has the following binary addition values:
     *              11    01
     *              00    10
     * These values are added to the value of each or R/G/B, just before those values are
     * truncated or looked up in a table, shifted so that we add to the bits which are
     * just about to be discarded.
     * We keep the value to add in r_oditheradd.
     * To proceed along the x axis we EOR by 10 every output pixel.
     * We must also EOR by 01 every line.
     * The starting value must be aligned with the origin of the output.
     */
    comment(ws, "Compute initial dither addition value - bit 0 changes every y, bit 1 every x");
    LDR_WP(r_pixel, save_xcoord)
    AND(R(r_pixel), R(r_pixel), IMM(1),                        "AND     r_pixel,r_pixel,#1               ; least sig bit of x, for dither");
    LDR_WP(r_oditheradd, save_ycoord)
    AND(R(r_oditheradd), R(r_oditheradd), IMM(1),              "AND     r_oditheradd,r_oditheradd,#1     ; least sig bit of y, for dither");
    EOR(R(r_pixel),R(r_pixel),OP2R(R(r_oditheradd)),           "EOR     r_pixel,r_pixel,r_oditheradd     ; if we start Y off on an odd footing, invert x as well");
    ORR(R(r_oditheradd), R(r_oditheradd),
    OP2R(R(r_pixel)) | LSLI(1),                                "ORR     r_oditheradd,r_oditheradd,r_pixel,LSL #1 ; dither add value");

    /* The dither should start based on the current ECF offset */
    LDR_WP(r_pixel, ecfyoffset_ptr)
    LDR_INDEX(r_pixel,r_pixel,0,"get kernel variable ECFYOffset")
    TST(R(r_pixel),IMM(1),                                     "TST     r_pixel,#1                       ; is Y ECF offset odd?");
    EOR(R(r_oditheradd),R(r_oditheradd),NE | IMM(3),           "EORNE   r_oditheradd,r_oditheradd,#3     ; if so, change ordered dither origin to match");

    LDR_WP(r_pixel, ecfshift_ptr)
    LDR_INDEX(r_pixel,r_pixel,0,"get kernel variable ECFShift")

    TST(R(r_pixel),IMM(wp->BPP),                               "TST     r_pixel,#out_bpp                 ; is ECF Shift an odd number of pixels?");
    EOR(R(r_oditheradd),R(r_oditheradd),NE | IMM(2),           "EORNE   r_oditheradd,r_oditheradd,#2     ; if so, change ordered dither origin to match");

    /* Shift the dither value to the top of the register. */
    {
      IFDEBUG(char a[256];)
      IFDEBUG(do_sprintf(a, "MOV     r_oditheradd,r_oditheradd,LSL #%i %t40; shift to top of word", 23 + ws->odither);)
      MOV(R(r_oditheradd), OP2R(R(r_oditheradd)) | LSLI(23 + ws->odither), a);
    }
  }
}

/**************************************************************************
*                                                                         *
*    Pixel translation                                                    *
*                                                                         *
**************************************************************************/

#ifdef DEBUG
static void add_ordered_dither_gun(asm_workspace *wp, workspace *ws, int bits_per_gun, int offset, char *gun)
#else
#define add_ordered_dither_gun(a,b,c,d,e) do_add_ordered_dither_gun(a,b,c,d)
static void do_add_ordered_dither_gun(asm_workspace *wp, workspace *ws, int bits_per_gun, int offset)
#endif
/* Do one gun of the ordered dither - entirely local to add_ordered_dither below
 * Offset is the offset from bit 0 of the base of this field of the colour
 */
{
#ifdef DEBUG
  char a[128];
#endif
  int x = 32 - bits_per_gun - offset; /* amount to shift the colour field in question */
  IFDEBUG(do_sprintf(a,                                  "CMN     r_oditheradd,r_pixel,LSL #%i %t40; %s below limit?", x, gun);)
  CMN(R(r_oditheradd), OP2R(R(r_pixel)) | LSLI(x), a);

  IFDEBUG(do_sprintf(a,                                  "ADDCC   r_pixel,r_pixel,r_oditheradd,LSR #%i %t40; if not, add.", x);)
  ADD(R(r_pixel), R(r_pixel), CC | OP2R(R(r_oditheradd)) | LSRI(x), a);
  UNUSED(wp);
}

static void add_ordered_dither(asm_workspace *wp, workspace *ws,PixelFormat pixelformat)
/* The 32-bit RGB value in r_pixel should have r_oditheradd >> (32-bits_per_gun)
 * added to each of R/G/B, except that these additions should be 'sticky'
 * at 255 in each gun.
 * 
 * The resulting values are just about to be truncated somewhat, so the lo
 * bits of each answer do not matter much. Thus, if the value is currently
 * 254 we never add, but this doesn't matter.
 */
{
  int redblue_bits_per_gun, green_bits_per_gun;
  switch(pixelformat)
  {
  case PixelFormat_12bpp:
    redblue_bits_per_gun = green_bits_per_gun = 4;
    break;
  case PixelFormat_15bpp:
    redblue_bits_per_gun = green_bits_per_gun = 5;
    break;
  case PixelFormat_16bpp:
    redblue_bits_per_gun = 5;
    green_bits_per_gun = 6;
    break;
  default:
    redblue_bits_per_gun = green_bits_per_gun = 8;
    break;
  }

  comment(ws, "Add current value for ordered dither");
  add_ordered_dither_gun(wp, ws, redblue_bits_per_gun, redblue_bits_per_gun+green_bits_per_gun, "blue");
  add_ordered_dither_gun(wp, ws, green_bits_per_gun, redblue_bits_per_gun, "green");
  add_ordered_dither_gun(wp, ws, redblue_bits_per_gun, 0, "red");
  newline();
}

static void convert_pixel(asm_workspace *wp, workspace *ws,PixelFormat pixelformat,const PixelFormat out_pixelformat)
/* Translate r_pixel from pixelformat to out_pixelformat, without using any
 * lookup tables etc.
 *
 * Requirements:
 * wp->is_it_jpeg valid
 * convert_pixel_rn() called
 * dither_expansion_init() called
 */
{
#ifdef DEBUG
  char a[256];
#endif
  if(pixelformat == out_pixelformat)
    return;
  if((pixelformat == PixelFormat_24bpp_Grey) && (out_pixelformat <= PixelFormat_4bpp))
  {
    assert(wp->is_it_jpeg, ERROR_FATAL);
    /* Hack for JPEG data in RISC OS 3
       JPEG has produced greyscale output, but we don't have a ColourTTR to
       map it to the current palette.
       Assuming default Wimp palettes, convert the output manually */
    if(out_pixelformat == PixelFormat_1bpp)
    {
      comment(ws, "Creating 0 or 1 from 24bit greyscale");
      TST(R(r_pixel), IMM(128),                                     "TST     r_pixel,#128                    ; test hi bit of R");
      MOV(R(r_pixel), IMM(1),                                       "MOV     r_pixel,#1                      ; black");
      MOV(R(r_pixel), NE | IMM(0),                                  "MOVNE   r_pixel,#0                      ; white");
      pixelformat = PixelFormat_1bpp;
    }
    else if(out_pixelformat == PixelFormat_2bpp)
    {
      comment(ws, "Creating 0,1,2 or 3 from 24bit greyscale");
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(6),                   "MOV     r_pixel,r_pixel,LSR #6           ; hi 2 bits of R");
      AND(R(r_pixel), R(r_pixel), IMM(3),                           "AND     r_pixel,r_pixel,#3               ; mask off everything else");
      RSB(R(r_pixel), R(r_pixel), IMM(3),                           "RSB     r_pixel,r_pixel,#3               ; change to 0->white, 3->black");
      pixelformat = PixelFormat_2bpp;
    }
    else if (out_pixelformat == PixelFormat_4bpp)
    {
      comment(ws, "Creating wimp colour in 0..7 from 24bit greyscale");
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(5),                   "MOV     r_pixel,r_pixel,LSR #5           ; hi 3 bits of R");
      AND(R(r_pixel), R(r_pixel), IMM(7),                           "AND     r_pixel,r_pixel,#7               ; mask off everything else");
      RSB(R(r_pixel), R(r_pixel), IMM(7),                           "RSB     r_pixel,r_pixel,#7               ; change to 0->white, 7->black");
      pixelformat = PixelFormat_4bpp;
    }
#if 0 /* This case is currently impossible, 24bpp greyscale output is only produced for 8bpp if a greyscale palette is in use, and a greyscale 8bpp palette is impossible on VIDC1 */
    else
    {
      /* Default 256 colour VIDC1 palette; organisation is:
       * bit 0 - tint 0
       * bit 1 - tint 1
       * bit 2 - red 2
       * bit 3 - blue 2
       * bit 4 - red 3 (high)
       * bit 5 - green 2
       * bit 6 - green 3 (high)
       * bit 7 - blue 3 (high)
       */
      comment(ws, "Creating bggrbrtt from 24bit greyscale");
      TEQ(R(r_pixel),OP2R(R(r_pixel)) | LSLI(25),                   "TEQ     r_pixel,r_pixel,LSL #25          ; check high two bits of R");
      MOV(R(r_pixel),OP2R(R(r_pixel)) | LSR(4),                     "MOV     r_pixel,r_pixel,LSR #4           ; tint bits & red 2");
      AND(R(r_pixel),R(r_pixel),IMM(7),                             "AND     r_pixel,r_pixel,#7               ; mask off the rest")
      ORR(R(r_pixel),R(r_pixel),IMM(0x28) | MI,                     "ORRMI   r_pixel,r_pixel,#&28             ; set green 2 & blue 2");
      ORR(R(r_pixel),R(r_pixel),IMM(0xd0) | CS,                     "ORRCS   r_pixel,r_pixel,#&d0             ; set RGB high bits");
      pixelformat = PixelFormat_8bpp;
    }
#endif
  }
  else if((pixelformat == PixelFormat_32bpp) && (out_pixelformat == PixelFormat_8bpp))
  {
    assert(wp->is_it_jpeg, ERROR_FATAL);
    /* Hack for JPEG data in RISC OS 3
       We're producing colour output but don't have a ColourTTR to map it
       to the current palette.
       Assume the default VIDC1 256 colour palette and map it to that. */
    /* Default 256 colour VIDC1 palette; organisation is:
     * bit 0 - tint 0
     * bit 1 - tint 1
     * bit 2 - red 2
     * bit 3 - blue 2
     * bit 4 - red 3 (high)
     * bit 5 - green 2
     * bit 6 - green 3 (high)
     * bit 7 - blue 3 (high)
     */
    comment(ws, "Creating bggrbrtt from 32bit colour");
    /* Making the tint - the average of the lower 6 of RGB isn't a bad approximation. We make this
     * by adding them all up, multiplying by 9, and dividing by 512.
     */
    AND(R(r_temp1), R(r_pixel), IMM(0x3F) | IMMROR(16),           "AND     r_temp1,r_pixel,#&3F0000         ; bottom 6 bits of B");
    MOV(R(r_temp2), OP2R(R(r_temp1)) | LSRI(16),                  "MOV     r_temp2,r_temp1,LSR #16          ; at bottom of temp2");
    AND(R(r_temp1), R(r_pixel), IMM(0x3F) | IMMROR(24),           "AND     r_temp1,r_pixel,#&3F00           ; bottom 6 bits of G");
    ADD(R(r_temp2), R(r_temp2), OP2R(R(r_temp1)) | LSRI(5),       "ADD     r_temp2,r_temp2,r_temp1,LSR #5   ; add to bottom B bits");
    AND(R(r_temp1), R(r_pixel), IMM(0x3F),                        "AND     r_temp1,r_pixel,#&3F             ; bottom 6 bits of R");
    ADD(R(r_temp2), R(r_temp2), OP2R(R(r_temp1)),                 "ADD     r_temp2,r_temp2,r_temp1          ; add to bottom B+G bits");
    ADD(R(r_temp2), R(r_temp2), OP2R(R(r_temp2)) | LSLI(3),       "ADD     r_temp2,r_temp2,r_temp2,LSL #3   ; (lo R+G+B)*9, tint value in bits 9 & 10");

    /* The hi bits are just done by extracting from the 24bpp value */
    AND(R(r_temp1), R(r_pixel), IMM(3) | IMMROR(18),              "AND     r_temp1,r_pixel,#&C000           ; both green bits");
    ORR(R(r_temp2), R(r_temp2), OP2R(R(r_temp1)),                 "ORR     r_temp2,r_temp2,r_temp1          ; merge in with tint (no shifting needed!)");

    MOV(R(r_pixel), OP2R(R(r_pixel)) | LSLI(9) | S,               "MOVS    r_pixel,r_pixel,LSL #9           ; check blue bits");
    ORR(R(r_temp2), R(r_temp2), IMM(1) | IMMROR(20) | MI,         "ORRMI   r_temp2,r_temp2,#8<<9            ; blue 2");
    ORR(R(r_temp2), R(r_temp2), IMM(1) | IMMROR(16) | CS,         "ORRCS   r_temp2,r_temp2,#128<<9          ; blue 3");

    MOV(R(r_pixel), OP2R(R(r_pixel)) | LSLI(16) | S,              "MOVS    r_pixel,r_pixel,LSL #16          ; check red bits");
    ORR(R(r_temp2), R(r_temp2), IMM(2) | IMMROR(22) | MI,         "ORRMI   r_temp2,r_temp2,#4<<9            ; red 2");
    ORR(R(r_temp2), R(r_temp2), IMM(2) | IMMROR(20) | CS,         "ORRCS   r_temp2,r_temp2,#16<<9           ; red 3");

    MOV(R(r_pixel), OP2R(R(r_temp2)) | LSRI(9),                   "MOV     r_pixel,r_temp2,LSR #9           ; shift down to final position");

    pixelformat = PixelFormat_8bpp;
  }
  else if((pixelformat == PixelFormat_24bpp_Grey) && (out_pixelformat >= PixelFormat_12bpp))
  {
    /* 24bpp grey is equivalent 24bpp/32bpp colour with out_pixelformat RGB order */

    /* Minor optimisation, pick 24bpp/32bpp to allow the giant if() block below to be skipped */
    if((out_pixelformat & PixelFormat_BPPMask) == PixelFormat_24bpp)
      pixelformat = PixelFormat_24bpp;
    else
      pixelformat = PixelFormat_32bpp;

    /* And pick right RGB order */
    pixelformat = (PixelFormat) (pixelformat | (out_pixelformat & PixelFormat_RGB));
    tracef("%t20; Treating 24bpp greyscale as %x\n" _ pixelformat);

    /* TODO - 24 grey handling should be folded into the if() below, so that reducing 24 grey to <=16bpp can be optimised */
  }

  if(pixelformat != out_pixelformat)
  {
    /* Some kind of true colour transformation needed */
    assert((pixelformat >= PixelFormat_12bpp) && (out_pixelformat >= PixelFormat_12bpp), ERROR_FATAL);
    int flags = pixelformat & (PixelFormat_Alpha | PixelFormat_RGB);
    pixelformat = (PixelFormat) (pixelformat & PixelFormat_BPPMask);
    int out_flags = out_pixelformat & (PixelFormat_Alpha | PixelFormat_RGB);
    PixelFormat out_format = (PixelFormat) (out_pixelformat & PixelFormat_BPPMask);
    assert(out_format != PixelFormat_32bpp_Hi, ERROR_FATAL);
    if((pixelformat != out_format) && (pixelformat >= PixelFormat_24bpp) && (out_format >= PixelFormat_24bpp))
    {
      /* Source & dest are both 24bpp/32bpp, but need converting between subformats */
      switch(pixelformat)
      {
      case PixelFormat_24bpp:
        pixelformat = PixelFormat_32bpp;
        break;
      case PixelFormat_32bpp:
        if(flags & PixelFormat_Alpha)
        {
          IFDEBUG(do_sprintf(a,                                  "BIC     r_pixel,r_pixel,#&%x ; Discard alpha",PIXELFORMAT_ALPHA_MASK(pixelformat | flags));)
          BIC(R(r_pixel),R(r_pixel),PIXELFORMAT_ALPHA_IMM(pixelformat | flags),a);
          flags -= PixelFormat_Alpha;
        }
        pixelformat = PixelFormat_24bpp;
        break;
      case PixelFormat_32bpp_Hi:
        /* TODO - On ARMv6+ we could use REV if we also need to red/blue swap
           For now just shift down and deal with red/blue swapping below */
        assert(!(flags & PixelFormat_Alpha), ERROR_FATAL);
        MOV(R(r_pixel), OP2R(R(r_pixel)) | LSRI(8),                   "MOV     r_pixel,r_pixel,LSR #8           ; Convert from palette entry");
        pixelformat = out_format;
        break;
      }
    }
    if(pixelformat == out_format)
    {
      /* Only RGB order or alpha fixup needed */
      if((flags & PixelFormat_RGB) != (out_flags & PixelFormat_RGB))
      {
        comment(ws, "Red/blue swap");
        switch(pixelformat)
        {
        case PixelFormat_12bpp:
          EOR(R(r_temp1), R(r_pixel), OP2R(R(r_pixel)) | LSLI(8),     "EOR     r_temp1,r_pixel,r_pixel,LSL #8   ; R ^ B");
          AND(R(r_temp1), R(r_temp1), IMM(0xF) | IMMROR(24),          "AND     r_temp1,r_temp1,#&F00");
          EOR(R(r_pixel), R(r_pixel), OP2R(R(r_temp1)),               "EOR     r_pixel,r_pixel,r_temp1          ; Swap one");
          EOR(R(r_pixel), R(r_pixel), OP2R(R(r_temp1)) | LSRI(8),     "EOR     r_pixel,r_pixel,r_temp1,LSR #8   ; Swap the other");
          flags ^= PixelFormat_RGB;
          break;
        case PixelFormat_15bpp:
          EOR(R(r_temp1), R(r_pixel), OP2R(R(r_pixel)) | LSLI(10),    "EOR     r_temp1,r_pixel,r_pixel,LSL #10  ; R ^ B");
          AND(R(r_temp1), R(r_temp1), IMM(0x1F) | IMMROR(22),         "AND     r_temp1,r_temp1,#&1F<<10");
          EOR(R(r_pixel), R(r_pixel), OP2R(R(r_temp1)),               "EOR     r_pixel,r_pixel,r_temp1          ; Swap one");
          EOR(R(r_pixel), R(r_pixel), OP2R(R(r_temp1)) | LSRI(10),    "EOR     r_pixel,r_pixel,r_temp1,LSR #10  ; Swap the other");
          flags ^= PixelFormat_RGB;
          break;
        case PixelFormat_16bpp:
          EOR(R(r_temp1), R(r_pixel), OP2R(R(r_pixel)) | LSLI(11),    "EOR     r_temp1,r_pixel,r_pixel,LSL #11  ; R ^ B");
          AND(R(r_temp1), R(r_temp1), IMM(0x3E) | IMMROR(22),         "AND     r_temp1,r_temp1,#&1F<<11");
          EOR(R(r_pixel), R(r_pixel), OP2R(R(r_temp1)),               "EOR     r_pixel,r_pixel,r_temp1          ; Swap one");
          EOR(R(r_pixel), R(r_pixel), OP2R(R(r_temp1)) | LSRI(11),    "EOR     r_pixel,r_pixel,r_temp1,LSR #11  ; Swap the other");
          flags ^= PixelFormat_RGB;
          break;
        case PixelFormat_32bpp:
          /* This is tricky depending on whether we have alpha or not */
          if(flags & PixelFormat_Alpha)
          {
            if(out_flags & PixelFormat_Alpha)
            {
              /* Must preserve alpha, use the above 4-instruction sequences */
              EOR(R(r_temp1), R(r_pixel), OP2R(R(r_pixel)) | LSLI(16),  "EOR     r_temp1,r_pixel,r_pixel,LSL #16  ; R ^ B");
              AND(R(r_temp1), R(r_temp1), IMM(0xFF) | IMMROR(16),       "AND     r_temp1,r_temp1,#&FF0000");
              EOR(R(r_pixel), R(r_pixel), OP2R(R(r_temp1)),             "EOR     r_pixel,r_pixel,r_temp1          ; Swap one");
              EOR(R(r_pixel), R(r_pixel), OP2R(R(r_temp1)) | LSRI(16),  "EOR     r_pixel,r_pixel,r_temp1,LSR #16  ; Swap the other");
              flags ^= PixelFormat_RGB;
              break;
            }
            /* We're discarding alpha. Get rid of it here and then use the 3 instruction R/B swap sequence */
            BIC(R(r_pixel), R(r_pixel), IMM(255) | IMMROR(8),         "BIC     r_pixel,r_pixel,#&FF000000       ; Discard alpha");
            flags -= PixelFormat_Alpha;
          }
          /* Else fall through to 24bpp case */
        case PixelFormat_24bpp:
          AND(R(r_temp1), R(r_pixel), IMM(255) | IMMROR(24),          "AND     r_temp1,r_pixel,#&FF00           ; G");
          if(!(out_flags & PixelFormat_Alpha)) /* No need to mask out this byte if we know we're overwriting it later */
          {
            BIC(R(r_pixel), R(r_pixel), IMM(255) | IMMROR(24),        "BIC     r_pixel,r_pixel,#&FF00           ; R & B remain");
          }
          ORR(R(r_pixel), R(r_temp1), OP2R(R(r_pixel)) | RORI(16),    "ORR     r_pixel,r_temp1,r_pixel,ROR #16  ; Swapped");
          flags ^= PixelFormat_RGB;
          break;
        }
      }
      /* RGB order should be good. Now deal with alpha. */
      if((flags & PixelFormat_Alpha) != (out_flags & PixelFormat_Alpha))
      {
        if(flags & PixelFormat_Alpha)
        {
          IFDEBUG(do_sprintf(a,                                  "BIC     r_pixel,r_pixel,#&%x      ; Discard alpha",PIXELFORMAT_ALPHA_MASK(pixelformat | flags));)
          BIC(R(r_pixel),R(r_pixel),PIXELFORMAT_ALPHA_IMM(pixelformat | flags),a);
        }
        else
        {
          IFDEBUG(do_sprintf(a,                                  "ORR     r_pixel,r_pixel,#&%x      ; Set alpha",PIXELFORMAT_ALPHA_MASK(pixelformat | out_flags));)
          ORR(R(r_pixel),R(r_pixel),PIXELFORMAT_ALPHA_IMM(pixelformat | out_flags),a);
        }
        flags ^= PixelFormat_Alpha;
      }
    }
    else if((pixelformat == PixelFormat_15bpp) && (out_format == PixelFormat_16bpp) && !((flags ^ out_flags) & PixelFormat_RGB))
    {
      /* Trivial case - 15bpp to 16bpp */
      MOV(R(r_temp1), OP2R(R(r_pixel)) | LSRI(5),                "MOV     r_temp1,r_pixel,LSR #5          ; B & G");
      TST(R(r_pixel), IMM(2) | IMMROR(24),                       "TST     r_pixel,#16<<5                  ; Top bit of green");
      AND(R(r_pixel), R(r_pixel), IMM(31),                       "AND     r_pixel,r_pixel,#31             ; R");
      ORR(R(r_pixel), R(r_pixel), OP2R(R(r_temp1)) | LSLI(6),    "ORR     r_pixel,r_pixel,r_temp1,LSL #6  ; B & G shifted across one bit");
      ORR(R(r_pixel), R(r_pixel), NE | IMM(32),                  "ORRNE   r_pixel,r_pixel,#32             ; Set low green bit to right value");
      pixelformat = out_format;
      if(flags & PixelFormat_Alpha)
        BIC(R(r_pixel), R(r_pixel), IMM(1) | IMMROR(16),         "BIC     r_pixel,r_pixel,#&10000         ; Discard alpha");
      flags = out_flags;
    }
    else if((pixelformat == PixelFormat_16bpp) && (out_format == PixelFormat_15bpp) && !((flags ^ out_flags) & PixelFormat_RGB))
    {
      /* Trivial case - 16bpp to 15bpp */
      MOV(R(r_temp1), OP2R(R(r_pixel)) | LSRI(6),                "MOV     r_temp1,r_pixel,LSR #6          ; B & G");
      AND(R(r_pixel), R(r_pixel), IMM(31),                       "AND     r_pixel,r_pixel,#31             ; R");
      ORR(R(r_pixel), R(r_pixel), OP2R(R(r_temp1)) | LSLI(5),    "ORR     r_pixel,r_pixel,r_temp1,LSL #5  ; recombined");
      pixelformat = out_format;
      if(out_flags & PixelFormat_Alpha)
        ORR(R(r_pixel), R(r_pixel), IMM(2) | IMMROR(18),         "ORR     r_pixel,r_pixel,#&8000          ; Set alpha");
      flags = out_flags;
    }
    else
    {
      /* Full processing needed. Pull it apart and put it back together in the right format.
         Basic procedure is:
         * use AND to extract a component
         * ORR it into the output pixel, shifting as appropriate
         * Repeat above for all channels
         * AND with bit expansion mask, and ORR that in at correct shift
         * If alpha needs expanding, and can't use main expansion mask, expand it manually using an immediate constant
         * Also if we've upgraded from 16bpp to 24/32bpp, green needs manual expansion */

      const PixelFormatInfo *in_fmt = pixelformat_info(pixelformat | flags);
      const PixelFormatInfo *out_fmt = pixelformat_info(out_format | out_flags);
      /* Try hard to eliminate an extra instruction by choosing the right component to start with */
      int done_channels = 0;
      for(int i=3;i>=0;i--)
      {
        /* Skip alpha channel if it doesn't exist in one or the other */
        if(!out_fmt->bits[i] || !in_fmt->bits[i])
        {
          assert(i == 3, ERROR_FATAL);
          done_channels = 8;
          continue;
        }
        /* If we have 1 bit alpha, and we're wanting to expand it, it's better to store it in the PSR than to mask-and-shift (especially for this first channel)
           The same technique is also worthwhile when we're shrinking down to 1bpp alpha. But not with any formats we currently support, so ignore that potential optimisation for now. */
        if((i == 3) && (in_fmt->bits[i] == 1) && (out_fmt->bits[i] >= 1))
        {
          IFDEBUG(do_sprintf(a,                                  "TST     r_pixel,#1<<%i                  ; check alpha",1<<(in_fmt->top[3]-1));)
          TST(R(r_pixel),IMM12(1<<(in_fmt->top[3]-1)),a);
          done_channels |= 1<<i;
          continue;          
        }
        /* TODO - use UBFX if possible */
        if((in_fmt->hints & (HINT_HIGHEST<<i)) && (out_fmt->top[i] == out_fmt->bits[i]) && (out_fmt->bits[i] <= in_fmt->bits[i]))
        {
          /* We can merely shift this down into place */
          IFDEBUG(do_sprintf(a,                                  "MOV     r_temp2,r_pixel,LSR #%i         ; reposition %s",in_fmt->top[i]-out_fmt->top[i],COMPONENT_NAME(i));)
          MOV(R(r_temp2), OP2R(R(r_pixel)) | LSRI(in_fmt->top[i]-out_fmt->top[i]),a);
          done_channels |= 1<<i;
          break;
        }
#if 0 /* No current output formats will satisfy these conditions */
        else if((in_fmt->top[i] == in_fmt->bits[i]) && (out_fmt->top[i] == 32) && (out_fmt->bits[i] >= in_fmt->bits[i]))
        {
          /* We can shift this up into place */
          IFDEBUG(do_sprintf(a,                                  "MOV     r_temp2,r_pixel,LSL #%i         ; reposition %s",32-in_fmt->top[i],COMPONENT_NAME(i));)
          MOV(R(r_temp2), OP2R(R(r_pixel)) | LSLI(32-in_fmt->top[i]),a);
          done_channels |= 1<<i;
          break;
        }
#endif
        else if(in_fmt->top[i] == out_fmt->top[i])
        {
          /* A simple mask will do */
          int bits = MIN(in_fmt->bits[i],out_fmt->bits[i]);
          int mask = ((1<<bits)-1)<<(in_fmt->top[i]-bits);
          IFDEBUG(do_sprintf(a,                                  "AND     r_temp2,r_pixel,#&%x           ; extract %s",mask,COMPONENT_NAME(i));)
          AND(R(r_temp2), R(r_pixel), IMM12(mask), a);
          done_channels |= 1<<i;
          break;
        }
        else if(!i)
        {
          /* No other choices left, just go with this one */
          int bits = MIN(in_fmt->bits[i],out_fmt->bits[i]);
          int mask = (1<<bits)-1;
          int shift = in_fmt->top[i]-bits;
          IFDEBUG(do_sprintf(a,                                  "AND     r_temp1,r_pixel,#&%x<<%i       ; extract %s",mask,shift,COMPONENT_NAME(i));)
          AND(R(r_temp1), R(r_pixel), IMM12(mask<<shift), a);
          shift = out_fmt->top[i]-in_fmt->top[i];
          IFDEBUG(do_sprintf(a,                                  "MOV     r_temp2,r_temp1,LS%c #%d        ; reposition %s",(shift>=0?'L':'R'),(shift>=0?shift:-shift),COMPONENT_NAME(i));)
          MOV(R(r_temp2), OP2R(R(r_temp1)) | (shift>=0?LSLI(shift):LSRI(-shift)), a);
          done_channels |= 1;
        }
      }
      /* Process remaining channels */
      for(int i=3;i>=0;i--)
      {
        if(done_channels & (1<<i))
          continue;
        done_channels |= 1<<i;
        int bits = MIN(in_fmt->bits[i],out_fmt->bits[i]);
        int mask = (1<<bits)-1;
        int shift = in_fmt->top[i]-bits;
        IFDEBUG(do_sprintf(a,                                  "AND     r_temp1,r_pixel,#&%x<<%i       ; extract %s",mask,shift,COMPONENT_NAME(i));)
        AND(R(r_temp1), R(r_pixel), IMM12(mask<<shift), a);

        /* If this is the last channel to process, write to r_pixel */        
        int done = (done_channels == 15);

        shift = out_fmt->top[i]-in_fmt->top[i];
        IFDEBUG(do_sprintf(a,                                  "ORR     %s,r_temp2,r_temp1,LS%c #%d        ; reposition %s",(done?"r_pixel":"r_temp2"),(shift>=0?'L':'R'),(shift>=0?shift:-shift),COMPONENT_NAME(i));)
        ORR((done?R(r_pixel):R(r_temp2)), R(r_temp2), OP2R(R(r_temp1)) | (shift>=0?LSLI(shift):LSRI(-shift)), a);
      }  
      /* Apply expansion mask */
      if((in_fmt == ws->pixel_expansion_in) && (out_fmt == ws->pixel_expansion_out))
      {
        IFDEBUG(do_sprintf(a,                                  "AND     r_temp1,r_pixel,r_expansionmask ; get expansion bits %x",ws->pixel_expansion_mask);)
        AND(R(r_temp1), R(r_pixel), OP2R(R(r_expansionmask)), a);
        IFDEBUG(do_sprintf(a,                                  "ORR     r_pixel,r_pixel,r_temp1,LSR #%d ; apply expansion",ws->pixel_expansion_shift);)
        ORR(R(r_pixel), R(r_pixel), OP2R(R(r_temp1)) | LSRI(ws->pixel_expansion_shift), a);
      }
      /* Manually expand green if needed */
      if((pixelformat == PixelFormat_16bpp) && (out_format > PixelFormat_16bpp))
      {
        assert((out_fmt->top[1] == 16) && (out_fmt->bits[1] == 8), ERROR_FATAL);
        AND(R(r_temp1), R(r_pixel), IMM(3) | IMMROR(18),       "AND     r_temp1,r_pixel,#&C000          ; get green expansion bits");
        ORR(R(r_pixel), R(r_pixel), OP2R(R(r_temp1)) | LSRI(6),"ORR     r_pixel,r_pixel,r_temp1,LSR #6  ; apply expansion");
      }
      /* Set alpha if needed */
      if((out_flags & PixelFormat_Alpha) && !(flags & PixelFormat_Alpha))
      {
        /* Note that this 'set alpha' message is different from the other one. If they are the same, norcroft doesn't seem to call do_sprintf, or somehow messes it up so completely that 'a' doesn't get updated! */
        IFDEBUG(do_sprintf(a,                                  "ORR     r_pixel,r_pixel,#&%x      ; Set alpha (2)",PIXELFORMAT_ALPHA_MASK(out_format | out_flags));)
        ORR(R(r_pixel),R(r_pixel),out_fmt->alphaimm12 | (1<<25),a);
      }
      else if((out_fmt->bits[3] > in_fmt->bits[3]) && (in_fmt->bits[3] != ws->pixel_expansion_shift))
      {
        /* Manual alpha expansion */
        if(in_fmt->bits[3] == 1)
        {
          /* Alpha flag will have been stored in the PSR earlier. Add it back in to the pixel. */
          IFDEBUG(do_sprintf(a,                                "ORRNE   r_pixel,r_pixel,#&%x            ; Apply alpha",PIXELFORMAT_ALPHA_MASK(out_format | out_flags));)
          ORR(R(r_pixel),R(r_pixel),NE | out_fmt->alphaimm12 | (1<<25),a);
        }
        else
        {
          int bits = out_fmt->bits[3]-in_fmt->bits[3];
          int mask = (1<<bits)-1;
          int shift = out_fmt->top[3]-bits;
          IFDEBUG(do_sprintf(a,                                  "AND     r_temp1,r_pixel,#&%x<<%i          ; extract alpha expansion bits",mask,shift);)
          AND(R(r_temp1), R(r_pixel), IMM12(mask<<shift), a);
          shift = in_fmt->bits[3];
          IFDEBUG(do_sprintf(a,                                  "ORR     r_pixel,r_pixel,r_temp1,LSR #%d   ; apply expansion",shift);)
          ORR(R(r_pixel), R(r_pixel), OP2R(R(r_temp1)) | LSRI(shift), a);
        }
      }
      /* And that should be it */
      pixelformat = out_format;
      flags = out_flags;
    }
    /* Recombine pixelformat */
    pixelformat = (PixelFormat) (pixelformat | flags);
  }

  assert(pixelformat == out_pixelformat, ERROR_FATAL); /* If this hasn't happened, we haven't completed the transformation. */
}

static void translate_pixel(asm_workspace *wp, workspace *ws)
/* Translate r_pixel from being a source pixel, to being a destination pixel.
 *
 * Requirements:
 * ws->in_pixelformat valid
 * ws->out_pixelformat valid
 * ws->gcol valid
 * ws->odither valid
 * wp->trns_palette valid
 * wp->ColourTTR valid
 * ws->ColourTTRFormat valid
 * wp->BPP valid
 * wp->BPC valid
 * wp->Log2bpp valid
 * dither_expansion_init() called
 * r_pixel allocated
 * r_table allocated if necessary
 */
{
  PixelFormat pixelformat = ws->in_pixelformat;

  if (PLOTMASK || TRANSMASK)
  {
    if (((ws->gcol & 7) == 2) && ((pixelformat & PixelFormat_BPPMask) != PixelFormat_32bpp)) /* AND plot action */
    {
      MOV(R(r_pixel), OP2R(R(r_pixel)) | LSLI(31-(wp->BPP)),  "MOV     r_pixel, r_pixel, LSL 31-out_bpp ;a");
      ORR(R(r_pixel), R(r_pixel), IMM(2) | IMMROR(2),         "ORR     r_pixel,r_pixel,#&80000000       ;a");
      MOV(R(r_pixel), OP2R(R(r_pixel)) | ASRI(31-(wp->BPP)),  "MOV     r_pixel, r_pixel, ASR 31-out_bpp ;a");
    }
    return; /* No more transformation necessary */
  }

  if (ws->odither) add_ordered_dither(wp, ws, pixelformat); /* do ordered dither */

  comment(ws, "Perform any transformation necessary");
  if (wp->trns_palette != 0)
  {
    assert(pixelformat <= PixelFormat_8bpp, ERROR_FATAL);
    if (wp->BPP == 16)
    {
      /* This is a special 16bpp palette created by makepalette16bpp */
      ins(ws, LDR(R(r_pixel), R(r_table))
            | INDEX(R(r_pixel), 2),                     "LDR     r_pixel,[r_table, r_pixel, LSL #2] ; 16bpp palette lookup");
      pixelformat = ws->out_pixelformat;
    }
    else
    {
      ins(ws, LDR(R(r_pixel), R(r_table))
            | INDEX(R(r_pixel), 3),                     "LDR     r_pixel,[r_table, r_pixel, LSL #3] ; standard palette lookup");
      pixelformat = PixelFormat_32bpp_Hi;
    }
  }

  /* Translation table lookup */
  if (wp->ColourTTR != 0)
  {
    comment(ws, "We have a translation table.");
    if (wp->Log2bpp <= 3) /* ie BPP <= 8 */
    {
      if(pixelformat != ws->ColourTTRFormat)
        convert_pixel(wp,ws,pixelformat,ws->ColourTTRFormat);
      ins(ws, LDRB(R(r_pixel), R(r_table)) | INDEX(R(r_pixel), 0),  "LDRB    r_pixel,[r_table, r_pixel]      ; byte table lookup");
    }
    else
    {
      assert(pixelformat <= PixelFormat_8bpp, ERROR_FATAL); /* up to 256 entries in word table */
      assert(pixelformat == ws->ColourTTRFormat, ERROR_FATAL);
      ins(ws, LDR(R(r_pixel), R(r_table)) | INDEX(R(r_pixel), 2),   "LDR     r_pixel,[r_table, r_pixel, LSL #2] ; word table lookup");
    }
    pixelformat = ws->out_pixelformat;              /* we've finished */
  }

  /* Do any extra conversion necessary */
  if(pixelformat != ws->out_pixelformat)
  {
    convert_pixel(wp,ws,pixelformat,ws->out_pixelformat);
    pixelformat = ws->out_pixelformat;
  }

  if (((ws->gcol & 7) == 2) && ((pixelformat & PixelFormat_BPPMask) != PixelFormat_32bpp)) /* AND plot action which did something stupid for 32bpp (GPS)*/
  {
    MOV(R(r_pixel), OP2R(R(r_pixel)) | LSLI(31-(wp->BPP)), "MOV     r_pixel, r_pixel, LSL 31-out_bpp");
    ORR(R(r_pixel), R(r_pixel), IMM(2) | IMMROR(2),         "ORR     r_pixel,r_pixel,#&80000000 ");
    MOV(R(r_pixel), OP2R(R(r_pixel)) | ASRI(31-(wp->BPP)),  "MOV     r_pixel, r_pixel, ASR 31-out_bpp");
  }

  comment(ws, "r_pixel is now a destination pixel.");

  if (DPIXEL_OUTPUT)
    ORR(R(r_pixel), R(r_pixel), OP2R(R(r_pixel)) | LSLI(wp->BPP),   "ORR     r_pixel,r_pixel,r_pixel,LSL #out_bpp:SHR:1 ; double pixel output");

  newline();
}

/**************************************************************************
*                                                                         *
*    Advancing the current pixel.                                         *
*                                                                         *
**************************************************************************/

static void odither_inc(asm_workspace *wp, workspace *ws, int xy)
/* Call every output pixel - alternates the ordered dither addition value
 * xy == 0 for x, 1 for y
 *
 * Requirements:
 * ws->odither valid
 * dither_expansion_init() called
 * r_oditheradd allocated if necessary
 */
{
  if (ws->odither)
    EOR(R(r_oditheradd),R(r_oditheradd), IMM(1 << (ws->odither - xy)) | IMMROR(8),
      xy == 0 ? "EOR     r_oditheradd,r_oditheradd,#odither_eorvalue ; alternate dither offset"
              : "EOR     r_oditheradd,r_oditheradd,#odither_eorvalue:SHR:1 ; alternate dither offset");
  UNUSED(wp);
}

/**************************************************************************
*                                                                         *
*    Misc                                                                 *
*                                                                         *
**************************************************************************/

static int get_key_word(asm_workspace *wp, workspace *ws)
/* Compute the low bits of the key word value */
{
  int key_word;

  key_word = ws->in_pixelformat             /* 0..5 */
               + (ws->out_pixelformat << 6) /* 6..11 */
               + (ws->gcol << 12);          /* 12..14 */
  if (SOURCE_MASK) key_word |= 1<<15;
  if (SOURCE_BPPMASK) key_word |= 1<<16;
  if (wp->trns_palette != 0) key_word |= 1<<17;
  if (wp->ColourTTR != 0) key_word |= 1<<18;
  if (DPIXEL_OUTPUT) key_word |= 1<<19;
  if (DPIXEL_INPUT) key_word |= 1<<20;
  if (PLOTMASK || TRANSMASK) key_word |= 1<<21;
  if (ISTRANS) key_word |= 1<<22;

  /* Bits 23+ are free for putscaled/sprtrans to use as they please */

  return key_word;
}

static void compile_buffer_init(asm_workspace *wp, workspace *ws)
/* We intend to compile some code. Pick a buffer to use, and set up
 * for generating into it. We use a simple round-robin for reusing buffers,
 * rather than attempting to do LRU.
 */
{
  label *p;
  regname *r;
  code_buffer *b = &(ws->buffers[ws->build_buffer]);
  ws->compile_base = &(b->code[0]);
  ws->compile_ptr = ws->compile_base;
  ws->compile_lim = ws->compile_base + BUFSIZE;
  FOR_EACH_LABEL(p) {p->def = 0; p->ref = 0;} /* zap all the labels to be undefined. */
  FOR_EACH_REGISTER_NAME(r) r->regno = -1;
  ws->next_free_reg = 0; /* allocate registers from 0 */
#ifdef DEBUG
  tracef("Compile buffer initialised.\n");
  if(ISTRANS)
  {
    tracef("%t20; Blitting code for %s\n" _
      (TRANSMASK ? "PlotMaskTransformed" : "PlotSpriteTransformed"));
  }
  else
  {
    tracef("%t20; Blitting code for %s, scale factors %i:%i,%i:%i outoffset %x\n" _
      (PLOTMASK ? "PlotMaskScaled" : "PutSpriteScaled") _
      b->xadd - b->xdiv _ b->xdiv _ b->yadd _ b->ydiv _ wp->save_outoffset);
  }
  tracef("%t20; gcol action=%i in-bpp=%i out-bpp=%i in-dpix=%s out-dpix=%s mask=%s 1bppmask=%s palette=%s table=%s\n" _
    ws->gcol _ (1<<wp->save_inlog2bpp) _ wp->BPP _
    whether(DPIXEL_INPUT) _ whether(DPIXEL_OUTPUT) _
    whether(SOURCE_MASK) _ whether(SOURCE_BPPMASK) _
    whether(wp->trns_palette != 0) _ whether(wp->ColourTTR != 0));
  tracef("%t20; Src format=%x Dest format=%x\n" _ ws->in_pixelformat _ ws->out_pixelformat);
  tracef("%t20.; Generated by compiler of (%s %s)\n" _ __DATE__ _ __TIME__);
  comment(ws, "Get register and workspace definitions, turn on listing");
  tracef("%t28.GET     w.GenHdr\n");
  tracef("%t28.OPT     1\n");
#endif
  RN(wp, 12, "workspace pointer")
  RN(sp, 13, "stack pointer")
  RN(lr, 14, "link register")
  RN(pc, 15, "program counter")
  ws->leave_r12_alone = FALSE;  /* by default, compiled code does not have module workspace pointer */
  UNUSED(wp);
}

static void compile_buffer_done(workspace *ws)
/* Finished compiling code sequence. */
{
#ifdef DEBUG
  label *p;
#endif

  tracef("%t28.END\n");
  tracef("Compile buffer done, %i words generated.\n" _ ws->compile_ptr - ws->compile_base);
  /* Increment pointer for next buffer to reuse. */
  ws->build_buffer++;
  if (ws->build_buffer >= NBUFFERS) ws->build_buffer = 0;
#ifdef DEBUG
  /* Check no unresolved references to labels */
  FOR_EACH_LABEL(p)
  {
    IFDEBUG(if(p->ref != 0) tracef("Unresolved reference to label %s at %x\n" _ p->name _ sizeof(int) * (p->ref - ws->compile_base));)
    assert(p->ref == 0, ERROR_FATAL);
  }
#endif
  /* ws->compile_base can be used as the base of the resulting procedure. */
}

/**************************************************************************
*                                                                         *
*    JPEG handling.                                                       *
*                                                                         *
**************************************************************************/

#ifdef ASMjpeg
#include "rojpeg.c"
#endif

/**************************************************************************
*                                                                         *
*    PutScaled                                                            *
*                                                                         *
**************************************************************************/

#include "putscaled.c"

/**************************************************************************
*                                                                         *
*    SprTrans                                                             *
*                                                                         *
**************************************************************************/

#include "sprtrans.c"

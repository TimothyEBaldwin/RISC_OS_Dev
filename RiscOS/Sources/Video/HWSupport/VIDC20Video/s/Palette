; Copyright 2012 Castle Technology Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

GV_WritePaletteEntry ROUT
        ; => r0 = type (0 = normal, 1 = border, 2 = pointer)
        ;    r1 = palette entry 0xBBGGRRSS
        ;    r2 = index
        Push    "r5, lr"
        AND     r4, r1, #&F0            ; Effective 0x000000S0
        MOV     r14, r1, LSR #8
        ORR     r14, r14, r4, LSL #20   ; VIDC20 ordering 0x0SBBGGRR

        LDR     r5, DevDesc
        LDR     r5, [r5, #HALDevice_Address]

        CMP     r0, #1
        BCC     %FT00
        BEQ     %FT01
02
        ; 2 = pointer
        SUB     r4, r2, #1
        CMP     r4, #3
        BCS     %FT20                   ; Colours 1...3 only (0 is transparent)
        ADD     r14, r14, r4, LSL #28   ; Index in bits 28/29
        ADD     r14, r14, #Reg_PointerColour
        STR     r14, [r5]
        B       %FT20
01
        ; 1 = border
        CMP     r2, #0
        BHI     %FT20
        ADD     r14, r14, #Reg_BorderColour
        STR     r14, [r5]
00
        ; 0 = normal
        CMP     r2, #255
        BHI     %FT20

        CMP     r2, #0
        STREQ   r1, SoftPalette0        ; Index 0 needed for readback
        MOVEQ   r4, #-1                 ; Force write to Reg_PaletteAddress
        LDRNE   r4, NextAutoIndex

        TEQ     r4, r2                  ; Is auto increment in sync?
        ADDNE   r4, r2, #Reg_PaletteAddress
        STRNE   r4, [r5]
        ASSERT  Reg_PaletteEntries = 0
        STR     r14, [r5]

        ADD     r4, r2, #1
        AND     r4, r4, #&FF
        STR     r4, NextAutoIndex       ; Track hardware auto increment
20
        MOV     r4, #0
        Pull    "r5, pc"

GV_WritePaletteEntries
        ; => r0 = type (0 = normal, 1 = border, 2 = pointer)
        ;    r1 = array of palette entries 0xBBGGRRSS
        ;    r2 = first index
        ;    r3 = number of entries to write
        CMP     r3, #0
        MOVEQ   r4, #0
        MOVEQ   pc, lr

        Push    "r1-r3, r5-r6, lr"

        ADDS    r14, r2, r3
        BCS     %FT40
        CMP     r14, #256
        BHI     %FT40                   ; More than there are entries in the chip

        CMP     r0, #0
        BNE     %FT20

        ; 0 = normal
        LDR     r6, DevDesc
        LDR     r6, [r6, #HALDevice_Address]

        CMP     r2, #0
        LDREQ   r14, [r1, #0]
        STREQ   r14, SoftPalette0       ; Index 0 needed for readback
        MOVEQ   r4, #-1                 ; Force write to Reg_PaletteAddress
        LDRNE   r4, NextAutoIndex

        TEQ     r4, r2                  ; Is auto increment in sync?
        ADDNE   r4, r2, #Reg_PaletteAddress
        STRNE   r4, [r6]

        ADD     r4, r2, r3
        AND     r4, r4, #&FF
        STR     r4, NextAutoIndex       ; Track hardware auto increment

        MOV     r5, r1
10
        LDR     r1, [r5], #4            ; Palette entry
        AND     r14, r1, #&F0           ; Effective 0x000000S0
        MOV     r1, r1, LSR #8
        ORR     r1, r1, r14, LSL #20    ; VIDC20 ordering 0x0SBBGGRR
        ASSERT  Reg_PaletteEntries = 0
        STR     r1, [r6]
        SUBS    r3, r3, #1
        BNE     %BT10
        B       %FT40
20
        ; 1 = border
        ; 2 = pointer
        MOV     r5, r1
30
        LDR     r1, [r5], #4            ; Palette entry
        BL      GV_WritePaletteEntry
        ADD     r2, r2, #1
        SUBS    r3, r3, #1
        BNE     %BT30
40
        MOV     r4, #0                  ; Claim
        Pull    "r1-r3, r5-r6, pc"

GV_ReadPaletteEntry ROUT
        ; => r0 = type (0 = normal, 1 = border, 2 = pointer)
        ;    r1 = palette entry 0xBBGGRRSS
        ;    r2 = index
        ; <= r1 = effective 0xBBGGRRSS
        CMP     r0, #0

        ; 1 = border
        ; 2 = pointer
        BICHI   r1, r1, #&0F            ; Effective 0xBBGGRRS0
        BHI     %FT10

        ; 0 = normal
        ; VIDC20 has only 4 bits of supremacy
        ; Index 0...15 have individual supremacy
        ;       16...255 use those from index 0
        CMP     r2, #16
        LDRCS   r4, SoftPalette0
        MOVCC   r4, r1
        AND     r4, r4, #&F0            ; Effective 0x000000S0
        BIC     r1, r1, #&FF            ; Effective 0xBBGGRR00
        ORR     r1, r1, r4
10
        ; Claim and return
        MOV     r4, #0
        MOV     pc, lr

        END

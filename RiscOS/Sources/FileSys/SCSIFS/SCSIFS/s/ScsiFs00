; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >ScsiFs00

        TTL     "Declarations and workspace allocation"

        GBLL    T
T       SETL    {TRUE}
        GBLL    F
F       SETL    {FALSE}


        GBLL    OpticalMemorySupport
OpticalMemorySupport  SETL fix_1

        GBLL    IgnoreRecoveredError
IgnoreRecoveredError   SETL fix_3

        GBLL    UseSpecialScatterBlk
UseSpecialScatterBlk   SETL fix_11

        GBLL    FloppySupport
FloppySupport   SETL fix_10

        GBLL    MediaLocking
MediaLocking    SETL T

        GBLL    DoBuffering
DoBuffering     SETL F          ;Read-ahead/write-behind not supported

        GBLL    SeekIsNOP
SeekIsNOP       SETL T          ;Because Rodime RO3000S objects to seek command

        GBLL    CheckXferLen
CheckXferLen    SETL T

;        GBLL    CheckSpareRMA    ; check enough stack before op?
;CheckSpareRMA   SETL F
;ExtraRMA        * 1024 * 33      ; usb mak pkt of 32k, + 1k ???

        GBLL    XferLenMax64K
XferLenMax64K   SETL T

        GBLL    RetryIfBusy
RetryIfBusy     SETL T

        GBLL    BigDisc
BigDisc         SETL T

        GBLL    AutoDetect
AutoDetect      SETL T

        GBLL    HotPlug
HotPlug         SETL AutoDetect :LAND: T

        GBLL    AllowPartitions
AllowPartitions SETL T

        GBLL    Ejecting
Ejecting        SETL F

        GBLL    LeftToDo        ;marker for bits requiring further refinement
LeftToDo        SETL F

        GBLL    Dev
Dev     SETL    test_version

;Debug message switches
        [ Dev
        GBLL    Debug
Debug   SETL    T
        GBLL    SpoolOff
SpoolOff SETL   F       ;T to disable spooling for debug messages
        GBLL    IrqDebug
IrqDebug SETL   F
        ]

        GBLL    Debug1
        GBLL    Debug2
        GBLL    Debug3
        GBLL    Debug4
        GBLL    Debug5
        GBLL    Debug6
        GBLL    Debug7
        GBLL    Debug9

        MACRO
$a      switch  $b
       [ Dev
        [ T ;>>>RCM was F
$a      SETL    $b
        |
$a      SETL    F
        ]
       |
$a      SETL    F
       ]

        MEND

Debug1  switch  F       ;Init/Die/Service entries
Debug2  switch  F       ;SCSI drivers
Debug3  switch  T       ;low level disc op
Debug4  switch  T       ;misc op
Debug5  switch  F       ;SCSI drivers border colours
Debug6  switch  F       ;SCSI drivers tube debug
Debug7  switch  T       ;autodetection
Debug9  switch  F       ;useful routines

        GET     hdr.MyMacros
;        GET     hdr.CoreHdr

bit0    bit 0
bit1    bit 1
bit2    bit 2
bit3    bit 3
bit4    bit 4
bit5    bit 5
bit6    bit 6
bit7    bit 7
bit8    bit 8
bit9    bit 9
bit10   bit 10
bit11   bit 11
bit12   bit 12
bit13   bit 13
bit14   bit 14
bit15   bit 15
bit16   bit 16
bit17   bit 17
bit18   bit 18
bit19   bit 19
bit20   bit 20
bit21   bit 21
bit22   bit 22
bit23   bit 23
bit24   bit 24
bit25   bit 25
bit26   bit 26
bit27   bit 27
bit28   bit 28
bit29   bit 29
bit30   bit 30
bit31   bit 31

EscapeBit       bit 6           ;escape if this bit set in ESC_Status

; Hardware addresses

;IoChip          * &03200000     ;IO controller
;IoControl       * 0


;Cpu

K       * 1024
M       * K*K

PsrMask         * &FC000003
NZCV            * N_bit :OR: Z_bit :OR: C_bit :OR: V_bit

       [ BigDisc
BigBit  * CreateFlag_BigDiscSupport
NewErrorBit * CreateFlag_NewErrorSupport
       |
BigBit  * 0
NewErrorBit * 0
       ]

       [ Ejecting
EjectBit * CreateFlag_FloppyEjects
       |
EjectBit * 0
       ]


;Register allocation

SB      RN 12
StkPtr  RN 13

LF      * 10
CR      * 13
DeleteChar      * 127


PollPeriod * 100  ;centi seconds between upcalls when disc changed works

        ASSERT EscapeBit=&40

AltDefectBit    bit 4   ;use alternative defect map, winnies only
ScatterBit      bit 5
NoEscape        bit 6
NoTimeOut       bit 7
Atomic          * NoEscape :OR: NoTimeOut
BackBitNo       * 8     ;internal use only
BackgroundOp    bit BackBitNo
OpMask          * 2_1111 ;ops 0-15

DiscBits        * 2_111 :SHL: (32-3)    ;In all disc addresses

Podule_DevNo    * 13

; osbyte numbers

OsbyteReadCMOS          * &A1
OsbyteWriteCMOS         * &A2
OsbyteReadResetType     * &FD

; osword numbers
OswordReadClock * 14

; CMOS allocation

                ^ ScsiFsCMOS
CMOSflags       # 1
; b0-b2 number of SCSI discs 0-4
; b3-b5 default drive number - 4   ie  0-3
; b6    unused
; b7    unused
FileCMOS        # 1     ;number of additional file cache buffers
DirCMOS         # 1     ;dir cache size
 [ :LNOT: BigDisc
MapSizeCMOS     # 4     ;map sizes of discs in units of 256 bytes
 ]

Service_SCSIAttached * &20102
Service_SCSIDetached * &20103
 [ AllowPartitions
Service_SCSIMounting * &20104
 ]
Upcall_DriveAdded    * 24
Upcall_DriveRemoved  * 25

        AREA    |!!!Module|, CODE, READONLY

        ORG     0

org

        ENTRY

;Module Header
        ASSERT  {PC}-org=0
        & 0             ;no start entry
        & InitEntry     ;initialisation entry
        & DieEntry
        & ServiceEntry
        & ScsiFsTitle
        & ScsiFsHelpString
        & ComTab
        & SCSIFSSWI_Base
        & SwiEntry
        & SwiNames
        & 0             ;no SWI name decoding code
        & 0
        & ModFlags

        ASSERT  {PC}-org=52

ScsiFsBootText
        =       "Acorn "        ;includes AdfsTitle
ScsiFsTitle
        Text    "SCSIFS"


DieTitle
        =       "FileCore%"
CreateTitle
        Text    "SCSI"


ScsiFsHelpString
        =       "SCSIFS",9,9
        [ Dev
        =       DevVersion," DEVELOPMENT VERSION",0
        |
        =       version," (",date,")",0
        ]
        ALIGN

        LTORG

ModFlags
        DCD     ModuleFlag_32bit

        GET     hdr.MyErrors

; Disc Record

        ^ 0
;
SectorSize      # 1     ;log2 sector size
SecsPerTrk      # 1
Heads           # 1     ;1 for old adfs floppy format
Density         # 1     ;1/2/4 single double quad

;only those above needed for low level drivers

LinkBits        # 1
BitSize         # 1     ;log2 bytes for each bit in map, 0 for old format
RAskew          # 1     ;track to track sector skew for random access
                        ;file allocation
BootOpt         # 1     ;boot option for this disc

LowSector       # 1
Zones           # 1     ;# zones in map
ZoneSpare       # 2     ;# bits in zones after 0 which are not map bits
        ASSERT  (ZoneSpare :MOD: 4)=2
RootDir         aw 4
DiscSize        aw 4

DiscStruc       # 0     ;above entries (except BootOpt) define disc structure

DiscId          aw 2
DiscName        # 10
DiscRecSig      # 0     ;above entries form signature of disc

DiscFlags       # 1
FloppyFlag      bit 0
NeedNewIdFlag   bit 1
AltMapFlag      bit 5
OldMapFlag      bit 6
OldDirFlag      bit 7   ;set <=> old small dirs


;entries below must be valid even when disc rec is not in use
Priority        # 1     ;0 DISC REC UNUSED
                        ;1 to # floppies -> floppy priority level
                        ;&FF good winnie
DiscsDrv        # 1     ;0-7 => drive in, 8 => not in drive, OR DISC REC UNUSED
DiscUsage       # 1     ;tasks using this disc, if >0 disc cant be forgotten
SzDiscRec       # 0

;default last word of disc record
;DiscFlags      0  FLOPPIES NEED NeedNewIdFlag SET INITIALLY
;Priority       0
;DiscsDrv       8
;DiscUsage      0
DefDiscRecEnd   * &00080000


; Drive Record

        ^ 0

DrvFlags                # 1
LostUnitAtn             bit 0
;ResetChangedByStep      bit 3
;ResetChangedByWrite     bit 4
;QuadDrv                 bit 5  ;set if quad
                        ASSERT  MiscOp_PollChanged_EmptyWorks_Flag = bit6
                        ASSERT  MiscOp_PollChanged_ChangedWorks_Flag = bit7

DevNo                   # 3
;HeadPosition            # 4
;PositionUnknown         * bit31
DrvSequenceNum          # 4
SzDrvRec                # 0

        MACRO
$lab    STDevNo $rd,$rdr,$rtemp,$c
        ASSERT  $rtemp<>$rdr
        ASSERT  $rtemp<>$rd
$lab    LDRB$c  $rtemp,[$rdr,#DrvFlags]
        ORR$c   $rtemp,$rtemp,$rd,LSL #8
        STR$c   $rtemp,[$rdr,#DrvFlags]
        MEND


;point Rptr to start of drive record Rindex, must preserve flags

        MACRO
$lab    DrvRecPtr $Rptr,$Rindex,$cond
        ASSERT  $Rptr<>SB
        ASSERT  $Rptr<>PC
        ASSERT  SzDrvRec=8
        ADD$cond $Rptr,SB,$Rindex, LSL #3
        Try8    ADD$cond,$Rptr,$Rptr,(:INDEX:DrvRecs)
        MEND


; DEFECT LIST

; The list consists of words containing the disc address ( in bytes ) of bad
; sectors, the end is marked by a value &200000xx, where &xx forms a check
; byte on the earlier list. The last 64 bytes describe the disc to ADFS.
; Any other bytes may be used as params for the low level drivers

DefectListDiscAdd       * &400+&800
SzDefectList            * &200
DefectEndMark           bit 29
MaxStruc                * 64
        ASSERT  SzDiscRec<=MaxStruc

        ^ 0
                # SzDefectList-MaxStruc-4
ParkDiscAdd     # 4

; OLD FS MAP
        ^ 0
FreeStart       # 82*3  ;table of free space start sectors
EndSpaceList    # 0
                # 1     ;reserved
OldName0        # 5     ;              RETRO DEFINITION
OldSize         # 3     ;size in sectors
Check0          # 1     ;checksum on sector 0

FreeLen         # 82*3  ;table of free space lengths
OldName1        # 5     ;              RETRO DEFINITION
OldId           # 2     ;disc id
OldBoot         # 1     ;boot option
FreeEnd         # 1     ;ptr to end of free space list
Check1          # 1     ;checksum on sector 1

        ASSERT  {VAR}=&200

; New map

                ^ 0
ZoneCheck       # 1
FreeLink        # 2     ;15 bit free space start link
CrossCheck      # 1     ;EORing this byte for all zones should yield &FF

DummyLenBit     bit 31  ;always set

ZoneDiscRecSz   * 60    ;reserve additional bytes
                ASSERT ZoneDiscRecSz>=SzDiscRec

ZoneHead        # ZoneDiscRecSz

Zone0Bits       * ZoneDiscRecSz*8

;zones are followed in RAM by table of one byte of flags per zone

ZoneValid       bit 0
ZoneCompacted   bit 1


; Dir entry
                ^ 0
NameLen         * 10
DirObName       # NameLen
DirLoad         # 4
DirExec         # 4
DirLen          # 4
DirIndDiscAdd   # 3
OldDirObSeq     # 1

OldDirEntrySz   * {VAR}
        ASSERT  OldDirEntrySz=26

NewDirAtts      * OldDirObSeq
ReadBit         * 1
WriteBit        * 2
IntLockedBit    * 4     ;the locked bit is held in bit 2 internally
ExtLockedBit    * 8     ;but is returned in bit 3 externally
DirBit          * 8
NewDirEntrySz   * {VAR}


; Directory Start
                ^ 0
StartMasSeq     # 1
StartHugo       # 4
DirFirstEntry   # 0

; Old Directory End
                ^ 0
                # -1
DirCheckByte    # 0     ;RETRO DEFINITION was reserved

                # -4
EndHugo         # 0

                # -1
EndMasSeq       # 0

                # -14   ;reserved

DirTitleSz      * 19
                # -DirTitleSz
OldDirTitle     # 0

                # -3
OldDirParent    # 0

                # -NameLen
OldDirName      # 0

                # -1
OldDirLastMark  # 0     ;dummy last entry marker

; New Directory End
                ^ 0
                # -1
        ASSERT  DirCheckByte=@

                # -4
        ASSERT  EndHugo=@

                # -1
        ASSERT  EndMasSeq=@

                # -NameLen
NewDirName      # 0

                # -DirTitleSz
NewDirTitle     # 0

                # -3
NewDirParent    # 0

                # -1    ;reserved
                # -1    ;reserved

                # -1
NewDirLastMark  # 0     ;dummy last entry marker

OldDirSize      * &500
NewDirSize      * &800

OldDirTabSz     * (OldDirSize-DirFirstEntry+OldDirLastMark)
NewDirTabSz     * (NewDirSize-DirFirstEntry+NewDirLastMark)
                ASSERT  OldDirTabSz :MOD: OldDirEntrySz = 0
                ASSERT  NewDirTabSz :MOD: NewDirEntrySz = 0
OldDirEntries   * OldDirTabSz / OldDirEntrySz
NewDirEntries   * NewDirTabSz / NewDirEntrySz

        ASSERT  OldDirEntries=47
        ASSERT  NewDirEntries=77

;Filing system control reason codes

FscAddFs        * 12
FscSelectFs     * 14
FscRemoveFs     * 16
FscAdd2ndFs     * 17
FscReadFileType * 18


;MAIN WORKSPACE ALLOCATION

        ^ 0, SB
SCSIFSWorkBase   # 0
Padding          # 4    ;>>>RCM stop 'sbaddr R7, BlockSizes-4' in ScsiFs15 from failing
BlockSizes      a4 4    ;log to base two of block size for device or 0 if not
                        ;mounted yet
 [ :LNOT: BigDisc
MapSizes        a4 4
 ]
FileCorePrivate a4 4
WinnieCallAfter a4 4
 [ BigDisc
FCFeatures      a4 4
FC_Big          * bit0
FC_NewErrors    * bit1
 ]
 [ AllowPartitions
PartitionBaseAdd a4 4*8
 ]
 [ UseSpecialScatterBlk
ScatterFlag    a4 4                         ;Are we converting a save to use scatterblk ?
ScatterData    a4 4                         ;New Length (=Old Length rounded up to next block)
WriteScatBlk   a4 6*4           ;Here is the scatter special block
 ]

 [ HotPlug
AttCBCount      #  1
DetCBCount      #  1
Dieing          #  1
myalign         #  1
 ]
;Low level workspace

Winnies         # 1
 [ FloppySupport:LOR:AutoDetect
Floppies        # 1
                # 2
DrvRecs         # SzDrvRec*8
 ]

 [ UseSpecialScatterBlk
; Block of 0's used for padding writes in special scatter blocks
; Previously SCSIFS used to just source the padding data from &00000000, but
; (a) that's not very nice
; (b) it doesn't work if zero page is relocated
; (c) other alternative locations (e.g. start of RMA) could contain sensitive information the user doesn't want storing to disc
; So as a compromise, sacrifice some RMA to give us a nice safe buffer to use, at least for devices with standard block sizes.
PaddingBlock    # 512
 ]
WorkSize        # 0

        ALIGN
        LTORG


;==============================================================================
;
; Scsi Peripheral Device Types
;
DevDirectAccess                 EQU &00
DevOpticalMemory                EQU &07

;==============================================================================
;
; Control bits in R0 for SWI SCSI_Op
;
CTL_TXNONE                      EQU &00 :SHL: 24
CTL_TXREAD                      EQU &01 :SHL: 24
CTL_TXWRITE                     EQU &02 :SHL: 24
CTL_TXRESERVED                  EQU &03 :SHL: 24
CTL_SCATTER                     EQU &01 :SHL: 26
CTL_NOESCAPE                    EQU &01 :SHL: 27
CTL_RETRYONTIMEOUT              EQU &01 :SHL: 28
CTL_BACKGROUND                  EQU &01 :SHL: 29

;
; Shift factor to convert Filecore control bits into SCSIdriver equivalants
;   ScatterBit   -> CTL_SCATTER
;   NoEscape     -> CTL_NOESCAPE
;   NoTimeOut    -> CTL_RETRYONTIMEOUT
;   BackgroundOp -> CTL_BACKGROUND
;
CTL_cnvt                        EQU 21  ;Shift (left) factor

 [ AutoDetect
        MACRO
$lab    mapDrvToDevLo $rd, $rs, $rdr
 [ "$rdr" = ""
        AND    $rd, $rs, #&FF
        DrvRecPtr $rd, $rd
        ASSERT DevNo :AND: 3 = 1
        LDR    $rd, [$rd, #DevNo :AND::NOT:3]
 |
        LDR    $rd, [$rdr, #DevNo :AND::NOT:3]
 ]
        MOV    $rd, $rd, ASR #8
        MEND

        MACRO
$lab    mapDevToDrvLo $rd, $rs
        ASSERT $rd = R1
        ASSERT $rs = R1
$lab    BIC    R1, R1, #&FF000000
        BL     MapDevToDrv
        MEND
 |
        MACRO
$lab    mapDrvToDevLo $rd, $rs
 [ fix_2
$lab    EOR    $rd, $rs, #4
 |
$lab    BIC    $rd, $rs, #4              ;map drives 4 to 7 to devices 0 to 3
 ]
        MEND

        MACRO
$lab    mapDevToDrvLo $rd, $rs
 [ fix_2
$lab    EOR    $rd, $rs, #4
 |
$lab    ORR    $rd, $rs, #4              ;map drives 4 to 7 to devices 0 to 3
 ]
        MEND

        MACRO
$lab    mapDrvToDevImm $rd, $im
$lab    MOV    $rd, $im :EOR: 4
        MEND
 ]


        LNK     s.ScsiFs05

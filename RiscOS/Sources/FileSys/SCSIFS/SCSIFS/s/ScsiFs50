; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; >ScsiFs50

 TTL    "Initialisation and FS star commands"

FSCreateBlock
 =      EjectBit+CreateFlag_FixedDiscPollChangeSupport
 =      (CreateFlag_DriveStatusWorks:SHR:8)+(BigBit:SHR:8)+(NewErrorBit:SHR:8)
 =      0,fsnumber_SCSIFS
 &      CreateTitle             ;>>>RCM was ScsiFsTitle
 &      ScsiFsBootText
 &      LowLevelEntry
 &      MiscEntry

; >>>>>>>>>
; InitEntry
; >>>>>>>>>

InitEntry ROUT                           ; NO REENTRANCY CHECK NEEDED
 [ Debug1
   mess ,"InitEntry - In",NL
 ]
 Push   "R7-R11,SB,LR"
 MOV    R10,#1          ;init flag
 MOV    R11,R12

 MOV    R0, #ModHandReason_Claim
 MOV    R3, #:INDEX: WorkSize
 SWI    XOS_Module              ;claim workspace
 BVS    %FT95

 MOV    SB, R2
 STR    SB, [R11]

 [ HotPlug
 sbaddr R0, DrvRecs
 MOV    R1, #(-1:SHL:8)
 MOV    R2, #0
 STRB   R2, AttCBCount
 STRB   R2, DetCBCount
 STRB   R2, Dieing
 [ AllowPartitions
 STR    R2, PartitionBaseAdd
 STR    R2, PartitionBaseAdd+4
 STR    R2, PartitionBaseAdd+8
 STR    R2, PartitionBaseAdd+12
 STR    R2, PartitionBaseAdd+16
 STR    R2, PartitionBaseAdd+20
 STR    R2, PartitionBaseAdd+24
 STR    R2, PartitionBaseAdd+28
 ]
 STMIA  R0!, {R1,R2}            ;Drive rec for ScsiFs::0
 STMIA  R0!, {R1,R2}            ;                      1
 STMIA  R0!, {R1,R2}            ;                      2
 STMIA  R0!, {R1,R2}            ;                      3
 STMIA  R0!, {R1,R2}            ;                      4
 STMIA  R0!, {R1,R2}            ;                      5
 STMIA  R0!, {R1,R2}            ;                      6
 STMIA  R0!, {R1,R2}            ;                      7
 ]

 [ FloppySupport
 MOV    R2, #0
 STR    R2, Padding  ;>>>>Init floppy BlockSizes
 STR    R2, BlockSizes          ;Block (sector size) for ScsiFs::4..7

 ASSERT DrvFlags = 0
 ASSERT DevNo = 1
 ASSERT DrvSequenceNum = 4
 ASSERT SzDrvRec = 8
 sbaddr R0, DrvRecs
 MOV    R1, #LostUnitAtn :OR: (-1:SHL:8)
 MOV    R2, #0
 STMIA  R0!, {R1,R2}            ;Drive rec for ScsiFs::0
 STMIA  R0!, {R1,R2}            ;                      1
 STMIA  R0!, {R1,R2}            ;                      2
 STMIA  R0!, {R1,R2}            ;                      3
 |
 MOV    R0, #0
 STR    R0, BlockSizes
 ]

 [ AutoDetect:LAND:{FALSE}
 sbaddr R0, DrvRecs
 MOV    R2, #0
10
 EOR    R14, R2, #4             ; original behaviour: device = drive EOR 4
 STDevNo R14, R0, R3
 ADD    R0, R0, #SzDrvRec
 ADD    R2, R2, #1
 CMP    R2, #8
 BLO    %BT10
 ]

 BL     ReadCMOSflags           ;(->R0,R2,R3,R4,R5,V) read #floppies & winnies
 [ AutoDetect
 BL     ScanDrives
 ]
 [ HotPlug
 MOV    R3, #4
 MOV    R4, #4
 ]
 [ FloppySupport
 STRB   R3, Floppies
 ]
 STRB   R4, Winnies

;Assume for the moment that user wants to start up with dir set as SCSI drives
;remain attached, unlike floppies.


 [ FloppySupport
 ORR    R3, R3, R5, LSL #16     ;Combine floppy count and default drive
 |
 MOV    R3, R5, LSL #16
 ]
 ORR R3,R3,#DriveConfig_StartupOpt_NoDir   ;>>>RCM see what happens
 [ LeftToDo
 ! 0, "Left to do - think about Dir/NoDir bit"
 ; Should we Set it, Clear it or read it from CMOS???
 ; for now, set it (above)
 ]
 ORR    R3, R3, R4, LSL #8      ;OR in number of drives
 BL     ReadDirCMOS             ;(->R0,R4,V)
 BL     ReadFileCMOS            ;(->R0,R5,V)

 [ DoBuffering
        ASSERT F,"Read ahead/write behind NOT supported"
 |
 MOV R5,#0 ;NO background Xfers
 ]

 BL     ReadMapSizeCMOS         ;(->R0,R6,V)
 STR    R6, MapSizes            ;Map sizes for ScsiFs::4..7
 baddr  R0, FSCreateBlock
 baddr  R1, org
 MOV    R2, R11
 SWI    XFileCore_Create        ;(R0-R6->R0-R2,V)
 BVS    %FT85
 STR    R0, FileCorePrivate
 STR    R2, WinnieCallAfter
 [ BigDisc
 MOV    R8, R0
 MOV    R0, #6
 SWI    XFileCore_MiscOp        ;(R0,R8->R0,V)
 MOVVC  R7, #FC_Big
 MOVVS  R7, #0
 SWI    XFileCore_Features
 SUBVSS R0, R0, R0              ;R0=0, V cleared
 TST    R0, #Feature_NewErrors
 ORRNE  R7, R7, #FC_NewErrors
 STR    R7, FCFeatures
 ]
 [ Debug1
   mess ,"InitEntry - Out",NL
 ]
 Pull   "R7-R11,SB,PC"

 LTORG



; >>>>>>>>
; DieEntry
; >>>>>>>>

DieEntry
 [ Debug1
   mess ,"DieEntry",NL
 ]
 Push   "R7-R11,SB,LR"
 getSB

 [ HotPlug
 MOV    R0, #1
 STRB   R0, Dieing                      ; prevent any further callbacks
 LDRB   R0, AttCBCount
 TEQ    R0, #0
 LDREQB R0, DetCBCount
 TEQ    R0, #0
 BEQ    %ft1                            ; none awaited
; need to let CBs in **********
1
 ]


 MOV    R10,#0                          ;Delete "FileCore%SCSI"
 MOV    R0, #ModHandReason_Delete       ; filecore will close down all
 baddr  R1, DieTitle                    ; open files before dying
 SWI    XOS_Module                      ;
 MOVVS  R9, R0

 MOV    R5, #0
 sbaddr R7, BlockSizes-4
01
 [ HotPlug
 MOV    R0, #Upcall_DriveRemoved
 MOV    R1, R5
 BL     UpcallDrive
 ]
 LDRB   R4, [R7, R5]
 TST    R4, #&FF
 BEQ    %FT02
 mapDrvToDevLo R1, R5
 [ MediaLocking
 BL     UnLockMedia
 ]
 MOV    R0, #2                  ;RC for ReleaseDevice
 MOV    R8, R12                 ;Access key
 SWI    XSCSI_Reserve
02
 MOVVS  R9, R0
 ADD    R5, R5, #1              ;Next drive
 CMP    R5, #8
 BNE    %BT01                   ;Loop until no more drives

85
 MOVVS  R9, R0
 MOV    R0, #ModHandReason_Free
 MOV    R2, SB
 SWI    XOS_Module          ;Free workspace
 [ Dev
 wrhex  R0, VS
 mess   VS,"Heap error",NL
 ]
95
 MOVVS  R9, R0
 [ Dev
 wrhex  R10,VS
 wrhex  R0, VS
 mess   VS,"Error",NL
 ]

 ADDS   R0, R9, #0
 ADDNES R10,R10,#0       ;only error on init (R10=0/1 for Die/Init)
 Pull   "R7-R11,SB,PC",EQ

 BL     SetV
 [ Dev
 wrhex  R0
 mess   ,"ScsiFs Init Error",NL
 ]
 Pull   "R7-R11,SB,PC"

 LTORG

ServiceTable
 DCD    0
 DCD    ServiceEntry2
 DCD    Service_Reset
 [ HotPlug
 DCD    Service_SCSIAttached
 DCD    Service_SCSIDetached
 ]
 DCD    0

;>>>>>>>>>>>>
;ServiceEntry
;>>>>>>>>>>>>

 DCD    ServiceTable
ServiceEntry
 MOV    R0, R0
 CMP    R1, #Service_Reset
 [ HotPlug
 Push   "LR"
 ASSERT Service_SCSIAttached >= 0x10000
 LDRNE  LR,=Service_SCSIAttached
 CMPNE  R1,LR
 ADDNE  LR,LR,#Service_SCSIDetached - Service_SCSIAttached
 CMPNE  R1,LR
 Pull   "PC",NE
 Pull   "LR"
 |
 MOVNE  PC, LR
 ]

ServiceEntry2
 [ HotPlug
 TEQ    R1, #Service_Reset
 BNE    ServiceAttachDetach
 ]
 [ Debug1
   mess ,"ServiceEntry, Service_Reset",NL
 ]
 Push   "R0-R5,R8,LR"
 getSB
 [ T
;
;Reservations are lost over reset, so Re-reserve each device/drive with
; a non-zero BlockSize entry
;
 MOV    R5, #0
 sbaddr R4, BlockSizes-4
101
 LDRB   LR, [R4, R5]
 TST    LR, #&FF
 BEQ    %FT102
 mapDrvToDevLo R1, R5
 BL     ReserveDevice
102
 ADD    R5, R5, #1              ;Next drive
 CMP    R5, #8
 BNE    %BT101                  ;Loop until no more drives
 |
 MOV    R0, #0                  ;Reservation lost over reset, force 'Examine'
 STR    R0, BlockSizes          ; on next access
 ]

 Pull   "R0-R5,R8,LR"
 MOV    PC, LR


DoSwiRetryDiscOp ROUT
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_DiscOp
 Pull   "R8,PC"


DoNulSwi
 MOV    PC,LR


DoSwiDrives ROUT
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_Drives
 Pull   "R8,PC"


DoSwiFreeSpace ROUT
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_FreeSpace
 Pull   "R8,PC"

DoSwiMiscOp ROUT
 Push    "R8,LR"
 LDR     R8, FileCorePrivate
 SWI     XFileCore_MiscOp
 Pull    "R8,PC"

 [ BigDisc
DoSwiSectorDiscOp ROUT
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_SectorDiscOp
 Pull   "R8,PC"

DoSwiDiscOp64 ROUT
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_DiscOp64
 Pull   "R8,PC"

DoSwiFreeSpace64 ROUT
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_FreeSpace64
 Pull   "R8,PC"
 ]

;Retry word = (Retry word BIC R0) EOR (R1 AND R0)
;exit R1 = R1 AND R0
; R2 old value, R3 new value

DoSwiDescribeDisc ROUT
 Push   "R8,LR"
 LDR    R8, FileCorePrivate
 SWI    XFileCore_DescribeDisc
 Pull   "R8,PC"


;
; DoSwiTestReady
; ==============
;
; On entry
;   R1 = Drive number (4..7)
;
; On exit
;   R0 = 0 - Drive NOT present
;   R1 = 1 - Don't know
;   R2 = 2 - Drive present & ready
;
DoSwiTestReady
 Push   "R1,R2,LR"
 SUB    StkPtr,StkPtr,#16
 MOV    R0,#2                           ;DetermineDevice
 mapDrvToDevLo R1, R1                   ;map drive onto device
 MOV    R2,StkPtr
 SWI    XSCSI_Initialise
 ADD    StkPtr,StkPtr,#16

 MOVVS  R0,#1
 MOVVC  R0,#2
 CLRV
 Pull   "R1,R2,PC"

 [  AllowPartitions
; On entry
;   R0 = reason code
;   Reason code:  0 = Sector offset for drive 1 in R1 is in R2
;   R1 = Drive number (0..7)
;   R2 = sector offset to base of image
;        This offset is zero by default. It may be changed by this swi
;        at any time, but changing this value after mounting the disc
;        is usually not wise!
;
;   Reason code:  1 = report SCSIFS disc number
; returns
;   R2 = SCSIFS disc icon (0..7), or -1 if none
;
DoSWIPartitions ROUT
 Push   "R1,R2,LR"
 TEQ    R0, #0              ; set partition base
 BNE    %ft1
 CMP    R1, #7
 Pull   "R1,R2,PC", HI
 ADD    LR, SB, R1, LSL #2  ; word offset
 STR    R2, [LR, #:INDEX:PartitionBaseAdd-:INDEX:SCSIFSWorkBase] ; remember
  Pull   "R1,R2,PC"
1
 TEQ    R0, #1              ; report icon used
 Pull   "R1,R2,PC",NE
 Push   "R3,R4"
 MOV    R2, #7
2
 DrvRecPtr  R4, R2
 LDRB   R3, [R4, #:INDEX:DevNo]
 TEQ    R3, R1
 BEQ    %ft3
 SUBS   R2,R2,#1
 BGE    %bt2
3
 Pull   "R3,R4"
 STR     R2,[R13, #4]  ; update R2 return value
 Pull   "R1,R2,PC"
 ]

; >>>>>>>>
; SwiEntry
; >>>>>>>>

SwiEntry ROUT
 Push   "SB,LR"
 getSB
 CMPS   R11,#FirstUnusedSwi
 ADRLO  LR, %FT10
 ADDLO  PC, PC, R11,LSL #2
 B      UnknownSwi
05
 B      DoSwiRetryDiscOp
 B      DoNulSwi
 B      DoSwiDrives
 B      DoSwiFreeSpace

 B      DoNulSwi
 B      DoSwiDescribeDisc
 B      DoSwiTestReady
 B      UnknownSwi

 B      UnknownSwi
 B      UnknownSwi
 B      UnknownSwi
 B      UnknownSwi

 B      DoSwiMiscOp
 [ BigDisc
 B      DoSwiSectorDiscOp
 B      UnknownSwi
 B      UnknownSwi

 B      UnknownSwi
 B      UnknownSwi
 B      DoSwiFreeSpace64
 B      UnknownSwi

 B      DoSwiDiscOp64
 |
 B      UnknownSwi
 B      UnknownSwi
 B      UnknownSwi

 B      UnknownSwi
 B      UnknownSwi
 B      UnknownSwi
 B      UnknownSwi

 B      UnknownSwi
 ]
 [ AllowPartitions
 B      DoSWIPartitions
 |
 B      UnknownSwi
 ]


FirstUnusedSwi  * (.-%BT05)/4

10      TEQ     PC,PC
        Pull    "SB,PC",EQ
        Pull    "SB,LR"
        MOVVCS  PC,LR
        ORRVSS  PC,LR,#V_bit

UnknownSwi
; SWI out of range: set R0 -> international error block

        Push    "R1-R7"

        ADR     R0,BadSWIErrBlk         ; R0 -> error block
        MOV     R1,#0
        MOV     R2,#0
        ADR     R4,SwiNames             ; R4 -> parameter to substitute
        MOV     R5,#0
        MOV     R6,#0
        MOV     R7,#0
        SWI     XMessageTrans_ErrorLookup

        Pull    "R1-R7"
        B       %BT10

SwiNames ROUT
 = "SCSIFS",0
 = "DiscOp",0
 = "NOP",0
 = "Drives",0
 = "FreeSpace",0
 = "NOP",0
 = "DescribeDisc",0
 = "TestReady",0
 = "7",0
 = "8",0
 = "9",0
 = "10",0
 = "11",0
 = "MiscOp",0
 = "SectorDiscOp",0
 = "14",0
 = "15",0
 = "16",0
 = "17",0
 = "FreeSpace64",0
 = "19",0
 = "DiscOp64",0
 = "Partitions",0
 = 0
 ALIGN

BadSWIErrBlk            MakeErrorBlock          ModuleBadSWI

FsCom   bit     (31-24)

 MACRO
 ComEntry $Com,$MinArgs,$MaxArgs,$GsTransBits,$HiBits
 ASSERT $MinArgs<=$MaxArgs
Com$Com DCB     "$Com",0
 ALIGN
 DCD    Do$Com
 =       $MinArgs
 =       $GsTransBits
 =       $MaxArgs
 =       $HiBits
 DCD    Syn$Com
 DCD    Help$Com
 MEND


 MACRO
 Config $Com
 DCB    "$Com",0
 ALIGN
 DCD    Con$Com
 DCD    bit30
 DCD    0
 DCD    ConHelp$Com
 MEND

ComTab                                  ;general star commands
 ComEntry SCSI,          0,0,0,0
                                        ;filing system star commands
                                        ;status/configure optioms
 [ DoBuffering
 Config SCSIFSbuffers
 ]
 Config SCSIFSDirCache
 [ :LNOT:HotPlug
 [ FloppySupport
 Config SCSIFSFloppies
 ]
 Config SCSIFSdiscs
 ]
 Config SCSIFSdrive

 =      0
 ALIGN


; >>>>>>
; DoSCSI
; >>>>>>

DoSCSI
 Push   "LR"             ; NO REENTRANCY CHECK NEEDED
 MOV    R0, #FscSelectFs
 baddr  R1, CreateTitle         ;>>>RCM was ScsiFsTitle
 SWI    XOS_FSControl
 Pull   "PC"


; CONFIGURE/STATUS HANDLERS

 [ DoBuffering
; >>>>>>>>>>>>>>>>
; ConSCSIFSbuffers
; >>>>>>>>>>>>>>>>

ShortConSynSCSIFSbuffers
 = "SCSIFSbuffers <D>",0
 ALIGN

ConSCSIFSbuffers
 Push   "R0-R6,SB,LR"
 getSB
 MOVS   R1, R0
 BNE    %FT05

; print syntax message
 baddr  R0, ShortConSynSCSIFSbuffers
 SWI    XOS_Write0
 SWIVC  XOS_NewLine
 B      ConfigReturn

05
 TEQS   R1, #1
 BNE    %FT15

; print status message
 BL     ReadFileCMOS    ;(->R0,R5,V)
 BVS    ConfigReturn
 SWI    XOS_WriteS
 Text   "SCSIFSbuffers"
 BVS    ConfigReturn
10
 MOV    R0, R5
 BL     WrDec           ;(R0->R0,V)
 SWIVC  XOS_NewLine     ;(->R0,V)
 B      ConfigReturn

; parse configure
15
 MOV    R0, #10 :OR: bit31 :OR: bit30
 SWI    XOS_ReadUnsigned        ;(R0-R2->R0-R2,V)
 BVS    ConfigReturn
 MOV    R1, #FileCMOS
 B      ConWrite
 ]


; >>>>>>>>>>>>>>>>>
; ConSCSIFSDirCache
; >>>>>>>>>>>>>>>>>

ShortConSynSCSIFSDirCache
 = "SCSIFSDirCache <D>[K]",0
 ALIGN

ConSCSIFSDirCache
 Push   "R0-R6,SB,LR"
 getSB
 MOVS   R1, R0
 BNE    %FT05

; print syntax message
 baddr  R0, ShortConSynSCSIFSDirCache
 SWI    XOS_Write0
 SWIVC  XOS_NewLine
 B      ConfigReturn

05
 TEQS   R1, #1
 BNE    %FT15

; print status message
 BL     ReadDirCMOS    ;(->R0,R4,V)
 BVS    ConfigReturn
 SWI    XOS_WriteS
 Text   "SCSIFSDirCache"
 BVS    ConfigReturn
10
 MOV    R0, R4, LSR #10
 BL     WrDec           ;(R0->R0,V)
 MOVVC  R0, #"K"
 SWIVC  XOS_WriteC
 SWIVC  XOS_NewLine     ;(->R0,V)
 B      ConfigReturn

; parse configure
15
 MOV    R0, #10 :OR: bit30
 SWI    XOS_ReadUnsigned        ;(R0-R2->R0-R2,V)
 BVS    ConfigReturn
 MOV    R1, #DirCMOS
 B      ConWrite

ShortConSynSCSIFSdrive
 = "SCSIFSdrive <D>",0
 ALIGN

; >>>>>>>>>>>>>>
; ConSCSIFSdrive
; >>>>>>>>>>>>>>

ConSCSIFSdrive ROUT
 Push   "R0-R6,SB,LR"
 getSB
 MOVS   R1, R0
 BNE    %FT05

; print syntax message
 baddr  R0, ShortConSynSCSIFSdrive
 SWI    XOS_Write0
 SWIVC  XOS_NewLine
 B      ConfigReturn

05
 BL     ReadCMOSflags   ;(->R0,R2,R4,R5,V)
 BVS    ConfigReturn
 TEQS   R1, #1
 BNE    %FT15

; print status message
 SWI    XOS_WriteS
 Text   "SCSIFSDrive"
 BVS    ConfigReturn
10
 MOV    R0, R5
 BL     WrDec           ;(R0->R0,V)
 SWIVC  XOS_NewLine     ;(->R0,V)
 B      ConfigReturn

; parse configure
15
 BIC    R2, R2, #2_00111000                     ;clear old bits
 BL     ParseAnyDrive           ;(R1->R0,R1,V)
 BVS    ConfigReturn
 ORR    R2, R2, R0, LSL #3      ;form new byte
 MOV    R1, #CMOSflags
 B      ConWrite

 [ :LNOT:HotPlug
 [ FloppySupport
; >>>>>>>>>>>
; ConSCSIFSFloppies
; >>>>>>>>>>>

ShortConSynSCSIFSFloppies
 = "SCSIFSFloppies   <D>",0
 ALIGN

ConSCSIFSFloppies ROUT
 Push   "R0-R6,SB,LR"
 getSB
 MOVS   R1, R0
 BNE    %FT05

; print syntax message
 baddr  R0, ShortConSynSCSIFSFloppies
 SWI    XOS_Write0
 SWIVC  XOS_NewLine
 B      ConfigReturn

05
 BL     ReadCMOSflags    ;(->R0,R2,R4,R5,V)
 BVS    ConfigReturn
 TEQS   R1, #1
 BNE    %FT15

; print status message
 SWI    XOS_WriteS
 Text   "SCSIFSFloppies  "
 BVS    ConfigReturn
10
 MOV    R0, R3
 BL     WrDec           ;(R0->R0,V)
 SWIVC  XOS_NewLine     ;(->R0,V)
 B      ConfigReturn

; parse configure
15
 BIC    R3, R2, #2_11000000                     ;clear old bits
 MOV    R0, #10 :OR: bit31 :OR: bit29
 MOV    R2, #4
 SWI    XOS_ReadUnsigned        ;(R0-R2->R0-R2,V)
 BVS    ConfigReturn
 ORR    R2, R3, R2, LSL #6      ;form new byte
 MOV    R1, #CMOSflags
 B      ConWrite
 ]


; >>>>>>>>>>>>>>
; ConSCSIFSdiscs
; >>>>>>>>>>>>>>

ShortConSynSCSIFSdiscs
 = "SCSIFSdiscs <D>",0
 ALIGN

ConSCSIFSdiscs ROUT
 Push   "R0-R6,SB,LR"
 getSB
 MOVS   R1, R0
 BNE    %FT05

; print syntax message
 baddr  R0, ShortConSynSCSIFSdiscs
 SWI    XOS_Write0
 SWIVC  XOS_NewLine
 B      ConfigReturn

05
 BL     ReadCMOSflags   ;(->R0,R2,R4,R5,V)
 BVS    ConfigReturn
 TEQS   R1, #1
 BNE    %FT15

; print status message
 SWI    XOS_WriteS
 Text   "SCSIFSdiscs"
 BVS    ConfigReturn
10
 MOV    R0, R4
 BL     WrDec           ;(R0->R0,V)
 SWIVC  XOS_NewLine     ;(->R0,V)
 B      ConfigReturn

; parse configure
15
 BIC    R3, R2, #2_00000111                     ;clear old bits
 MOV    R0, #10 :OR: bit31 :OR: bit29
 MOV    R2, #4
 SWI    XOS_ReadUnsigned        ;(R0-R2->R0-R2,V)
 BVS    ConfigReturn
 ORR    R2, R3, R2              ;form new byte
 MOV    R1, #CMOSflags
 ] ; :LNOT:HotPlug

ConWrite
 MOV    R0, #OsbyteWriteCMOS
 SWI    XOS_Byte    ;(R0-R2->R0-R2,V)
ConfigReturn
 STRVS  R0, [SP]
 Pull   "R0-R6,SB,PC"

 END

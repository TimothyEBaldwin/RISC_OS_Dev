; Copyright 2002 Tematic Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; -> hdr.MyMacros


; =============================================
; Macros should be kept in ALPHABETICAL order !
; =============================================

;*************************************************
; MOVES REGISTER TO NEXT ALIGNMENT OR STAYS WHERE IT IS
; Flags and $temp corrupted
;*************************************************
        MACRO
$label  ALIGNREG $reg
$label  TST   $reg, #3
        ADDNE $reg, $reg, #4
        BICNE $reg, $reg, #3
        MEND

; ************************************
; ***  Call the byte copy routine  ***
; ************************************

; Note: This is purely for ease rather than elegance, sorry (JRF)
        MACRO
$var    CD_ByteCopy  $cond
 [ UseSWICDByteCopy
        SWI$cond     XCD_ByteCopy
 |
        BL$cond      MyCD_ByteCopy
 ]
        MEND

;********************************************************
;********************************************************

; This converts an ISO or HISIERRA date to an ARCHY centi-second date

;********************************************************
;********************************************************
; $from -> 6 byte block, $to -> put 5 byte Archy block

        MACRO
$label  ConvertToArchyDate $from, $to, $temp1, $temp2, $temp3, $temp4, $temp5, $temp6
$label  LDRB    $temp1, [ $from, #0 ]              ; R1 = year ( from 1900 )

        LDR     $temp2, =365                       ; ( year * 365 ) + ( year DIV 4 )
        MOV     $temp4, $temp1, ASR #2             ;
        MLA     $temp3, $temp2, $temp1, $temp4     ;

        LDR     $temp2, =6 * 15 * 25 * 15          ; result * numberofcentisecondsayear / 256
        MUL     $temp3, $temp2, $temp3             ;

        MOV     $temp6, $temp3, ASR #24            ; h/b of result ( ignore bits 8 to 31 )

        MOV     $temp5, $temp3, ASL #8             ; l/bs of result

        LDRB    $temp1, [ $from, #1 ]              ; month ( 1 to 12 )

        ADRL    $temp4, DaysInMonth - 4            ; R3 = cumulative total of days up to that month
        LDR     $temp3, [ $temp4, $temp1, ASL #2 ] ;
        LDRB    $temp4, [ R0, #2 ]                 ; day
        ADD     $temp3, $temp3, $temp4             ;
        MUL     $temp4, $temp3, $temp2             ; R4 = R3 * 6 * 15 * 15 * 25


        ADD     $temp5, $temp5, $temp4, ASL #8     ; l/bs of result
        MOV     $temp3, $temp4, ROR #24            ; h/b of result
        AND     $temp3, $temp3, #&FF               ;
        ADD     $temp6, $temp6, $temp3             ;

        LDRB    $temp2, [ $from, #3 ]              ; l/bs hourcentiseconds
        LDR     $temp1, =60*60*100                 ;
        MLA     $temp5, $temp1, $temp2, $temp5     ;

        LDR     $temp1, =60*100                    ; l/bs minutecentiseconds
        LDRB    $temp2, [ $from, #4 ]              ;
        MLA     $temp5, $temp1, $temp2, $temp5     ;

        LDRB    $temp1, [ $from, #5 ]              ; l/bs of secondcentiseconds
        MOV     $temp2, #100                       ;
        MLA     $temp5, $temp1, $temp2, $temp5     ;

        STR     $temp5, [ $to ]
        STRB    $temp6, [ $to, #4 ]
        MEND

; **********************************************************
; This will print an inline message if 'debug' = ON.
; **********************************************************
        MACRO
$label  DebugInline $string,$nl
;$label  [ debug=ON
;        Push "R14"
;         [ hostvdu
;        SWI XHostFS_HostVdu
;         ]
;        SWI XOS_WriteS
;        = "$string"
;         [ "$nl"="NL"
;        = 13,10
;         ]
;        = 0
;        ALIGN
;         [ hostvdu
;        SWI XHostFS_TubeVdu
;         ]
;        Pull "R14"
;        ]
        MEND

; **********************************************************
; This will print a new line if 'debug' = ON.
; **********************************************************
        MACRO
$label  DebugNewLine
;$label  [ debug
;        Push "R14"
;         [ hostvdu
;        SWI XHostFS_HostVdu
;         ]
;        SWI XOS_NewLine
;         [ hostvdu
;        SWI XHostFS_TubeVdu
;         ]
;        Pull "R14"
;        ]
        MEND

; **********************************************************
; This will perform a XOS_Write0 if 'debug' = ON.
; **********************************************************
        MACRO
$label  Debug0 $string,$nl
;$label  [ debug
;        Push "R14"
;         [ hostvdu
;        SWI XHostFS_HostVdu
;         ]
;        SWI XOS_Write0
;         [ "$nl"="NL"
;        SWI XOS_NewLine
;         ]
;         [ hostvdu
;        SWI XHostFS_TubeVdu
;         ]
;        Pull "R14"
;        ]
        MEND

; **********************************************************
; This will perform a Display if 'debug' = ON.
; **********************************************************
        MACRO
$label  DebugDisplay $string,$nl
;$label  [ debug
;        Push "R14"
;         [ hostvdu
;        SWI XHostFS_HostVdu
;         ]
;        Display $string,$nl
;         [ hostvdu
;        SWI XHostFS_TubeVdu
;         ]
;        Pull "R14"
;        ]
        MEND

; **********************************************************
; ***                  Unsigned divide by 10             ***
; on entry:
;          $number = value to divide by 10
; on exit:
;          $number=$number / 10
;          $temp1 =$number MOD 10
; **********************************************************
        MACRO
$label  DivideBy10 $number, $temp1, $temp3
$label  MOV     $temp1,$number
        MOV     $number,$number,LSR #1
        ADD     $number,$number,$number,LSR #1
        ADD     $number,$number,$number,LSR #4
        ADD     $number,$number,$number,LSR #8
        ADD     $number,$number,$number,LSR #16
        MOV     $number,$number,LSR #3
        ADD     $temp3,$number,$number,LSL #2
        SUB     $temp1,$temp1,$temp3,LSL #1
        CMP     $temp1,#10
        ADDGE   $number,$number,#1
        SUBGE   $temp1,$temp1,#10
        MEND

;***********************************************************************
; This pulls from a full-descending stack ( -> R13 )
;***********************************************************************

        MACRO
$label  PushAllWithReturnFrame $cond
$label  Push     "R0-R11,R14", $cond
        STR$cond sp, stackreturn        ; Return frame, no reentrancy!
        MEND

        MACRO
$label  PullAllFromFrame $cond
$label  LDR$cond sp, stackreturn
        Pull     "R0-R11,R14", $cond
        MEND

        MACRO
$label  PullAllFromFrameAndExit $cond, $keep
$label  LDR$cond sp, stackreturn
      [ "$keep"=""
        Pull     "R0-R11,PC", $cond
      |
        ; Keep the first $keep registers
        ADD$cond sp, sp, #4 * $keep
        DCI      (Cond_$cond :OR: &08BD8FFF) :AND: :NOT: ((1:SHL:$keep) - 1)
      ]
        MEND

; ******************************************************
; ***  Macro Find length of null terminated string   ***
; ******************************************************
        MACRO
$label  LengthOfString $name, $length, $temp
        MOV     $length, #0
01
$label  LDRB    $temp, [ $name, $length ]
        ADD     $length, $length, #1
        CMP     $temp, #0
        BNE     %BT01
        MEND

; ******************************************************
; ***  This is for cdfs to keep a log of calls made  ***
; ******************************************************
        MACRO
$label log_on
$label
      [ log
        Push    "R14"
        LDR     R14, log_pointer
        STR     PC, [ R14 ], #4
        STR     R14, log_pointer
        Pull    "R14"
      ]
      MEND

; ************************************************************************************
; ***  This macro is specialised for XA and is used in 'FileMan' and 'EntryFile'   ***
; *** on entry:                                                                    ***
; ***          $return  =  UNUSED                                                  ***
; ***          $pointer -> object information                                      ***
; ***          $temp1   =  UNUSED                                                  ***
; ***          $temp2   =  UNUSED                                                  ***
; *** on exit:                                                                     ***
; ***          $return  =  1, 2 or 3                                               ***
; ***          $pointer -> preserved                                               ***
; ***          $temp1   =  preserved                                               ***
; ***          $temp2   =  preserved                                               ***
; ************************************************************************************

        MACRO
$label  MACRO__XA_WHAT_DATA_MODE $return, $pointer, $temp1, $temp2
$label  Push    "$temp1, $temp2"
        MOV     $return, # 1
        LDRB    $temp1, [ $pointer, # OBJECT__XA_ATTRIBUTES_LO ]
        LDRB    $temp2, [ $pointer, # OBJECT__XA_ATTRIBUTES_HI ]
        ORR     $temp1, $temp1, $temp2, LSL # 8
        TEQ     $temp1, # 0             ; [ no XA information ]
        BEQ     %FT01
        ; Mode 2 form 2 ?
        TST     $temp1, # ATTRIBUTES__XA_MODE_2_FORM_2
        MOVNE   $return, # 2
        MOVEQ   $return, # 3
01
        Pull    "$temp1, $temp2"
        MEND


; ******************************************************
; ***  Simple SETV and CLRV which are26/32 neutral   ***
; ******************************************************

        MACRO
$label  VCLEAR $cond
$label  CMP$cond R0, #0
        MEND

        MACRO
$label  VSET $cond
      [ "$cond"<>"AL" :LAND: "$cond"<>""
        DCI     &1A000001 :EOR: Cond_$cond ; brach over on opposite condition
      ]
$label  CMP     R0, #&80000000
        CMNVC   R0, #&80000000
        MEND

        END

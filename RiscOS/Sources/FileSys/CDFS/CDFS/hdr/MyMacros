; Copyright 2002 Tematic Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; -> macros


OUTPUT_TO_SCREEN * FALSE

; =============================================
; Macros should be kept in ALPHABETICAL order !
; =============================================

;*************************************************
; MOVES REGISTER TO NEXT ALIGNMENT OR STAYS WHERE IT IS
; Flags and $temp corrupted
;*************************************************
        MACRO
$label  ALIGNREG $reg
$label  TST $reg, #3
        ADDNE $reg, $reg, #4
        BICNE $reg, $reg, #3
        MEND

; ************************************
; ***  Call the byte copy routine  ***
; ************************************

; Note: This is purely for ease rather than elegance, sorry (JRF)
        MACRO
$var    CD_ByteCopy  $cond
 [ UseSWICDByteCopy
        SWI$cond     XCD_ByteCopy
 |
        BL$cond      CD_ByteCopy
 ]
        MEND

;********************************************************
;********************************************************

; This converts an ISO or HISIERRA date to an ARCHY centi-second date

;********************************************************
;********************************************************
; $from -> 6 byte block, $to -> put 5 byte Archy block

        MACRO
$label  ConvertToArchyDate $from, $to, $temp1, $temp2, $temp3, $temp4, $temp5, $temp6
$label  LDRB $temp1, [ $from, #0 ] ; R1 = year ( from 1900 )

 LDR $temp2, =365           ; ( year * 365 ) + ( year DIV 4 )
 MOV $temp4, $temp1, ASR #2 ;
 MLA $temp3, $temp2, $temp1, $temp4         ;

 LDR $temp2, =6 * 15 * 25 * 15  ; result * numberofcentisecondsayear / 256
 MUL $temp3, $temp2, $temp3     ;

 MOV $temp6, $temp3, ASR #24        ; h/b of result ( ignore bits 8 to 31 )

 MOV $temp5, $temp3, ASL #8         ; l/bs of result

 LDRB $temp1, [ $from, #1 ]        ; month ( 1 to 12 )

 ADRL $temp4, DaysInMonth - 4   ; R3 = cumulative total of days up to that month
 LDR $temp3, [ $temp4, $temp1, ASL #2 ] ;
 LDRB $temp4, [ R0, #2 ]        ; day
 ADD $temp3, $temp3, $temp4             ;
 MUL $temp4, $temp3, $temp2             ; R4 = R3 * 6 * 15 * 15 * 25


 ADD $temp5, $temp5, $temp4, ASL #8     ; l/bs of result
 MOV $temp3, $temp4, ROR #24        ; h/b of result
 AND $temp3, $temp3, #&FF           ;
 ADD $temp6, $temp6, $temp3             ;

 LDRB $temp2, [ $from, #3 ]        ; l/bs hourcentiseconds
 LDR $temp1, =60*60*100         ;
 MLA $temp5, $temp1, $temp2, $temp5         ;

 LDR $temp1, =60*100            ; l/bs minutecentiseconds
 LDRB $temp2, [ $from, #4 ]        ;
 MLA $temp5, $temp1, $temp2, $temp5         ;

 LDRB $temp1, [ $from, #5 ]        ; l/bs of secondcentiseconds
 MOV $temp2, #100               ;
 MLA $temp5, $temp1, $temp2, $temp5         ;

 STR $temp5, [ $to ]
 STRB $temp6, [ $to, #4 ]

       MEND

; **********************************************************
; This will print a message if 'debug' = ON.
; **********************************************************
;        MACRO
;$label  Debug $string,$nl
;$label  [ debug=ON
;        STASH R14
;         [ hostvdu=ON
;        SWI XHostFS_HostVdu
;         ]
;        SWI XOS_WriteS
;        = "$string"
;         [ "$nl"="NL"
;        = 13,10
;         ]
;        = 0
;        ALIGN
;         [ hostvdu=ON
;        SWI XHostFS_TubeVdu
;         ]
;        GRAB R14
;        ]
;        MEND

; **********************************************************
; This will print a new line if 'debug' = ON.
; **********************************************************
        MACRO
$label  DebugNewLine
;$label  [ debug=ON
;        STASH R14
;         [ hostvdu=ON
;        SWI XHostFS_HostVdu
;         ]
;        SWI XOS_NewLine
;         [ hostvdu=ON
;        SWI XHostFS_TubeVdu
;         ]
;        GRAB R14
;        ]
        MEND

; **********************************************************
; This will perform a XOS_Write0 if 'debug' = ON.
; **********************************************************
        MACRO
$label  Debug0 $string,$nl
;$label  [ debug=ON
;        STASH R14
;         [ hostvdu=ON
;        SWI XHostFS_HostVdu
;         ]
;        SWI XOS_Write0
;         [ "$nl"="NL"
;        SWI XOS_NewLine
;         ]
;         [ hostvdu=ON
;        SWI XHostFS_TubeVdu
;         ]
;        GRAB R14
;        ]
        MEND

; **********************************************************
; This will perform a Display if 'debug' = ON.
; **********************************************************
        MACRO
$label  DebugDisplay $string,$nl
;$label  [ debug=ON
;        STASH R14
;         [ hostvdu=ON
;        SWI XHostFS_HostVdu
;         ]
;        Display $string,$nl
;         [ hostvdu=ON
;        SWI XHostFS_TubeVdu
;         ]
;        GRAB R14
;        ]
        MEND

; **********************************************************
; ***                  Unsigned divide by 10             ***
; on entry:
;          $number = value to divide by 10
; on exit:
;          $number=$number / 10
;          $temp1 =$number MOD 10
; **********************************************************
  MACRO
$label DivideBy10 $number, $temp1, $temp3
$label MOV     $temp1,$number
       MOV     $number,$number,LSR #1
       ADD     $number,$number,$number,LSR #1
       ADD     $number,$number,$number,LSR #4
       ADD     $number,$number,$number,LSR #8
       ADD     $number,$number,$number,LSR #16
       MOV     $number,$number,LSR #3
       ADD     $temp3,$number,$number,LSL #2
       SUB     $temp1,$temp1,$temp3,LSL #1
       CMP     $temp1,#10
       ADDGE   $number,$number,#1
       SUBGE   $temp1,$temp1,#10
  MEND

;***********************************************************************
; This pulls from a full-descending stack ( -> R13 )
;***********************************************************************

        MACRO
$label  GRABALL $cond
$label  LDR$cond R13, stackreturn
        GRAB "R0 - R11, R14", $cond
        MEND

        MACRO
$label  GRABALLANDRETURN $cond
$label  LDR$cond R13, stackreturn
        GRAB "R0 - R11, PC", $cond
        MEND

        MACRO ; leaves a number of registers alone (from R0 upwards)
$label  GRABALLANDRETURNRESULTS $regs, $cond
$label  LDR$cond R13, stackreturn
        ADD$cond R13, R13, #4 * $regs
        DCI (Cond_$cond :OR: &08BD8FFF) :AND: :NOT: ((1:SHL:$regs) - 1)
        MEND

        MACRO
$label  GRABALLANDRETURNERROR
$label  LDR R13, stackreturn
        ADD R13, R13, #4
        VSET
        GRAB "R1 - R11, PC"
        MEND


; ******************************************************
; ***  Macro Find length of null terminated string   ***
; ******************************************************
        MACRO
$label  LengthOfString $name, $length, $temp
        MOV $length, #0
01
$label  LDRB $temp, [ $name, $length ]
        ADD $length, $length, #1
        CMP $temp, #0
        BNE %BT01
        MEND

;--- This is for cdfs to keep a log of calls made

 MACRO
$label log_on
$label
 [ log=ON
 STASH R14
 LDR R14, log_pointer
 STR PC, [ R14 ], #4
 STR R14, log_pointer
 GRAB R14
 ]
 MEND

; ************************************************************************************
; ***  This macro is specialised for XA and is used in 'FileMan' and 'EntryFile'   ***
; *** on entry:                                                                    ***
; ***          $return  =  UNUSED                                                  ***
; ***          $pointer -> object information                                      ***
; ***          $temp1   =  UNUSED                                                  ***
; ***          $temp2   =  UNUSED                                                  ***
; *** on exit:                                                                     ***
; ***          $return  =  1, 2 or 3                                               ***
; ***          $pointer -> preserved                                               ***
; ***          $temp1   =  preserved                                               ***
; ***          $temp2   =  preserved                                               ***
; ************************************************************************************

        MACRO
$label  MACRO__XA_WHAT_DATA_MODE $return, $pointer, $temp1, $temp2
$label  STASH     "$temp1, $temp2"
        MOV       $return, # 1
        LDRB      $temp1, [ $pointer, # OBJECT__XA_ATTRIBUTES_LO ]
        LDRB      $temp2, [ $pointer, # OBJECT__XA_ATTRIBUTES_HI ]
        ORR       $temp1, $temp1, $temp2, LSL # 8
        TEQ       $temp1, # 0                           ; [ no XA information ]
        BEQ       %FT01
       ; Mode 2 form 2 ?
        TST       $temp1, # ATTRIBUTES__XA_MODE_2_FORM_2
        MOVNE     $return, # 2
        MOVEQ     $return, # 3
01

;        STASH r4
;        STRIM " Data mode = "
;        MOV  r4, $return
;        Display r4
;        STRIM " Flags = "
;        MOV  r4, $temp1
;        Display r4
;        SWI XOS_NewLine
;        GRAB  r4

        GRAB      "$temp1, $temp2"
        MEND

;************************************************************
; This is used by CDFS in 'Test' to set up module entry points
;************************************************************
       MACRO
$label ModuleDescriptionHeader
$label
 DCD 0
 DCD initialisingcode - startofheader
 DCD finalisingcode - startofheader
 DCD servicecode - startofheader
 DCD title - startofheader
 DCD help - startofheader
 DCD KeywordTable - startofheader
 DCD CDFSSWIBaseNumber
 DCD CDFSSWIentry - startofheader
 DCD CDFStableofswinames - startofheader
 DCD 0                                   ; decoding code
 [ LazyIntHelp
 DCD message_filename - startofheader
 |
 DCD 0                                   ; international help
 ]
 DCD ModuleFlags - startofheader

; DCD 0                                   ; code for command
; DCD 1                                   ; information word
; DCD 0                                   ; syntax message
; DCD 0                                   ; help text
       MEND


        MACRO
$label  STASHALL $cond
$label  STASH "R0 - R11, R14", $cond
        STR$cond R13, stackreturn
        MEND


        MACRO
$label  VCLEAR $cond
$label  CMP$cond R0, #0
        MEND

        MACRO
$label  VSET $cond
      [ "$cond"<>"AL" :LAND: "$cond"<>""
        DCI     &1A000001 :EOR: Cond_$cond ; brach over on opposite condition
      ]
$label  CMP     R0, #&80000000
        CMNVC   R0, #&80000000
        MEND

        END

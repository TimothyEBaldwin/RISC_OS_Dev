; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; Open

; PROCS:

; NumberOfNextFreeFileHandle
; INFO                              ; RISC OS 2 only
; AnotherDriveHasBeenAdded
; DisplayHeader                     ; RISC OS 2 only
; CheckDiscName
; ValidatePathName
; ShuffleStringUp       ( used by 'Directory' )
; ConvertBufferSizeToReal
; ConvertRealBufferToSize

;**************************************************************************
NumberOfNextFreeFileHandle ; Returns R0 = number of free handle, 0 if fail
;**************************************************************************

 STASH "R1, R3,R14"

 LDR R1, =:INDEX:OpenFileList       ; R1 -> start of list
 ADD R1, R1, R12                    ;

 MOV R3, #MAXNUMBEROFOPENFILES

search_for_space                    ; look through list

 LDR R14, [ R1 ], #4

 SUBS R3, R3, #1
 TEQNE R14, #0
 BNE search_for_space

 TEQ R14, #0
 RSBEQ R0, R3, #MAXNUMBEROFOPENFILES
 MOVNE R0, #0                       ; If not found then R0 = 0

 GRAB "R1, R3,PC"

 LTORG


;***************************************************************************
AnotherDriveHasBeenAdded ROUT ; R0 = drive number requested

; If an error, then V set, R0 -> error message

;***************************************************************************

 STASH "R0 - R9, R14"

; R5 = drive number requested
; R6 = device id
; R7 -> sparecontrolblock_offset

 LDRB R6, numberofdrives           ; already know the drive number
 CMP R0, R6                        ;
 GRAB "R0 - R9, PC", LO            ; exit, V (almost certainly) clear

;*******************
; Only allow the configured number of drives to be selected
;*******************

 LDR R6, maxnumberofdrives                   ; Error if not configged enough
 TEQ R6, #0
; BEQ %FT32

 SUBNES R6, R6, #1
 ; If 0 drives configged then make an exception

 RSBHSS R14, R0, R6                          ;
 GRAB "R0 - R9, R14", LO

 BLO         baddrive

32

;*******************

; R3 = device id
; R4 = card number
; R5 = LUN
; R6 = drive number requested
; R7 -> control block

 MOV R3, #0
 MOV R4, #3

;----------------------------
; Logical unit number support
;----------------------------

 [ Module_Version >= 218

          MOV        r5, #0
 ]

;----------------------------

 MOV R6, R0


 ADD R7, R12, #:INDEX:sparecontrolblock


; 1. Find a drive that has been turned on

look_for_device


;**************
; CheckIDKnown                    ;
;**************

; R0 = composite id
; R1 -> list
; R2 -> end of list

 ORR R0, R3, R4, LSL #3

;----------------------------
; Added for version 2.18
;----------------------------

          ORR        r0, r0, r5, LSL #5

;----------------------------

 LDR R1, =:INDEX:ListOfDrivesAttached  ; R1 -> first entry
 ADD R1, R1, R12                       ;

 LDRB R2, numberofdrives               ; R2 -> last entry
 ADD R2, R1, R2                        ;

04

 LDRB R14, [ R1 ], #1

 CMP R1, R2
 BHI %FT05                       ; Reached end of list - so NOT FOUND

 TEQ R14, R0

 BNE %BT04

;***************
; Next device
;***************
01                       ; Found the drive - so don't bother to check

;---------------------------------
; Support for Logical Unit Numbers
;---------------------------------

 [ Module_Version >= 218


   [ Module_Version >= 220

; The new way - faster because it searches for devices with LUN 0 first
          ADD        r3, r3, #1                ; Next device id
          ANDS       r3, r3, #2_111

          ADDEQ      r5, r5, #1                ; New LUN
          ANDS       r5, r5, #2_111

          TEQEQ      r3, #0
          SUBEQ      r4, r4, #1                ; Next card
          CMPEQ      r4, #-1                   ; Last card reached ?

   |

          ADD        r5, r5, #1                ; New LUN
          ANDS       r5, r5, #2_111

          ADDEQ      r3, r3, #1                ; Next device id
          ANDS       r3, r3, #2_111

          TEQEQ      r5, #0
          ADDEQ      r4, r4, #1                ; Next card
          TEQEQ      r4, #4                    ; Last card reached ?

    ]
 |

 ; The old way

 ADD R3, R3, #1                  ; Next device id
 ANDS R3, R3, #2_111             ; Next card
 ADDEQ R4, R4, #1                ; Screw the LUN
 TEQEQ R4, #4                    ; Last card reached ?

 ]

;---------------------------------

 BNE look_for_device

 GRAB "R0 - R9, R14"

; Debug "AnotherDriveHasBeenAdded returning error",NL

baddrive
            STASH      "r1-r2, r14"
            addr       r0, baddrive_tag
            ADR        r1, message_block
            MOV        r2, #0
            SWI        XMessageTrans_ErrorLookup
            GRAB       "r1-r2, pc"



;**************
; CheckDevice                     ; Is device a CDROM drive ?
;**************
05

; Make sparecontrolblock = device id

; STASH R6

 MOV R8, #0


;----------------------------------
; Preserve the Logical Unit Numbers
;----------------------------------

 [ Module_Version < 218

 MOV R5, #0

 ]

;----------------------------

 STMIA R7, { R3 - R5, R8 }
 STR R8, [ R7, #16 ]

; GRAB R6

; Request info from drive

 ; Make sure 'Z' set ( ADDS ... )


;-----------------------------------
; Not a good idea to forget the LUN
;-----------------------------------

 [ Module_Version < 218

 MOV R5, #DEVICERETRYCOUNT         ; retry count = 0 ( and 'Z' = 1 )

 ]

;-----------------------------------

06

; 2. Add drive number to list

 SWI      XCD_Identify
 BVS      %BT01

 CMP      r2, #-1
 BEQ      %BT01

 MOV      r9, r2


; R9 = drive type


 LDRB R0, numberofdrives

 LDR R14, =:INDEX:ListOfDrivesAttached
 ADD R14, R12, R14

 ORR R2, R3, R4, LSL #3

;---------------------------------
; Support for logical unit numbers
;---------------------------------

 [ Module_Version >= 218

            ORR        r2, r2, r5, LSL #5

 ]

;---------------------------------

 STRB R2, [ R14, R0 ]

 LDR R14, =:INDEX:DriveTypes
 ADD R14, R14, R12
 STRB R9, [ R14, R0 ]

 ADD R0, R0, #1
 STRB R0, numberofdrives

;************
; Set SCSIControl          ; set the error response of the drive
;************              ;

 MOV R0, #1
 SWI XCD_Control           ; R0 = error level, R7 -> control block


 LDRB R0, numberofdrives   ; Another drive been attached ?
                           ;
 CMP R0, R6                ;
                           ;

 BLS look_for_device

 GRAB "R0 - R9, PC"



;***************************************************************************
CheckDiscName ROUT; R0 -> name, RETURNS R1 = TRUE/FALSE
;***************************************************************************

; ISO Spec allows the following characters in a disc name:

;               A - Z             0 - 9        _

; Justin allows the following characters in a disc name:

;               /   (because otherwise I can't open the linux CD)
;               -   (because otherwise I can't open Jan 1998 MSDN Platform
;                    Archive disc 1)
;               ,   (because someone said they'd found a disc that used that)

; JB .. also allow hard space &A0 and lowercase letters
; This routine converts CR to a null

 STASH "R0, R2"

01

 LDRB R1, [ R0 ], #1

; UpperCase R1, R2            ; Convert to uppercase

 TEQ R1, #&0D                ; Convert CR to null
 TEQNE R1, #SPACE            ; Convert SPACE to null
 MOVEQ R1, #0                ;
 CMP R1, #32
 MOVLE R1, #0

 STRB R1, [ R0, #-1 ]        ; Converted to uppercase, and terminated

; TEQ R1, #0                  ; Either null terminated or CR terminated
 GRAB "R0, R2", LE           ; last entry
 MOVLE R1, #TRUE             ;
 MOVLE PC, R14               ;

 BIC R2, R1, #32             ; clear the upper/lowercase bit
 CMP R2, #"A"                ; characters 'A - Z'
 RSBHSS R2, R2, #"Z"         ;
 BHS %BT01                   ;

 CMP R1, #"0"                ; characters '0 - 9'
 RSBHSS R2, R1, #"9"         ;
 BHS %BT01                   ;

 TEQ R1, #"_"                ; character 'underline'
 [ AllowSlashInDiscName
 TEQNE R1, #"/"              ; character 'slash' (by Justin)
 ]
 [ AllowHyphenInDiscName
 TEQNE R1, #"-"              ; character 'hyphen' (by Justin)
 ]
 [ AllowCommaInDiscName
 TEQNE R1, #","              ; character 'comma' (by Justin)
 ]
 [ AllowHardSpaceInDiscName
 TEQNE R1, #&A0              ; character 'hard space' (by Jwb)
 ]
 BEQ %BT01                   ;

02
 GRAB "R0, R2"
 MOV R1, #FALSE
 MOV PC, R14

 [ {FALSE} ; not used!
;***************************************************************************
ValidatePathName ROUT      ; R0 -> path name
; corrupts 'TempArea'
;***************************************************************************

; This checks a pathname, also converts CR at end to null

; Checks made:
;             1. Path entry is no longer than 'MAXLENGTHOFNAME'
;             2. Number of path entries <= MAXNUMBEROFPATHENTRIES
;             3. Characters in path are ISO valid


 STASH "R0 - R4"

;*******************
; First check the disc name if present ( copy to another area )
;*******************

 LDRB R4, [ R0 ]
 CMP R4, #":"
 BNE %FT02 ;no_disc_name

 ADD R4, R12, #:INDEX:TempArea

 MOV R3, R0

; R3 -> start of path name
; R4 -> TempArea
; R2 = temp


01 ;copy_for_discname_check

 LDRB R2, [ R3, #1 ]!
 STRB R2, [ R4 ], #1
 TEQ R2, #"."
 TEQNE R2, #0

 BNE %BT01 ;copy_for_discname_check

 TEQ R2, #"."

 MOVEQ R2, #0
 STREQB R2, [ R4, #-1 ]

 SUBEQ R3, R3, #1             ; R3 -> start of path name

 BL CheckDiscName             ; R0 -> disc name, RETURNS R1 = TRUE/FALSE

 TEQ R1, #FALSE
          MOVEQ      r0, #ERROR_BADNAME
          BEQ        ErrorExit

 MOV R0, R3                   ; Point R0 at past disc name

;*************
02 ;no_disc_name
;*************

; characters checked for: A - Z  a - z  0 - 9  _ ! $ & ^ * # %

; R0 -> disc name
; R1 = temp
; R4 = number of dots counted

 MOV R4, #0

03 ;validate_path

 LDRB R1, [ R0 ], #1                 ;

 TEQ R1, #"."                        ; Make sure only 8 paths used
 ADDEQ R4, R4, #1                    ;
 TEQEQ R4, #MAXNUMBEROFPATHS         ;
          MOVEQ      r0, #ERROR_BADNAME
          BEQ        ErrorExit


 TEQ R1, #"."
 BEQ %BT03 ;validate_path

 TEQ R1, #"$"
 TEQNE R1, #"%"
 TEQNE R1, #"&"
 TEQNE R1, #"^"
 TEQNE R1, #"/"
 TEQNE R1, #WILDANY
 TEQNE R1, #"@"
 TEQNE R1, #"!"
 TEQNE R1, #WILDCHAR
 TEQNE R1, #REPLACEMENTFORDOT
 BEQ %BT03 ;validate_path

 CMP R1, #"a"                ; characters 'a - z' converted to upper case
 RSBHSS R2, R1, #"z"         ;
 BHS %BT03 ;validate_path     ;

 CMP R1, #"A"                ; characters 'A - Z'
 RSBHSS R2, R1, #"Z"         ;
 BHS %BT03 ;validate_path     ;

 CMP R1, #"0"                ; characters '0 - 9'
 RSBHSS R2, R1, #"9"         ;
 BHS %BT03 ;validate_path     ;

 CMP R1, #"_"                ; character 'underline'
 BEQ %BT03 ;validate_path     ;

 TEQ R1, #13                         ; Convert CR or LF into null
 TEQNE R1, #0                        ;
 TEQNE R1, #SPACE                    ;

        MOVNE     r0, #ERROR_BADNAME
        BNE       ErrorExit

 SUBS R1, R1, R1
 STRB R1, [ R0, #-1 ]

 GRAB "R0 - R4"

 MOV PC, R14
 ]

;***************************************************************************
ConvertBufferSizeToReal ROUT ; R0 = CMOS number, RETURNS R1 = size in K
;    FLAGS CORRUPTED
;***************************************************************************

 STASH "R0, R14"

;**************
; Convert number into a Kbytes value
;**************

 TEQ R0, #0

 MOVEQ R1, #0

 MOVNE R1, #1
 ADDNE R0, R0, #2
 MOVNE R1, R1, ASL R0

 GRAB "R0, PC"

; BICS PC, R14, #Overflow_Flag

;***************************************************************************
ConvertRealBufferToSize ROUT    ; R0 = number of K, RETURNS R1 = bit setting
;***************************************************************************

 STASH "R0, R2"

;**************
; Calculate the actual number to go in the CMOSRAM byte
; This is done by taking the top bit set in R0 ( from bits 9 to 0 )
; K    to  number
; 0    to    0
; 8    to    1
; 16   to    2
; 32   to    3
; 64   to    4
; 128  to    5
; 256  to    6
; 512  to    7
;**************

 MVN R0, R0, ASL #22

 MOV R2, #7

01                               ; Top bit set or done enough bits ?
                                 ;
 MOVS R0, R0, ASL #1             ;
                                 ;
 SUBCSS R2, R2, #1               ;
                                 ;
 BCS %BT01                       ; [ no ]


 CMP R2, #0                      ; R2 = number to go in CMOS RAM
                                 ;
 MOVLT R1, #0                    ;
                                 ;
 MOVGE R1, R2

 GRAB "R0, R2"

 MOV PC, R14


;***************************************************************************
;***************************************************************************
;***************************************************************************
;***************************************************************************

 LTORG

 END

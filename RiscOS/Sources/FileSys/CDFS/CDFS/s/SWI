; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

; CDFS SWI commands in here are:

; MyCDFS_ConvertDriveToDevice 0
; MyCDFS_SetBufferSize        1
; MyCDFS_GetBufferSize        2
; MyCDFS_SetNumberOfDrives    3
; MyCDFS_GetNumberOfDrives    4
; MyCDFS_GiveFileType         5
; MyCDFS_DescribeDisc         6
; MyCDFS_WhereIsFile          7
; MyCDFS_Truncation           8

; Tables in here:
; IBMExtensions
; ArchyFileTypes


; SWI process -

; 1. Load R12 with w/s pointer

; 2. Save all registers at start of stack

; 3. Check that SWI is a valid number ( in the range 0 to x ( < 64 ) )

; 4. Branch to proc to control that part

; 5. Terminate the proc with BICS PC, R14, #Overflow_Flag or ORRVSS PC, R14,

; IF ERROR &1E6 ( SWI ... NOT KNOWN ) THEN SUICIDE ?
; ON SWI ENTRY :
;               R11 = SWI number % 64
;               R12 = private word pointer  - USE Pull & Push
;               R13 = supervisor stack
;               R14 = return register


;*********************************************************************
CDFSSWIentry
;*********************************************************************

        LDR     R12, [ R12 ]

        ; TURN IRQS ON
      [ No26bitCode
        CLRPSR  I_bit, R10
      |
        TEQ     PC, PC
        MVNNE   R10, #I_bit    ; R10 can safely be corrupted
        TSTNEP  R10, PC
        MRSEQ   R10, CPSR
        BICEQ   R10, R10, #I32_bit
        MSREQ   CPSR_c, R10
      ]

;**************************************************************************
;                          Check SWI Number
;**************************************************************************


        CMP     R11, #( EndSWIJumpTable - StartSWIJumpTable ) / 4
        BCS     SWITooBig

;***************************************************************************
;                    Jump table for each SWI ( very fast ) !!
;***************************************************************************

        Push    "R0 - R9, R14"

        DebugInline " SWI SWI "

        LDR     R14, [ PC, R11, LSL #2 ]    ; R14 corrupted !!!!!!!!!!!
        ADD     PC, PC, R14                 ;


StartSWIJumpTable

        DCD     CDFS_ConvertDriveToDevice_Code - StartSWIJumpTable - 4
        DCD     CDFS_SetBufferSize_Code - StartSWIJumpTable - 4
        DCD     CDFS_GetBufferSize_Code - StartSWIJumpTable - 4
        DCD     CDFS_SetNumberOfDrives_Code - StartSWIJumpTable - 4
        DCD     CDFS_GetNumberOfDrives_Code - StartSWIJumpTable - 4
        DCD     CDFS_GiveFileType_Code - StartSWIJumpTable - 4
        DCD     CDFS_DescribeDisc_Code - StartSWIJumpTable - 4
        DCD     CDFS_WhereIsFile_Code - StartSWIJumpTable - 4
        DCD     CDFS_Truncation_Code - StartSWIJumpTable - 4

EndSWIJumpTable

SWITooBig
        Push    "r1-r3, r14"
        addr    r0, switoobig_tag
        ADR     r1, message_block
        MOV     r2, #0
        SWI     XMessageTrans_ErrorLookup
        Pull    "r1-r3, r14"
        TEQ     pc, pc
        MOVEQ   pc, r14
        ORRS    pc, r14, #V_bit

;***************************************************************************
;***************************************************************************
;***************************************************************************
;***************************************************************************

;**************************************************************************
;                          Do CDFS_ConvertDriveToDevice
;**************************************************************************

CDFS_ConvertDriveToDevice_Code


; on entry:
;          R0 = drive number

; on exit:
;         R0, R2 - R10 preserved
;         R1 = composite device id ( b0..b2 = device,b3..b4=card,b5..b7=LUN)
;            + drivetype ( b8 .. b15 )
;            ( b16 .. b30 RESERVED )
;         If error, for some reason, then R1 = &ffffffff ( -1 )


;****************
; First check to see if R0 >= number of drives in my list
;****************

        DebugInline " Convert drive "

        LDRB    R1, numberofdrives

        CMP     R0, R1

        BLHS    AnotherDriveHasBeenAdded ; RETURNS V set if error
        BVS     %FT91 ; temp hack

        LDRB    R1, numberofdrives

        CMP     R0, #0                  ; R0 > 0 and < numberofdrives ?
        RSBHSS  R14, R0, R1             ;
        BLO     %FT90

;****************
; Give the composite device id to Leonardo
;****************

        LDR     R14, =:INDEX:ListOfDrivesAttached
        ADD     R14, R14, R12

        LDRB    R1, [ R0, R14 ]

        LDR     R14, =:INDEX:DriveTypes
        ADD     R14, R14, R12
        LDRB    R2, [ R0, R14 ]
        ORR     R1, R1, R2, ASL #8

        MOV     R10, R1

        DebugInline " End convert "

        Pull    "R0 - R9, R14"

        MOV     R1, R10

        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

90
        Pull    "R0-R9, R14"
        MOV     R1, #-1
        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

91
        ADD     sp,sp,#4
        Pull    "r1-r9,pc"

;**************************************************************************
CDFS_SetBufferSize_Code   ROUT ; R0 = bit number
;**************************************************************************

        MOV     R4, R0

;**************
; Get byte currently in CMOS RAM
;**************

        MOV     R0, #OsByte_ReadCMOS

        MOV     R1, #CDROMFSCMOS        ; Cmos RAM location

        SWI     XOS_Byte                ; R2 = contents of location


;************
; Mix byte in CMOS with number
;************

        BIC     R2, R2, #BITSUSEDBYBUFFER

        ORR     R2, R2, R4, ASL #BUFFERSHIFT


;************
; Store mixed byte back into CMOS
;************

        MOV     R0, #OsByte_WriteCMOS

        MOV     R1, #CDROMFSCMOS

                                        ; R2 = number
        SWI     XOS_Byte

        Pull    "R0 - R9, R14"

        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

;**************************************************************************
CDFS_GetBufferSize_Code   ROUT ; RETURNS R0 = bit number
;**************************************************************************

;**************
; Get byte currently in CMOS RAM
;**************

        MOV     R0, #OsByte_ReadCMOS

        MOV     R1, #CDROMFSCMOS        ; Cmos RAM location

        SWI     XOS_Byte                ; R2 = contents of location


;**************
; Extract the buffer value from the CMOS byte
;**************

        AND     R2, R2, #BITSUSEDBYBUFFER

        MOV     R2, R2, ASR #BUFFERSHIFT


        MOV     R10, R2

        Pull    "R0 - R9, R14"

        MOV     R0, R10

        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

;**************************************************************************
CDFS_SetNumberOfDrives_Code  ROUT  ; R0 = number of drives
;**************************************************************************

        MOV     R4, R0

;**************
; Get byte currently in CMOS RAM
;**************

        MOV     R0, #OsByte_ReadCMOS

        MOV     R1, #CDROMFSCMOS        ; Cmos RAM location

        SWI     XOS_Byte                ; R2 = contents of location


;************
; Mix byte in CMOS with number
;************

        BIC     R2, R2, #BITSUSEDBYDRIVENUMBER
        ORR     R2, R2, R4

;************
; Store mixed byte back into CMOS
;************

        MOV     R0, #OsByte_WriteCMOS

        MOV     R1, #CDROMFSCMOS

                                        ; R2 = number
        SWI     XOS_Byte

        Pull    "R0 - R9, R14"

        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

;**************************************************************************
CDFS_GetNumberOfDrives_Code  ROUT ; RETURNS R0 = number of drives
;**************************************************************************

;**************
; Get byte currently in CMOS RAM
;**************

        MOV     R0, #OsByte_ReadCMOS

        MOV     R1, #CDROMFSCMOS        ; Cmos RAM location

        SWI     XOS_Byte                ; RETURNS R2 = contents of location


;************
; Mix byte in CMOS with number
;************

        AND     R10, R2, #BITSUSEDBYDRIVENUMBER

        Pull    "R0 - R9, R14"

        MOV     R0, R10

        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14


;**************************************************************************
CDFS_GiveFileType_Code ROUT   ; R0 -> filename, RETURNS R1 = file type or 0
;**************************************************************************

; on entry:
;          R0 -> filename ( not necc. word aligned )
; on exit:
;          R1 = file type for name ( 0 if none found ) ( 0 TO &FFF )

        Push    "R0 - R3"

;********************
; First look to see if the path to read optional info from has been set up
;********************

        ADR     R0, RedirectedFileTypes

        LDR     R1, =:INDEX:SWI_buffer
        ADD     R1, R1, R12

        MOV     R11, R1

        MOV     R2, #MAXLENGTHOFDISCNAME + ( MAXLENGTHOFNAME + 1 ) * MAXNUMBEROFPATHS + 4

        MOV     R3, #0

        SWI     XOS_ReadVarVal          ; system variable set ?
                                        ;
        Pull    "R0 - R3"

        BVS     no_extensions           ; [ no ]


;********************   *********************    *********************
; Read file extensions from a file instead of the mem table
;********************   *********************    *********************

; Find extension ( after dot )

        MOV     R8, R0
        MOV     R14, #0

find_that_dot

        LDRB    R1, [ R8 ], #1
        TEQ     R1, #"."
        MOVEQ   R14, R8
        TEQ     R1, #0
        BNE     find_that_dot

        MOVS    R8, R14                 ; No dot
        LDRNEB  R1, [ R8 ]              ; A dot but nothing follows it
        TEQNE   R1, #0
        Pull    "R0 - R9, R14", EQ
        MOVEQ   R1, #0
        BEQ     %FT80


; R6 = file type number of current name
; R7 = number of lines done
; R8 -> extension name, ie TXT
; R9 = file handle
; R10 = finish ( TRUE / FALSE )
; R11 -> SWI_buffer

                ; Look through all of file for extensions

;*****
; Copy '<CDFSFilefdgfjsa>' into SWI_buffer

        MOV     R14, #"<"
        MOV     R0, R11
        STRB    R14, [ R0 ], #1

        ADR     R1, RedirectedFileTypes

08

        LDRB    R14, [ R1 ], #1
        TEQ     R14, #0
        STRNEB  R14, [ R0 ], #1
        BNE     %BT08

        MOV     R14, #">"
        STRB    R14, [ R0 ], #1
        MOV     R14, #0
        STRB    R14, [ R0 ], #1

        MOV     R0, #&40 + 2_1100       ; OPENIN ( no writing to file necc. )
        MOV     R1, R11
        MOV     R2, #0

        SWI     XOS_Find                ; Path is rubbish ?

        BVS     no_extensions           ; [ yes ]
                                        ; RETURNS R0 = file handle ( or 0 if VS )

        MOV     R9, R0

        MOV     R10, #FALSE
        MOV     R7, #1

; ******************** Validate file extension **********************

;*******************
REPEAT_start_checks
;*******************

; R2 -> place to put next char
; R3 -> last place to put char

        MOV     R2, #namebufferexe
        ADD     R2, R11, R2

        ADD     R3, R2, #5

05

        MOV     R1, R9                  ;
        SWI     XOS_BGet                ; RETURNS R0 = byte got from file

        STRB    R0, [ R2 ], #1

        TEQ     R0, #SPACE
        TEQNE   R2, R3
        BNE     %BT05

        TEQ     R2, R3
        BEQ     %FT01

        MOV     R3, #0
        STRB    R3, [ R2, #-1 ]

; ******************** Validate file type **********************


; R2 -> place to put next char
; R3 -> last place to put char

        ADD     R2, R11, #numberbufferexe

        ADD     R3, R2, #7

06

        MOV     R1, R9                  ;
        SWI     XOS_BGet                ; RETURNS R0 = byte got from file

        STRB    R0, [ R2 ], #1

        TEQ     R0, #&A
        TEQNE   R2, R3
        BNE     %BT06


        TEQ     R2, R3
        BEQ     %FT01

        MOV     R3, #0
        STRB    R3, [ R2, #-1 ]

        DebugInline " File type "

        LDR     R0, =10+(1:SHL:29)          ; Get number from string in number buffer
        ADD     R1, R11, #numberbufferexe   ;
        MOV     R2, #&1000                  ;
        SWI     XOS_ReadUnsigned            ; RETURNS R2 = number


        MOV     R6, R2

        ; Compare namebuffer & entryname passed in


        MOV     R0, R8
        ADD     R1, R11, #namebufferexe


; R0 -> entryname
; R1 -> namebuffer
; R2 = byte from entry name
; R3 = byte from name buffer
; R4 = temp
; R14 = counter

        MOV     R14, #0

07

        LDRB    R2, [ R0, R14 ]
        LDRB    R3, [ R1, R14 ]

        CMP     R2, #32
        MOVLT   R2, #0

        ADD     R14, R14, #1

        TEQ     R2, #0
        TEQEQ   R3, #0
        BNE     %FT08

        MOV     R10, R6
        MOV     R0, #0                  ; Close file if found
        MOV     R1, R9                  ;
        SWI     XOS_Find                ;

        Pull    "R0 - R9, R14"

        MOV     R1, R10
        B       %FT80

08

        TEQ     R2, R3
        BEQ     %BT07

end_mems      ; R4 = TRUE / FALSE  name same


        ADD     R7, R7, #1              ; line = line + 1


        MOV     R0, #5                  ; EOF
        MOV     R1, R9                  ;
        SWI     XOS_Args                ; RETURNS R2 = 0 if not EOF, else EOF

        TEQVC   R2, #0
        BEQ     REPEAT_start_checks

;********************   ;********************    ;********************
; close file
;********************   ;********************    ;********************

        MOV     R0, #0
        SWI     XOS_Find

      [ UseMimeMapTranslations
        ; it's NOT in the file
        MOV     r0,#MMM_TYPE_DOT_EXTN
        MOV     r1,r8 ; -> extension
        MOV     r2,#MMM_TYPE_RISCOS
        SWI     XMimeMap_Translate
        BVS     %FT55
        MOV     r10,r3

        Pull    "R0 - R9, R14"
        MOV     R1, R10
        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

55
      ]
        Pull    "R0 - R9, R14"
        MOV     R1, #0
        CMP     PC, PC ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

;********************   ;********************    ;********************

01

        MOV     R0, #0                  ; Close file then carry on with the internal extens
        MOV     R1, R9                  ;
        SWI     XOS_Find                ;

no_extensions

        ; 1/ Find if there is a dot in the name

        MOV     R3, R0
        MOV     R7, #0

find_me_the_dot                         ; Look for the last dot
        LDRB    R1, [ R3 ], #1          ;
        TEQ     R1, #"."
        MOVEQ   R7, R3
        TEQ     R1, #0
        BNE     find_me_the_dot

        MOVS    R3, R7                  ; No dot found in the name

        Pull    "R0 - R9, R14", EQ
        MOVEQ   R1, #0
        BEQ     %FT80

        ADR     R4, IBMExtensions
        MOV     R6, #0

repeat_search_for_extension

        LDRB    R1, [ R4 ]              ; Reached end of list
        TEQ     R1, #0                  ;

      [ UseMimeMapTranslations
        BNE     %FT02

        ; it's NOT in the internal DB
        MOV     r0,#MMM_TYPE_DOT_EXTN
        MOV     r1,r3 ; -> extension
        MOV     r2,#MMM_TYPE_RISCOS
        SWI     XMimeMap_Translate
        BVS     %FT55
        MOV     r10,r3

        Pull    "R0 - R9, R14"
        MOV     R1, R10
        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

55 ; failed
        Pull    "R0 - R9, R14"
        MOV     R1, #0                  ;
        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

02
      |
        Pull    "R0 - R9, R14", EQ
        MOVEQ   R1, #0
        BEQ     %FT80
      ]

        MOV     R5, R3

compare_extension_with_name             ; Compare the names with the one passed
                                        ; in
        LDRB    R2, [ R5 ], #1          ; part from name passed in
        CMP     r2,#32
        MOVLT   r2,#0


        LDRB    R1, [ R4 ], #1          ; part from list of names
        TEQ     R1, #0                  ; different
        TEQEQ   R2, #0                  ;
        BEQ     same                    ;
        TEQ     R2, R1                  ; same
        BNE     different               ;
        B       compare_extension_with_name

same

        ADR     R0, ArchyFileTypes      ; Load corresponding Archy file type
        LDR     R1, [ R0, R6, ASL #2 ]  ;

        MOV     R10, R1
        Pull    "R0 - R9, R14"
        MOV     R1, R10
        CMP     PC, PC ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14


different

        TEQ     R1, #0                  ; Move to next entry in list
        LDRNEB  R1, [ R4 ], #1          ;
        BNE     different               ;
        ADD     R6, R6, #1              ; Not found
                                        ;
        B       repeat_search_for_extension


80
        CMP     PC, PC ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

RedirectedFileTypes
        DCB     "CDFSNewFileTypePath$File", 0
        ALIGN

;**************************************************************************
IBMExtensions
;**************************************************************************


        ; Must be of length 4 chars ( fill with zeroes if nec. )

        DCB     "DOC", 0    ; 0
        DCB     "TXT", 0    ; 1
        DCB     "BAT", 0    ; 2
        DCB     "EXE", 0    ; 3
        DCB     "BIN", 0    ; 4
        DCB     "TIF", 0    ; 5
        DCB     "COM", 0    ; 6
        DCB     "PCD", 0    ; 7
        DCB     "MPG", 0    ; 8
        DCB     "DAT", 0    ; 9


        ; Insert more extensions here ( don't forget to add matching
        ;                              Archy file type below )
        ASSERT  ((. - IBMExtensions) :AND:3) = 0
        DCB     0
        ALIGN

;**************************************************************************
ArchyFileTypes
;**************************************************************************

      [ DOCisMSWord
        DCD     &AE6      ; ms-word    0
      |
        DCD     &FFF      ; text       0
      ]
        DCD     &FFF      ; text       1
        DCD     &FDA      ; MSDOSbat   2
        DCD     &FD9      ; MSDOSexe   3
        DCD     &FFD      ; Data       4
        DCD     &FF0      ; TIFF       5
        DCD     &FD8      ; MSDOScom   6
        DCD     &be8      ; PhotoCD    7
        DCD     &BF8      ; MPEG   8
        DCD     &BF8      ; DATA   9 - needs to be MPEG for some discs ;-(

        ; Insert more Archy file types here
        ;
        DCD 0


;**************************************************************************
CDFS_DescribeDisc_Code ROUT
;**************************************************************************
; on entry:
;          R0 = drive number
;          R1 -> 64 byte block

; on exit:
;         nowt


; R9 -> 64 byte block


; 0. Is block word aligned ?

        TST     R1, #3
        BNE     swiinvalidparameter

        MOV     R9, R1


        ; Kludge any error to return

        LDR     R14, stackreturn
        Push    "R14"
        ADR     R14, return_here
        PushAllWithReturnFrame


        BL      TestKnowDisc            ; R0 = drive, RETURNS R1->buf, RETURNS R2 =disc

return_here

        STRVS   R0, swi_verytemporary
        STRVC   R1, swi_verytemporary
        PullAllFromFrame
        LDRVC   R1, swi_verytemporary
        Pull    "R14"
        STR     R14, stackreturn

        Pull    "R0 - R9, R14", VS
        LDRVS   R0, swi_verytemporary
        TEQ     PC, PC
        TEQVC   PC, #0
        MOVEQ   PC, R14                 ; 32-bit error exit
        ORRVSS  PC, R14, #V_bit         ; 26-bit error exit

; 4. Enter details into block

        ;a. Size of disc ( 1 word )

        LDR     R14, [ R1, #SIZEOFDISCOFFSETINABUFFER ]

        STR     R14, [ R9, #SIZEOFDISCOFFSETFORDESCRIBE ]

        ;b. Block size ( 1 word )

        LDR     R14, [ R1, #BLOCKSIZEOFFSETINABUFFER ]

        STR     R14, [ R9, #BLOCKSIZEOFFSETFORDESCRIBE ]

        ;c. Block number of root directory ( 1 word )

        LDR     R14, [ R1, #LBAOFMAINDIROFFSETINABUFFER ]

        STR     R14, [ R9, #STARTLBAOFFSETFORDESCRIBE ]

        ;d. Disc name ( up to 32 bytes )

        ADD     R8, R1, #DISCNAMEOFFSETINABUFFER
        ADD     R7, R9, #DISCNAMEOFFSETFORDESCRIBE
        ADD     R6, R7, #MAXLENGTHOFDISCNAME
01
        LDRB    R5, [ R8 ], #1
        TEQ     R5, #SPACE
        MOVEQ   R5, #0
        STRB    R5, [ R7 ], #1

        CMP     R7, R6
        BLE     %BT01

        ;e. Boot option ( 1 byte )

        MOV     R5, #0
        STRB    R5, [ R9, #BOOTOPTIONOFFSETFORDESCRIBE ]

        Pull    "R0 - R9, R14"

        ; Not grabbing the correct return registers first time around

        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

;**************************************************************************
CDFS_WhereIsFile_Code  ; R0 -> pathname RETURNS R1 = block number or -1
                       ; RETURNS R2 = length in bytes of file
;**************************************************************************
;*********************
; Dir: ( pathname$, RETURN pointer to block of object info, 0 if not found,
;                   RETURN R2 = 1 if a file, 2 if a directory )
;                   RETURN R3 -> start of disc buffer
;                   RETURN R4 = drive number

        ; Kludge any error to return

        ADR     R14, here
        PushAllWithReturnFrame

        VCLEAR

        MOV     R1, #2 ; Don't care what I find
        BL      Dir

here
        BVS     error_here

        TEQ     R2, #object_file        ; A file ?

        STREQ   R1, swi_verytemporary

        PullAllFromFrame

        Pull    "R0 - R9, R14"
        LDREQ   R10, swi_verytemporary
        LDREQ   R2, [ R10, #LENGTHOFFSET ]
        LDREQ   R1, [ R10, #LBASTARTOFFSET ]
        MOVEQ   R1, R1, LSR #8
        MOVNE   R1, #-1
        CMP     PC, PC                  ; clears V in 32-bit mode
        MOVEQ   PC, R14
        MOVS    PC, R14

error_here ; V is already set

        STR     R0, swi_verytemporary
        PullAllFromFrame
        Pull    "R0-R9,R14"
        LDR     R0, swi_verytemporary
        TEQ     PC, PC
        MOVEQ   PC, R14
        ORRS    PC, R14, #V_bit

;**************************************************************************
CDFS_Truncation_Code
;**************************************************************************

; on entry:
;          r0=0 THEN read current truncation type
;                    on exit:
;                            r1=current value
;               ELSE
;          r0=1
;               set truncation type
;               r1=0 then truncate from right  (default for risc os 2.00)
;               r1=1 then truncate from left
;               r1=2 then no truncation        (default for risc os 3.00 > )
;               r1=-1 then use default for os version

        TEQ     R0, #0
        Pull    "R0-R9,R14",EQ
        LDREQB  R1, truncation
        BEQ     %FT80

        TEQ     R0, #1

        BNE     swiinvalidparameter

        ; check for risc os 3, if so then allow r1=0 to 2 else r1=0 to 1

        LDRB    R14, os_version
        SUB     R14, R14, #1            ; OK AT THE MOMENT

        CMP     R1, #-1                 ; Use default truncation for risc os version
        ANDEQ   R1, R14, #2_10          ; r14=1 or 2 convert to 0 or 2

        CMP     R1, #0
        RSBHSS  R3, R1, R14
        BLO     swiinvalidparameter

        STRB    R1, truncation

80
        Pull    "R0 - R9, R14"
        TEQ     PC, PC
        MOVEQ   PC, R14
        MOVS    PC, R14

swiinvalidparameter
        Pull    "R0-R9,R14"

        Push    "r1-r4, r14"
        addr    r0, invalidparameter_tag
        ADR     r1, message_block
        MOV     r2, #0
        SWI     XMessageTrans_ErrorLookup
        Pull    "r1-r4, r14"
        TEQ     pc, pc
        MOVEQ   pc, r14
        ORRS    pc, r14, #V_bit

        LTORG

        END

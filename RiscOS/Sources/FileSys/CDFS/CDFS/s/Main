; Copyright 1996 Acorn Computers Ltd
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;
; -> CDFS module


; IF ERROR &1E6 ( SWI ... NOT KNOWN ) THEN SUICIDE ?

; ON SWI ENTRY :

;               R11 = SWI number % 64

;               R12 = private word pointer  - USE GRAB & STASH

;               R13 = supervisor stack

;               R14 = return register

        AREA    |CDFS$$Code|, CODE, READONLY, PIC

        GET     hdr:ListOpts
        GET     hdr:Macros
        GET     hdr:System
        GET     hdr:MsgTrans
        GET     hdr:ModHand
        GET     hdr:Free
        GET     hdr:FSNumbers

        GET     hdr:HostFS
        GET     hdr:NdrDebug

        GBLL    debug
debug   SETL    false

        GBLL    hostvdu
hostvdu SETL    true

;*****************************************************************
;*****************************************************************
;                   Procedures in this file
;*****************************************************************
;*****************************************************************

; initialisingcode     ; Start up as a filing system

; finalisingcode       ; Kill filing system and claimed RMA space

; servicecode          ; Service call handler

; registerFS           ; Register module as a filing system

; InformationBlock     ; Block used by FileSwitch

;*****************************************************************
;*****************************************************************





;*****************************************************************
;                       MODULE HEADER
;*****************************************************************

startofheader

 GET hdr.Options           ; Link in options
 GET hdr.MimeMap           ; Link in MimeMap handling
 GET hdr.Hashes            ; Link in hash define file
 GET hdr.MyMacros          ; Link in macro file
 GET VersionASM            ; Date/version strings

 ENTRY

 ModuleDescriptionHeader

 [ debug
        GET     Hdr:Proc
        InsertNDRDebugRoutines
 ]

;*****************************************************************
;                       Include other files
;*****************************************************************

 GET s.Args        ; deals with FSEntry_Args (ControlFile)
 GET s.Strings     ; Any old string
 GET s.Misc        ; Deals with miscellaneous *COMMANDS
 GET s.DiscOp      ; Deals with most disc operations
 GET s.FileMan     ; Handles file operations - See keyword table
 GET s.Filer       ; Routines called by 'FileMan'
 GET s.Directory   ; move to and cat directory
 GET s.EntryFile   ; deals with FSEntry_File
 GET s.Open        ; deals with open / close extras
 GET s.SWI         ; deals with the SWI CDFS_...
 GET s.Error       ; Deals with errors from SWI XCD_...
 GET s.Tables      ; Unchanging tables
 GET s.StarHelp    ; RISC OS 3 Contains *help routines
 GET s.WordTable3  ; RISC OS 3 Contains keyword table ( *CDFS, *PLAY ... )
 GET s.Variables   ; Layout of variables in workspace
 GET s.ByteCopy
 GET s.Free        ; Support for Free module


;-----------------------------------------------------------------------------------------------

; CANNOT USE CDFS$Path 'cause it screws up *dir cdfs::0

message_filename DCB    "CDFSMessages:Messages", 0


Path             DCB    "CDFSMessages$Path"
                 DCB    0
PathDefault      DCB    "Resources:$.Resources.CDFS."
                 DCB    0
                 ALIGN

ModuleFlags      DCD    ModuleFlag_32bit

;-----------------------------------------------------------------------------------------------
initialisingcode ROUT
;
; on entry:
;          R10 -> enviroment string ( see page 631 )
;          R11 = I/O base or instantiation number
;          R12 -> currently preferred instantiation of module
;          R13 -> supervisor stack
;
; on exit:
;         must preserve R7 - R11, and R13, forget the rest
;
;-----------------------------------------------------------------------------------------------

         STASH         r14

;----------------------------------------------------------
; initialise CDFSFiler$Path if not already done
;----------------------------------------------------------

         ADR       r0, Path
         MOV       r2, #-1
         MOV       r3, #0
         MOV       r4, #2
         SWI       XOS_ReadVarVal          ; returns R2=0 if doesn't exist
         CMP       r2, #0                  ; clears V as well!

         ADREQ     r0, Path
         ADREQ     r1, PathDefault
         MOVEQ     r2, #?PathDefault
         MOVEQ     r3, #0
         MOVEQ     r4, #0
         SWIEQ     XOS_SetVarVal

;-----------------------------------------------------------------------------------------------
; Read configured number of drives.
;-----------------------------------------------------------------------------------------------

         MOV         r0, #161                ; Reason code              FOR GET
         MOV         r1, #HARDRAMLOCATION    ; Cmos RAM location
         SWI         XOS_Byte                ; R2 = contents of location

 [ CheckConfiguredDrives
         TST         r2, #BITSUSEDBYDRIVENUMBER

         BNE         %FT00

         SUB         r13, r13, #16              ; local buffer for MessageTrans file descriptor
         MOV         r0, r13                    ; open message file
         ADR         r1, message_filename
         MOV         r2, #0
         SWI         XMessageTrans_OpenFile

         ADRVCL      r0, noconfigureddrives_tag ; lookup error (or use error from OpenFile)
         MOVVC       r1, r13
         SWIVC       XMessageTrans_ErrorLookup

         MOV         r1, r0                     ; at this point we definitely have an error of some sort
         MOV         r0, r13
         SWI         XMessageTrans_CloseFile
         MOV         r0, r1                     ; ignore any error from CloseFile

         ADD         r13, r13, #16              ; free buffer and return error (don't start up)
         VSET
         GRAB        pc
00
 ]

         MOV         r6, r2

;-----------------------------------------------------------------------------------------------
; Free w/s if already got some
;-----------------------------------------------------------------------------------------------

         ; LDR        r14, [ r12 ]
         ; TEQ        r14, #0

         ; BLNE       finalisingcode


;-----------------------------------------------------------------------------------------------
; Claim space from RMA for workspace
;-----------------------------------------------------------------------------------------------

         MOV         r0, #6                  ; Reason code
         LDR         r3, =SIZEOFRMA          ; Amount of memory required
         SWI         XOS_Module
         MOVVS       r4, r0
         BVS         kill_filing_system

         STR         r2, [ r12 ]                 ; Save it in the private word

         MOV         r12, r2

;-----------------------------------------------------------------------------------------------
; Clear the reserved memory
;-----------------------------------------------------------------------------------------------

         MOV         r1, #0          ; R1 = Wiper
         MOV         r0, r12         ; R0 -> Start of wipe
         LDR         r3, =SIZEOFRMA  ; R3 -> end of wipe
         ADD         r3, r3, r12
03
         STMIA       r0!, { r1 }
         CMP         r0, r3
         BLE         %BT03

;-----------------------------------------------------------------------------------------------
; Claim space from RMA for LIB & URD paths ( and clear them )
;-----------------------------------------------------------------------------------------------

;----------------------------------------------------------
; Set up MessageTrans expecting the CDSFSResources module
; to have put the files into ResourceFS
;----------------------------------------------------------

         ADR       r0, message_block
         ADR       r1, message_filename
         MOV       r2, #0
         SWI       XMessageTrans_OpenFile
         MOVVS     r4, r0
         BVS       free_workspace

;--------------------------------------------------------------------------
; Extract the buffer value from the CMOS byte
;--------------------------------------------------------------------------

         AND         r0, r6, #BITSUSEDBYBUFFER

         MOV         r0, r0, LSR #BUFFERSHIFT


        ; First find out how big the buffer size is

         BL          ConvertBufferSizeToReal ; R0 = bit size, RETURNS R1 = number of K


         TEQ         r1, #0                 ; If no memory is needed then do not claim it
         MOVEQ       r1, #6                 ; Cheat - claim a minimum amount of 6K

         MOV         r5, r1                 ; preserve R1

         MOV         r3, r1, ASL #10        ; R1 = number of K * 1024 = number of bytes
         STR         r3, discbuffersize

         MOV         r0, #6

         SWI         XOS_Module           ; R0 = 6, R3 = amount required
                                  ; RETURNS R2 -> claimed block

         MOVVS       r2, #0             ; If cannot get memory then use 0 buffers
         STRVS       r2, discbuffersize ; ( Display message )
         BVS         display_no_buffers   ;

         STR         r2, discbufferpointer
         STR         r2, disclastpointer

;--------------------------------------------------------------------------
; Clear the disc buffer space ; R2 -> start, R3 = length, R14 = temp
;--------------------------------------------------------------------------

         ADD         r3, r3, r2        ; R3 -> end of space
         MOV         r14, #0           ; R14 = wiper
02
         STMIA       r2!, { r14 }
         CMP         r2, r3
         BLT         %BT02

;--------------------------------------------------------------------------
; Claim space for pointers  ( length depends on size of configured buffer )
;--------------------------------------------------------------------------

; R5 = size of cache in K

         MOV         r3, r5, ASL #2
         STR         r3, maxnumberofbuffers

; R3 = ( size_of_cache_in_K * 4 * 3 * 2 ) + 4 just in case
;    = ( R5 * 8 * 3 ) + 4

; R5 = 32
; R3 = 32 * 8 = 256
; R3 = 256 * 3 = 768
; R3 = 768 + 4 = 772

         [ SIZEOFBUFFERENTRY<>16
        ! 0, " See 'Main' "
         ]

         MOV         r3, r5, ASL #6     ; xK * 4 * 16

         ADD         r3, r3, #SIZEOFBUFFERENTRY + 4

         MOV         r0, #6

         SWI         XOS_Module     ; R3 = total size of cache required
         MOVVS       r4, r0
         BVS         free_disc_cache

         STR         r2, pointerToBufferList


         ADD         r3, r3, r2
         MOV         r4, #0
         MOV         r1, r2
04
         STMIA       r1!, { r4 }
         CMP         r1, r3
         BLT         %BT04

no_disc_buffer

;--------------------------------------------------------------------------
; Read the configure option, if 0 drives configured, then look for one
;--------------------------------------------------------------------------

;----------------------------------
; Seperate byte in CMOS from number
;----------------------------------

         ANDS        r0, r6, #BITSUSEDBYDRIVENUMBER

         STR         r0, maxnumberofdrives

;         BLEQ        AnotherDriveHasBeenAdded  ; R0 = drive number

;----------------------------------
; Set module up as a filing system
;----------------------------------

         BL          registerFS
         MOVVS       r4, r0
         BVS         free_pointer_list

;------------------------------
; Register with the Free module
;------------------------------
         MOV         r0, #fsnumber_CDFS
         ADRL        r1, Free_Entry
         MOV         r2, r12
         SWI         XFree_Register
         ; It's not fatal if this produces an error

;---------------------------------------------------
; Set disc has changed value for all possible drives
;---------------------------------------------------

         STASH       r7                            ; SMC: Don't want to corrupt r7, do we!

         ADD         r7, r12, #:INDEX:sparecontrolblock
         MOV         r6, #0
01
         SWI         XCD_DiscHasChanged
         ADD         r6, r6, #1
         AND         r2, r6, #2_111                ; R2 = device number
         MOV         r3, r6, ASR #3                ; R3 = card number
         AND         r3, r3, #2_11
         MOV         r4, r6, ASR #5                ; R4 = LUN
         AND         r4, r4, #2_11
         STMIA       r7, { r2, r3, r4 }
         CMP         r6, #2_1111111                ; If device =7,LUN=3,card=3 THEN end
         BLE         %BT01

         GRAB        r7

         [ log=ON
         LDR R14, =:INDEX:log_memory
         ADD R14, R14, R12
         STR R14, log_pointer
         ]

;----------------------------------
; Check for presence of RISC_OS 3.0
;----------------------------------

         ADR         r0, rmensure
         SWI         XOS_CLI                 ; No error, so must be OK (?) !!!

         MOV         r0, #2
         STRVCB      r0, truncation

         MOVVC       r0, #3                ; remember what os version is being run
         STRB        r0, os_version

;----------------------------------------------------------
; Set the PhotoCD file type to read 'PhotoCD'
;----------------------------------------------------------
       [ Module_Version >= 220
         ADR       r0, photocd_filetype
         SWI       XOS_CLI
       ]

;----------------------------------------------------------
; End Initialisation process
;----------------------------------------------------------
         CMP       R0,#0
         GRAB      pc

;----------------------------------------------------------

       [ Module_Version >= 220
photocd_filetype = "Set File$Type_BE8 PhotoCD", 0
       ]


rmensure         DCB "RMENSURE UtilityModule 2.12", 0

 ALIGN
;*****************
display_no_buffers
; If the disc buffer space not available
; Then print a message and use 0 buffers
;*****************

 ADRL   r0, nospace_tag
 ADR    r1, message_block
 MOV    r2, #0
 SWI    XMessageTrans_ErrorLookup
 ADD    r0, r0, #4
 SWI    XOS_Write0

 SWI XOS_NewLine

 SWI XOS_ReadMonotonicTime   ; RETURNS R0 = time in centi-seconds since
                             ; last hard reset
 ADD R1, R0, #2*100
06
 SWI XOS_ReadMonotonicTime   ; RETURNS R0 = time in centi-seconds since
                             ; last hard reset
 CMP R0, R1
 BLT %BT06

 B no_disc_buffer


;-----------------------------------------------------------------------------------------------
finalisingcode ROUT
;
; on entry:
;          r4  = 0 or -> error block ( may have jumped in from InitialisationCode )
;          R10 = fatality indicator, 0 = non-fatal, 1 = fatal
;          R11 = instantiation number
;          R12 -> private word
;          R13 -> supervisor stack
;
; on exit:
;          R7 - R11 and R13 must be preserved, forget the rest
;-----------------------------------------------------------------------------------------------

         STASH     r14
         MOV       r4, #0
         LDR       r12, [ r12 ]

;----------------------------------------------------------
; Close the message trans file for RISC OS 3
; added: 9-June-93 for CDFS v 2.16
;----------------------------------------------------------

         ADR       r0, message_block
         SWI       XMessageTrans_CloseFile

;--------------------------------
; Deregister from the Free module
;--------------------------------
         MOV       r0, #fsnumber_CDFS
         ADRL      r1, Free_Entry
         MOV       r2, r12
         SWI       XFree_DeRegister

;----------------------------------------------------------
; free the pointer list - if it was claimed
;----------------------------------------------------------
free_pointer_list

         LDR       r14, discbuffersize
         TEQ       r14, #0
         MOVNE     r0, #7
         LDRNE     r2, pointerToBufferList
         SWI       XOS_Module              ; R0 = 7, R2 -> RMA to free

;----------------------------------------------------------
; free the disc cache space
;----------------------------------------------------------
free_disc_cache

         LDR       r14, discbuffersize
         TEQ       r14, #0
         MOVNE     r0, #7
         LDRNE     r2, discbufferpointer
         SWI       XOS_Module              ; R0 = 7, R2 -> RMA to free

;--------------------------------------------------------------------------
; free the workspace
;--------------------------------------------------------------------------
free_workspace

         MOV       r0, #7
         MOV       r2, r12
         SWI       XOS_Module              ; R0 = 7, R2 -> RMA to free

;--------------------------------------------------------------------------
; Kill module as a filing system
;--------------------------------------------------------------------------
kill_filing_system

         MOV       r0, #16

         addr      r1, FilingSystemName

         SWI       XOS_FSControl

;--------------------------------------------------------------------------
; Exit returning error
;--------------------------------------------------------------------------

         MOVS      r0, r4                        ; Tell about the error
         GRAB      pc, EQ
         VSET
         GRAB      pc

;--------------------------------------------------------------------------
ServiceTable
	 DCD	0			; flag word
	 DCD	serviceursula - startofheader
	 DCD	Service_FSRedeclare
	 DCD	0
	 DCD	ServiceTable - startofheader

servicecode ROUT
;
; on entry:
;          r1 = service call reason code
;          other registers service call specific
;
; on exit:
;          r1 = 0 (service claimed) or preserved (service not claimed)
;          other registers service call specific
;--------------------------------------------------------------------------
	 MOV	 r0,r0			; nop to indicate service table present
         TEQ     r1, #Service_FSRedeclare
         MOVNE   pc, lr

serviceursula
         LDR     r12, [r12]
         ; Drop through to...

;--------------------------------------------------------------------------
registerFS ROUT
;
; Register our filing system.
;--------------------------------------------------------------------------

         STASH  "r0-r3,lr"

         MOV    r0, #12                 ; Reason code to add a filing system
         addr   r1, startofheader
         ADR    r2, InformationBlock
         SUB    r2, r2, r1
         MOV    r3, r12                 ; Passed in R12 when call to filing system
         SWI    XOS_FSControl

         GRAB   "r0-r3,pc"

;--------------------------------------------------------------------------
;        This next block is used by FileSwitch

; All of the routines are held in the file 'FileMan'
;--------------------------------------------------------------------------

 ALIGN

InformationBlock

 DCD FilingSystemName - startofheader              ; &00

 DCD StartUpText - startofheader                   ; &04

 DCD OpenFile - startofheader                      ; &08

 DCD GetByte - startofheader                       ; &0c

 DCD PutByte - startofheader                       ; &10

 DCD ControlOpenFile - startofheader               ; &14

 DCD CloseFile - startofheader                     ; &18

 DCD WholeFile - startofheader                     ; &1c

 DCD FILINGSYSTEMINFORMATIONWORD                   ; &20

 DCD FSOperations - startofheader                  ; &24

 DCD 0                                             ; &28  Not supported

 DCD EXTRA_FILINGSYSTEMINFORMATIONWORD             ; &2c

; Not part of Information Block

 LTORG

 END



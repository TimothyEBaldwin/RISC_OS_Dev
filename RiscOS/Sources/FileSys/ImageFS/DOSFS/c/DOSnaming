/* Copyright 1996 Acorn Computers Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*> c.DOSnaming <*/
/*---------------------------------------------------------------------------*/
/* MSDOS to RISCOS name conversion                Copyright (c) 1989 JGSmith */
/*---------------------------------------------------------------------------*/

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "kernel.h"
#include "DebugLib/DebugLib.h"

#include "DOSFS.h"
#include "TIMEconv.h"
#include "ADFSshape.h"
#include "Helpers.h"
#include "MsgTrans.h"
#include "DOSnaming.h"
#include "DOSshape.h"
#include "DOSdirs.h"
#include "debug.h"

/*---------------------------------------------------------------------------*/
/* validate that the given character appears in the string */

int validchar(char *string,char init)
{
//  if (init >= 128) return -1;    /* Allow top bit set characters */

  while (*string != NULL)
  {
    if (*string == init)
      return -1;
    string++;
  }

  return 0;
}

/*---------------------------------------------------------------------------*/
/* Map certain characters between filing systems */

char mapchar(char cchr,char *fromlist,char *tolist)
{
  while (*fromlist != NULL)
  {
    if (cchr == *fromlist)
      return *tolist;
    fromlist++;
    tolist++;
  }
  return cchr;
}

/*-------------------------------------------------------------------------*/

static int chr_pos(char *text,char marker)
{
// int index ;
//
// /* return the character position of the passed character (or 0 if none) */
// for (index = 0; (text[index] != NULL); index++)
//  if (text[index] == marker)
//   return(index) ;
 char * index =strrchr(text,marker);
 return(index?(int)(index-text):NULL) ;
}

/*-------------------------------------------------------------------------*/
/* return a string containing the text before the given character */

char *before(char *newptr,char *text,char marker,int npad)
{
 int cpos = chr_pos(text,marker) ;
 if (cpos == 0)
  cpos = strlen(text) ;

 strncpy(newptr,text,cpos) ;
 if (npad == 0)
  newptr[cpos] = NULL ;

 return(newptr) ;
}

/*-------------------------------------------------------------------------*/
/* return a string containing the text after the last occurrence of */
/* the given character */
/* used to extract the DOS file extent info */

char *after(char *newptr,char *text,char marker,int npad)
{
 int cpos = chr_pos(text,marker) ;


 if (cpos != 0)
  {
//   int len = strlen(text) ;
   if (npad == 0)
    strcpy(newptr,&text[cpos + 1]) ;
   else
    strncpy(newptr,&(text[cpos + 1]),4) ;
  }
 else
  if (npad == 0)
   strcpy(newptr,"") ;

 return(newptr) ;
}

/* RISC OS name:
 *      [$.]<path>
 * RISC OS path:
 *      <filename (max. 10 chars)>[.<path element>]
 *
 * DOS name:
 *      [\]<path>
 * DOS path:
 *      <filename (max. 8 chars)>[.<extension (max. 3 chars)>[\<path element>]
 */
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/* Check that the given DOS names are identical */

int namematch(char *wcname,char *fname)
{
 char string1[257];
 char string2[257] ;

 /* Code assumes characters upto (and including) "file_sep" will always fit
  * in RISC OS names.
  */
 before(string1,fname,file_sep,0) ;
 before(string2,wcname,file_sep,0) ;
 if (wild_card_compare(string1,string2,DOSwcmult,DOSwcsing) == TRUE)
  {
   /* "string1" is the full (non-wildcarded) filename we have matched with */
   /* "string2" is the original (wildcarded) filename we were given on entry */

   after(string1,fname,file_sep,0) ;
   after(string2,wcname,file_sep,0) ;

   if (wild_card_compare(string1,string2,DOSwcmult,DOSwcsing) == TRUE)
    return(TRUE) ;
  }

 return(FALSE) ;
}

/*---------------------------------------------------------------------------*/
/* convertRISCOStoDOS:
 * translate a standard RISC OS name into a MS-DOS one.
 * **** we should really include code to check the "dest" buffer limits ****
 */
char *convertRISCOStoDOS(char *source,char *dest)
{
 char      *csptr = source ;
 char      *cdptr = dest ;
 int        loop ;
 int        filesepseen = FALSE ; /* if we have seen the file seperator */
 char      *cptr ;      /* string pointer */
 char       lchr ;      /* last character seen */
 int        point = 0 ; /* position where file extension started */

 if ((source == NULL) || (*source == NULL))
  {
   dprintf(("","DOSFS: convertRISCOStoDOS: NULL name\n")) ;
   *dest = NULL ;
   return(dest) ;
  }

 dprintf(("","DOSFS: convertRISCOStoDOS: \"%s\"",source)) ;

 lchr = '\0' ; /* no last character */
 cptr = csptr;
 do {
   /* Ensure that "/" characters do not appear at the start or end of the name
    * and that "//" sequences are trapped.
    */
   if ((*cptr == '/' && (lchr == '\0' || lchr == *cptr || lchr == '.')) || ((lchr == '/') && ((*cptr == '\0') || (*cptr == '.'))))
    return_error1(char *,err_invalidname,source) ;

   lchr = *cptr++ ; /* remember this character */
 } while (lchr);

 if (*csptr == '$')             /* ROOT directory specifier */
  {
   csptr++ ;
   if (*csptr == '.')           /* RISC OS directory seperator */
    {
     *cdptr++ = dir_sep ;       /* MSDOS directory seperator */
     csptr++ ;
    }
   else
    if (*csptr == NULL)
     *cdptr++ = dir_sep ;
    else
     *cdptr++ = '$' ;
  }

 for (loop = 0;;)       /* convert the remainder of the pathname */
  {
   if (*csptr == NULL)  /* end of the source pathname */
    {
     *cdptr = NULL ;    /* terminate the destination pathname */
     break ;
    }

   switch (*csptr)
    {
     case '.' : /* RISC OS to directory seperator */
                *cdptr++ = dir_sep ;
                csptr++ ;
                loop = 0 ;
                filesepseen = FALSE ; /* for this leafname */
                break ;

     case '/' : /* convert to file seperator */
                if (filesepseen)
                 return_error1(char *,err_invalidname,source);
                *cdptr++ = file_sep ;
                csptr++ ;
                loop++ ;
                point = loop ;
                filesepseen = TRUE ;
                break ;

     default  : /* perform standard name mapping */
                if (filesepseen)
                 {
                  char c = *csptr++;
                  /* should never need to truncate the extension */
//                  if ((loop - point) >= extsize)
//                   return_error1(char *,err_invalidname,source) ;
//                  if (islower(c))
//                   c = toupper(c);
                  *cdptr++ = mapchar(c,ROmapping,DOSmapping) ;
                 }
                else
                 {
                  char c = *csptr;
//                  if (islower(c))
//                   c = toupper(c) ;
                  *cdptr++ = mapchar(c,ROmapping,DOSmapping) ;
                  csptr++ ;      /* step over this DOS character */
                 }
                loop++ ;
                break ;
    }
  }

 dprintf((""," converted to \"%s\"\n",dest)) ;

 for (cptr = dest; *cptr; cptr++)
  if (!validchar(valchars,*cptr))
   return_error1(char *,err_invalidname,source);

 return(dest) ;
}


/*---------------------------------------------------------------------------*/

char *buildFILEname(DOS_direntry * dentry,char *name)
{
 char *cptr = (char *)&(dentry->FILE_status);
 int   index ;
 int   loop ;
 dprintf(("","buildFILEname: dentry:%p\n",dentry));

 /* "dentry" should contain a valid filename */
 /* copy prefix characters (or upto a space) into the filename buffer */
 for (index=0; ((cptr[index] > ' ') && (index < namsize)); index++)
  name[index] = cptr[index] ;

 /* copy suffix characters (or upto a space) into the filename buffer */
 for (loop=0; ((dentry->FILE_extension[loop] > ' ') && (loop < extsize)); loop++)
  {
   if (loop == 0) /* the first character of the extension */
    name[index++] = file_sep ; /* then place in the file_seperator */
   name[index++] = dentry->FILE_extension[loop] ;
  }

 /* terminate the name */
 name[index] = NULL ;
 dprintf(("","buildFILEname: got:%s\n",name));

 return(name) ;
}

//Calculates the LFN checksum of an 11 bytes dos filename
byte lfnchecksum(char * filename)
{
 byte checksum=0;
 byte lsb;
 int i;
 for(i=0;i<11;i++)
 {
  lsb = (checksum&0x1); //Save the lsb
  checksum = checksum >> 1; // Shift the byte
  lsb = lsb << 7; // Turn saved lsb into msb
  checksum |= lsb;
  checksum += filename[i];
 }

 return checksum;
}

/* returns NULL if short and long names are identical, else NZ */
int  shorten_lfn(char * longfname, char * shortname, char * shortnamebuff, DIR_info * cdir)
{
 // char * longfname : pointer to a null terminated file name
 // char * shortnamebuff : pointer to a 13 byte buffer to store newly created short file name
 // DIR_info * cdir : pointer the dir info structure for the target directory
 int i, j, o, retval, dotseen=0;
 char * extension,c;
 /* check if already a valid short file name */
 memset(shortnamebuff,' ',12);shortnamebuff[12]=0;
 dprintf(("","shorten_lfn: start with -%s-\n",longfname));
 for(i=0,j=0;(i<=12)&&(j<=12);i++,j++)
 {
   c=longfname[i];
   if(c=='.')
   {
     if(!dotseen)
     {
       dotseen=i+1;
       while(j<8)
       {
        shortnamebuff[j++]=' ';  // spacefill to 8
       }
     }
     if(i>8) break ; // too many chars
   }
 dprintf(("","shorten_lfn: check -%x-%c- toupper(c) -%c-\n",c,c,toupper(c)));
   if(c && ((c=='.')||((c==toupper(c)) && (c!=' '))))
   { /* copy over */
     shortnamebuff[j]=c;
 dprintf(("","shorten_lfn: copied -%c-\n",c));
   }
   else
   {
     dprintf(("","shorten_lfn: %d %d %d\n",c,strlen(shortnamebuff),strlen(longfname)));
     if(!c && /*strlen(shortnamebuff)==strlen(longfname) && */((!dotseen && (i<9)) || dotseen))
     { /* end of string .. and identical */
       dprintf(("","shorten_lfn: its a valid DOS SFN\n"));
       retval= 0;
       goto slnfn1;
     }
     break;
   }
 }



 memset(shortnamebuff,'_',8);
 memset(&shortnamebuff[8],' ',4);
 shortnamebuff[12]=NULL;
 for(i=0,o=0;o<6;i++)
 {
  if(longfname[i]==NULL)
  {
   o=6;
   continue;
  }
  if(longfname[i]==' ') continue;
  if(longfname[i]=='.')
  {
   if( &(longfname[i]) == strrchr(longfname,'.') )
   {//If we are currently at the last 'dot' terminator in the filename...
    o=6;      //Ensuring we
    continue; //Drop out of the loop
   }else
   {
    i++;
    continue;
   }
  }
  if(longfname[i] == ('+' || ',' || ';' || '=' || '[' || ']' || '.'))
  {
   shortnamebuff[o] = '_';
  }else
  {
   shortnamebuff[o] = toupper(longfname[i]);
  }
  o++;
 }

 dprintf(("","shorten_lfn: strchr(longfname,'.') = %p, c='%c'\n",strchr(longfname,'.'),*strchr(longfname,'.')));
 //We now have collected the first 6 characters of the short file name.
 if(extension=strrchr(longfname,'.'), extension != NULL) //There is a dot extension
 {//char * 'extension' points to the dot extension
  for(i=0,o=8;o<12;i++)
  {
   if(extension[i]==NULL)
   {
    o=12; //Break out of loop
    continue;
   }
   if(extension[i]==' ') continue;
   if(extension[i] == ('+' || ',' || ';' || '=' || '[' || ']'))
   {
    shortnamebuff[o] = '_';
   }else
   {
    shortnamebuff[o] = toupper(extension[i]);
   }
   o++;
  }
 }
 shortnamebuff[6]='~';
 shortnamebuff[7]='1';
 shortnamebuff[12]=0;
 if(shortnamebuff[9]==' ') shortnamebuff[8]='\0';

 dprintf(("","Here file name is '%s'\n",shortnamebuff));

 DOS_direntry * fentry;
 int index;

 for(i=1;i<99;i++)
 {
  shortnamebuff[7]='0'+(i%10);
  if((i / 10) > 0)
  {
   shortnamebuff[6]='0'+(i/10);
   shortnamebuff[5]='~';
  }
  index=0;
  fentry=findDIRentry(shortnamebuff,cdir,cdir->dir_size,&index);
  if(fentry==NULL)
  {
   i=99;
   continue;
  }
 }


 dprintf(("","shorten_lfn: Started with lfn \"%s\"\n",longfname));
 dprintf(("","shorten_lfn: Created short name \"%s\", char[8]= %x, char[9]= %x, char[10]= %x, char[11]= %x, char[12]= %x, char[13]= %x\n",shortnamebuff,shortnamebuff[8],shortnamebuff[9],shortnamebuff[10],shortnamebuff[11],shortnamebuff[12],shortnamebuff[13]));
 retval=1;
slnfn1:
  memset(shortname,' ',11);
  memcpy(shortname,shortnamebuff,8);
  memcpy(&shortname[8],&shortnamebuff[9],3);
  if(shortnamebuff[8]=='.') i=8;
  else i=0;
  for(;i<11;i++)
  {
   if(shortnamebuff[i] == ' ')
   {
    shortnamebuff[i]=0;
    i=11;
    continue;
   }
  }
 return retval;
}

void MakeLFNEntries(DOS_direntry * lfn[],int numreq,char* leafname,char* shortname)
{
   int lfnnum,i;
   DOS_lfnentry * lfnentry;
   int charnum=0;
   int nullreached=0;
   for(i=(numreq-2),lfnnum=0;i>=0;i--,lfnnum++)
   {//create the long file name structures
    lfnentry = (DOS_lfnentry*)lfn[i];
    lfnentry->FILE_Ordinal =  ((lfnnum&0x3F)+1);
    if(i==0) lfnentry->FILE_Ordinal |= 0x40; // Last entry
    lfnentry->FILE_attribute = 0x0F;
    lfnentry->FILE_uchar0_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar0    = (nullreached)?0xFF:leafname[charnum];
    if(leafname[charnum]==NULL) nullreached=1;
    charnum++;
    lfnentry->FILE_uchar1_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar1    = (nullreached)?0xFF:leafname[charnum];
    if(leafname[charnum]==NULL) nullreached=1;
    charnum++;
    lfnentry->FILE_uchar2_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar2    = (nullreached)?0xFF:leafname[charnum];
    if(leafname[charnum]==NULL) nullreached=1;
    charnum++;
    lfnentry->FILE_uchar3_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar3    = (nullreached)?0xFF:leafname[charnum];
    if(leafname[charnum]==NULL) nullreached=1;
    charnum++;
    lfnentry->FILE_uchar4_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar4    = (nullreached)?0xFF:leafname[charnum];
    if(leafname[charnum]==NULL) nullreached=1;
    charnum++;
    lfnentry->FILE_uchar5_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar5    = (nullreached)?0xFF:leafname[charnum];
    if(leafname[charnum]==NULL) nullreached=1;
    charnum++;
    lfnentry->FILE_uchar6_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar6    = (nullreached)?0xFF:leafname[charnum];
    if(leafname[charnum]==NULL) nullreached=1;
    charnum++;
    lfnentry->FILE_uchar7_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar7    = (nullreached)?0xFF:leafname[charnum];
    if(leafname[charnum]==NULL) nullreached=1;
    charnum++;
    lfnentry->FILE_uchar8_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar8    = (nullreached)?0xFF:leafname[charnum];
    if(leafname[charnum]==NULL) nullreached=1;
    charnum++;
    lfnentry->FILE_uchar9_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar9    = (nullreached)?0xFF:leafname[charnum];
    if(leafname[charnum]==NULL) nullreached=1;
    charnum++;
    lfnentry->FILE_uchar10_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar10    = (nullreached)?0xFF:leafname[charnum];
    if(leafname[charnum]==NULL) nullreached=1;
    charnum++;
    lfnentry->FILE_uchar11_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar11    = (nullreached)?0xFF:leafname[charnum];
    if(leafname[charnum]==NULL) nullreached=1;
    charnum++;
    lfnentry->FILE_uchar12_hi = (nullreached)?0xFF:0;
    lfnentry->FILE_uchar12    = (nullreached)?0xFF:leafname[charnum];
    if(leafname[charnum]==NULL) nullreached=1;
    charnum++;
    lfnentry->FILE_checksum = lfnchecksum(shortname);
   }
}


/*---------------------------------------------------------------------------*/
/* convertRISCOStoLFN:
 * translate a standard RISC OS name into an extended DOS one.
 */
char *convertRISCOStoLFN(char *source,char *dest)
{
 char      *csptr = source ;
 char      *cdptr = dest ;
 int        loop ;
 int        filesepseen = FALSE ; /* if we have seen the file seperator */
 char      *cptr ;      /* string pointer */
 char       lchr ;      /* last character seen */
 int        point = 0 ; /* position where file extension started */

 if ((source == NULL) || (*source == NULL))
  {
   dprintf(("","DOSFS: convertRISCOStoLFN: NULL name\n")) ;
   *dest = NULL ;
   return(dest) ;
  }

 dprintf(("","DOSFS: convertRISCOStoLFN: \"%s\"",source)) ;

 lchr = '\0' ; /* no last character */
 cptr = csptr;
 do {
   /* Ensure that "/" characters do not appear at the start or end of the name
    * and that "//" sequences are trapped.
    */
//   if ((*cptr == '/' && (lchr == '\0' || lchr == *cptr || lchr == '.')) || ((lchr == '/') && ((*cptr == '\0') || (*cptr == '.'))))
//    return_error1(char *,err_invalidname,source) ;

   lchr = *cptr++ ; /* remember this character */
 } while (lchr);

 if (*csptr == '$')             /* ROOT directory specifier */
  {
   csptr++ ;
   if (*csptr == '.')           /* RISC OS directory seperator */
    {
     *cdptr++ = dir_sep ;       /* MSDOS directory seperator */
     csptr++ ;
    }
   else
    if (*csptr == NULL)
     *cdptr++ = dir_sep ;
    else
     *cdptr++ = '$' ;
  }

 for (loop = 0;;)       /* convert the remainder of the pathname */
  {
   if (*csptr == NULL)  /* end of the source pathname */
    {
     *cdptr = NULL ;    /* terminate the destination pathname */
     break ;
    }

   switch (*csptr)
    {
     case '.' : /* RISC OS to directory seperator */
                *cdptr++ = dir_sep ;
                csptr++ ;
                loop = 0 ;
                filesepseen = FALSE ; /* for this leafname */
                break ;

     case '/' : /* convert to file seperator */
//                if (filesepseen)
//                 return_error1(char *,err_invalidname,source);
                *cdptr++ = file_sep ;
                csptr++ ;
                loop++ ;
                point = loop ;
//                filesepseen = TRUE ;
                break ;

     default  : /* perform standard name mapping */
//                if (filesepseen)
//                 {
//                  char c = *csptr++;
                  /* should never need to truncate the extension */
//                  if ((loop - point) >= extsize)
//                   return_error1(char *,err_invalidname,source) ;
//                  if (islower(c))
//                   c = toupper(c);
//                  *cdptr++ = mapchar(c,ROmapping,DOSmapping) ;
//                 }
//                else
//                 {
                  if (loop < 255)    /* characters left */
                   {
                    char c = *csptr;
//                    if (islower(c))
//                     c = toupper(c) ;
                    *cdptr++ = mapchar(c,ROmapping,DOSmapping) ;
                   }
#if 1 /* SMC_TRUNCATE */
                  else
                   {
                    if (!(module_flags & TRUNCATE_NAMES))
                     return_errorT(char *, err_nametoolong, tok_nametoolong, source, namsizestr);
                   }
#endif
                  csptr++ ;      /* step over this DOS character */
//                 }
                loop++ ;
                break ;
    }
  }

 dprintf((""," converted to \"%s\"\n",dest)) ;

// for (cptr = dest; *cptr; cptr++)
//  if (!validchar(valchars,*cptr))
//   return_error1(char *,err_invalidname,source);

 return(dest) ;
}


/*-------------------------------------------------------------------------*/
/* convertDOStoRISCOS:
 */
char *convertDOStoRISCOS(char *source,char *dest)
{
 char *csptr = source ;
 char *cdptr = dest ;
 int   loop ;

 dprintf(("","DOSFS: convertDOStoRISCOS: \"%s\" ",source)) ;

 if (*csptr == dir_sep)
  *cdptr++ = '$' ;

 for (loop = 0;;)
  {
   if (*csptr == NULL)  /* end of the source pathname */
    {
     *cdptr = NULL ;    /* terminate filename */
     break ;            /* the for loop */
    }

   switch (*csptr)
    {
     case file_sep : /* convert the character to "/" */
                     *cdptr++ = '/' ;
                     csptr++ ;
                     loop++ ;
                     break ;

     case dir_sep  : /* convert to RISC OS directory seperator */
                     *cdptr++ = '.' ;
                     loop = 0 ;
                     csptr++ ;
                     break ;

     default       : /* perform standard name mapping */
                     /* we never truncate here, it's up to the outside world */
                     *cdptr++ = mapchar(*csptr,DOSmapping,ROmapping) ;
                     csptr++ ;
                     loop++ ;
                     break ;
    }
  }

 dprintf(("","converted to \"%s\"\n",dest)) ;
 return(dest) ;
}

/*---------------------------------------------------------------------------*/
/*> EOF c.DOSnaming <*/

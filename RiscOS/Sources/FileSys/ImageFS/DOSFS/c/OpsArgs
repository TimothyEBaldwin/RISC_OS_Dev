/* Copyright 2012 Castle Technology Ltd
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*> c.OpsArgs <*/
/*-------------------------------------------------------------------------*/
/* DOSFS image FS 'Args'                        Copyright (c) 1990 JGSmith */
/*-------------------------------------------------------------------------*/

#include <stdlib.h>
#include "DebugLib/DebugLib.h"

#include "DOSFS.h"
#include "DOSshape.h"
#include "Ops.h"
#include "DOSclusters.h"
#include "debug.h"

int DOSFS_write_extent(FILEhand *fhand,word fext)
{
 /* in: fhand : internal filesystem handle for this file
  *     fext  : new file extent
  *
  * Set the extent of a file (usually prior to it being closed).
  */

 /* modify the current file pointer for the given open file */
 dprintf(("","\n\nDOSFS_write_extent: fhand = &%08X, fext = &%08X\n",(int)fhand,fext));

 /* We will fall straight through if the extent is identical to the current
  * file length.
  */
 if (fext > fhand->filelen)
  {
   word indexptr = fhand->indexptr ; /* preserve our position over ensure */
   if (DOSFS_write_zeros(fhand,fhand->filelen,(fext - fhand->filelen)) < 0)
    return((int)-1) ; /* error already defined */
   fhand->indexptr = indexptr ; /* restore file position */
  }
 else
  if (fext < fhand->filelen)
   {
    /* truncate the file to the desired length */
    if (ensure_exact(fhand,fext) < 0)
     return((int)-1) ; /* error already defined */
    fhand->indexptr = fext ; /* new file position */
   }

 dprintf(("","DOSFS_write_extent: fhand &%08X (len &%08X ptr &%08X)\n",(int)fhand,fhand->filelen,fhand->indexptr));
 /* out:
  *     no conditions
  */
 return(0) ;
}

word DOSFS_alloc(FILEhand *fhand)
{
 int CLUSTERsize ;

 /* in: fhand : internal filesystem handle for the file
  */

 dprintf(("","\n\nDOSFS_alloc: fhand = &%08X\n",(int)fhand));

 CLUSTERsize = cluster_size(&(fhand->ihand->disc_boot)) ;

 /* return the disc space allocated to the file */
 /* out:
  *     return : space allocated to the file (rounded up the next allocation
  *              unit)
  */
 dprintf(("","DOSFS_alloc: fhand &%08X (len &%08X ptr &%08X)\n",(int)fhand,fhand->filelen,fhand->indexptr));
 return((fhand->filelen + (CLUSTERsize - 1)) & -CLUSTERsize) ;
}

FS_datestamp *DOSFS_flush(FILEhand *fhand)
{
 /* in: fhand : internal filesystem handle for the file
  *
  * Flush any buffered data to the media.
  */

 dprintf(("","\n\nDOSFS_flush: fhand = &%08X\n",(int)fhand));

 /* flush the file buffer if modified */
 if ((fhand->filebuff != NULL) && (fhand->modified))
  {
   dprintf(("","DOSFS_flush: buffer needs to be written to the file\n"));
   DOS_cluster_RW(Wdata,fhand->currentCLUSTER,0,fhand->filebuff,(secsalloc(fhand->ihand) * DOSsecsize),fhand->ihand) ;
   fhand->modified = 0 ; /* clear the modified flag */
  }

 /* The load/exec addresses returned are those currently in the directory
  * entry for the file.
  */
 tstamp.loadaddr = fhand->loadaddr ;
 tstamp.execaddr = fhand->execaddr ;

 dprintf(("","DOSFS_flush: fhand &%08X (len &%08X ptr &%08X)\n",(int)fhand,fhand->filelen,fhand->indexptr));
 /* out:
  *     tstamp.loadaddr = desired load address for the file
  *     tstamp.execaddr = desired exec address for the file
  */
 return(&tstamp) ;
}

word DOSFS_ensure(FILEhand *fhand,word ensure)
{
 /* in:
  *     fhand  : internal filesystem handle for the file
  *     ensure : size of file to ensure
  *
  * Ensure the file can be extended to at least the given size. The extra
  * space need NOT be zeroed.
  */

 dprintf(("","\n\nDOSFS_ensure: fhand = &%08X, ensure = &%08X\n",(int)fhand,ensure));

 /* Set the file length to at least the desired value "ensure". */
 if (fhand->filelen < ensure) {
   if (ensure_exact(fhand, ensure) < 0)
     return -1;
 }

 dprintf(("","DOSFS_ensure: fhand &%08X (len &%08X ptr &%08X)\n",(int)fhand,fhand->filelen,fhand->indexptr));
 /* out:
  *     return : size of file actually ensured
  */
 return(fhand->filelen) ;
}

int DOSFS_write_zeros(FILEhand *fhand,word foff,word bytes)
{
  return DOS_bytes_RW(Wzero, 0, bytes, foff, fhand);
}

FS_datestamp *DOSFS_read_datestamp(FILEhand *fhand)
{
 /* in: fhand : internal filesystem handle for the file
  *
  * Return the current load and exec addresses for this file.
  */

 dprintf(("","\n\nDOSFS_read_datestamp: fhand = &%08X\n",(int)fhand));

 /* The load/exec addresses returned are those currently in the directory
  * entry for the file.
  */
 tstamp.loadaddr = fhand->loadaddr ;
 tstamp.execaddr = fhand->execaddr ;

 dprintf(("","DOSFS_read_datestamp: fhand &%08X (len &%08X ptr &%08X)\n",(int)fhand,fhand->filelen,fhand->indexptr));
 /* out:
  *     tstamp.loadaddr = desired load address for the file
  *     tstamp.execaddr = desired exec address for the file
  */
 return(&tstamp) ;
}

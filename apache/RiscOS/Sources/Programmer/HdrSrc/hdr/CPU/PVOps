; Copyright (c) 2013-2017, Timothy Baldwin
;
; Licensed under the Apache License, Version 2.0 (the "License");
; you may not use this file except in compliance with the License.
; You may obtain a copy of the License at
;
;     http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS,
; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
; See the License for the specific language governing permissions and
; limitations under the License.
;

 IF :LNOT: :DEF: Included_Hdr_PVOps
        GBLL    Included_Hdr_PVOps
Included_Hdr_PVOps SETL {TRUE}

 IF :LNOT: :DEF: Included_Hdr_Machine_Machine
        GET     Hdr:Machine.<Machine>
 ENDIF

        GBLS    _PVirt
_PVirt  SETS    "__PVirt"

        MACRO
        PVOpsImports

        ; Linux port SWIs
        EXTERN  $_PVirt._FastSWI
        EXTERN  $_PVirt._SWI

        ; Linux system calls
        EXTERN  $_PVirt._LinuxSyscall

        ; Banked registers and PSR manipulation
        ; Implementions for 26-bit (TODO), 32-bit native and 32-bit user mode.
        EXTERN  $_PVirt._GetCPSR
        EXTERN  $_PVirt._GetSPSR
        EXTERN  $_PVirt._LoadSaveBlock
        EXTERN  $_PVirt._LoadUsr
        EXTERN  $_PVirt._LoadUsrRegisters
        EXTERN  $_PVirt._MOVS_PC_LR
        EXTERN  $_PVirt._SetCPSR_c
        EXTERN  $_PVirt._SetCPSR_cxsf
        EXTERN  $_PVirt._SetCPSR_c_unstack
        EXTERN  $_PVirt._SetCPSR_cf_unstack
        EXTERN  $_PVirt._SetCPSR_cs_unstack
        EXTERN  $_PVirt._SetCPSR_csf_unstack
        EXTERN  $_PVirt._SetCPSR_cx_unstack
        EXTERN  $_PVirt._SetCPSR_cxf_unstack
        EXTERN  $_PVirt._SetCPSR_cxs_unstack
        EXTERN  $_PVirt._SetCPSR_cxsf_unstack
        EXTERN  $_PVirt._SetSPSR
        EXTERN  $_PVirt._StoreUsr

        ; Virtual banked registers
        EXTERN  $_PVirt._GetVCPU
        EXTERN  $_PVirt._VModeOffsets

        ; For InitPVOps
        EXTERN  $_PVirt._TableEnd
        EXTERN  $_PVirt._TableStart

        MEND

        MACRO
        PVJumpTable
      IF PVSys = 3
        PVOpsImports
      ELIF PVSys > 0
        EXPORT  $_PVirt._TableStart
$_PVirt._TableStart
        EXPORT  $_PVirt._SetCPSR_cs_unstack
        EXPORT  $_PVirt._SetCPSR_cxs_unstack
$_PVirt._SetCPSR_cs_unstack
$_PVirt._SetCPSR_cxs_unstack
        MSR     cpsr_s, r1
        B       $_PVirt._SetCPSR_c_unstack

        EXPORT  $_PVirt._SetCPSR_csf_unstack
        EXPORT  $_PVirt._SetCPSR_cxsf_unstack
$_PVirt._SetCPSR_csf_unstack
$_PVirt._SetCPSR_cxsf_unstack
        MSR     cpsr_sf, r1

        EXPORT  $_PVirt._SetCPSR_cf_unstack
        EXPORT  $_PVirt._SetCPSR_cxf_unstack
$_PVirt._SetCPSR_cf_unstack
$_PVirt._SetCPSR_cxf_unstack
        MSR     cpsr_f, r1

        EXPORT  $_PVirt._SetCPSR_c_unstack
        EXPORT  $_PVirt._SetCPSR_cx_unstack
$_PVirt._SetCPSR_c_unstack
$_PVirt._SetCPSR_cx_unstack
        LDR     r0, [sp, #16]
        STR     lr, [sp, #16]
        MOV     lr, r0
        LDMFD   sp!, {r0-r3, ip, pc}

        EXPORT  $_PVirt._GetCPSR
$_PVirt._GetCPSR
        MRS     r0, CPSR
        MOV     pc, lr

        EXPORT  $_PVirt._SetSPSR
$_PVirt._SetSPSR
        MSR     SPSR_cxsf, r1
        MOV     pc, lr

        EXPORT  $_PVirt._GetSPSR
$_PVirt._GetSPSR
        MRS     r0, SPSR
        MOV     pc, lr

        EXPORT  $_PVirt._GetVCPU
$_PVirt._GetVCPU
        DCD     1
        UND

        EXPORT  $_PVirt._FindMode
$_PVirt._FindMode
        DCD     2
        UND

        EXPORT  $_PVirt._MOVS_PC_LR
$_PVirt._MOVS_PC_LR
        MOVS    pc, lr
        UND

        EXPORT  $_PVirt._LoadUsrRegisters
$_PVirt._LoadUsrRegisters
        DCD     3
        UND

        EXPORT  $_PVirt._SWI
$_PVirt._SWI
        LDR     r0, [sp, #12]
        STR     lr, [sp, #12]
        MOV     lr, r0
        LDMFD   sp!, {r0-r3, pc}

        EXPORT  $_PVirt._LinuxSyscall
$_PVirt._LinuxSyscall
        DCD     4
        UND

        EXPORT  $_PVirt._FastSWI
$_PVirt._FastSWI
        MOV     pc, lr
        UND
        
        EXPORT  $_PVirt._TableEnd
$_PVirt._TableEnd

      ENDIF
        MEND

        MACRO
        InitPVOps
      [ PVSys = 1 :LOR: PVSys = 2
        STMFD   sp!, {r0, r1, lr} ; FIXME Remove?
        ADRL    r0, $_PVirt._TableStart
        ADRL    r1, $_PVirt._TableEnd
        SWI     0xE0202 ; XIXSupport_PatchTable
        LDMFD   sp!, {r0, r1, lr}
      ]
        MEND

        MACRO
        MOVop2$c $rd, $op2a, $op2b
  [ "$op2b" = ""
    [  "$op2a" != "$rd"
        MOV$c   $rd, $op2a
    ]
  |
        MOV$c   $rd, $op2a, $op2b
  ]
        MEND

        ; Simulates a SWI call
        MACRO
$label  pvSWI$cond $swi
$label
 [ PVSys > 0
        STM$cond.DB sp!, {r0-r3, lr}
        BL$cond $_PVirt._SWI
 ]
        SWI$cond $swi
        MEND

        ; Simulates a SWI call, corrupts LR
        MACRO
$label  fvSWI$cond $swi
$label
 [ PVSys > 0
        BL$cond $_PVirt._FastSWI
 ]
        SWI$cond $swi
        MEND


        MACRO
$label  pvMRS$c $reg, $psr
        ASSERT  ("$psr" = "CPSR") :LOR: ("$psr" = "SPSR")
 [ PVirt > 0
        IF      $reg = 0
$label  STR$c   lr, [sp, #-4]!
        BL$c    $_PVirt._Get$psr
        LDR$c   lr, [sp], #4

        ELIF    $reg = 14
$label  STR$c   r0, [sp, #-4]!
        BL$c    $_PVirt._Get$psr
        MOV$c   lr, r0
        LDR$c   r0, [sp], #4

        ELSE
$label  STM$c.FD sp!, {r0, lr}
        BL$c    $_PVirt._Get$psr
        MOV$c   $reg, r0
        LDM$c.FD sp!, {r0, lr}

        ENDIF
 |
$label  MRS$c   $reg, $psr
 ]
        MEND

        MACRO
$label  pvMSR$c $psr, $op2a, $op2b
$label
 IF PVirt < 1
        [ "$op2b" = ""
        MSR$c   $psr, $op2a
        |
        MSR$c   $psr, $op2a, $op2b
        ]
 ELIF "$psr" = "SPSR_cxsf"
        STM$c.FD sp!, {r1, lr}
        MOVop2$c r1, $op2a, $op2b
        BL$c    $_PVirt._SetSPSR
        LDM$c.FD sp!, {r1, lr}
 ELSE

        ASSERT "$psr":LEFT:5 = "CPSR_"
        ASSERT "$psr":LEFT:6 <> "CPSR_x"

  [ "$psr":LEFT:6 = "CPSR_c"
        STM$c.FD sp!, {r0-r3, ip, lr}
        MOVop2$c r1, $op2a, $op2b
        BL$c    $_PVirt._Set$psr._unstack
  ]

        [ "$op2b" = ""
        MSR$c   $psr, $op2a
        |
        MSR$c   $psr, $op2a, $op2b
        ]
 ENDIF ; PVirt
        MEND

        MACRO
$label  MOVS_PC_LR $c
 [ PVirt > 0
$label  B$c     $_PVirt._MOVS_PC_LR
 |
$label  MOV$c.S pc, lr
 ]
        MEND


                        ^       0
                        #       8 ; Reserved for ELF thread local variables.
vcpu_vectors            #       4
vcpu_irq_pending        #       1
vcpu_cpsr               #       1
                        #       2
vcpu_r13_svc            #       4
vcpu_r14_svc            #       4
vcpu_spsr_svc           #       4
vcpu_r13_usr            #       4
vcpu_r14_usr            #       4
vcpu_spsr_usr           #       4
vcpu_r13_irq            #       4
vcpu_r14_irq            #       4
vcpu_spsr_irq           #       4
vcpu_r13_fiq            #       4
vcpu_r14_fiq            #       4
vcpu_spsr_fiq           #       4
vcpu_r13_und            #       4
vcpu_r14_und            #       4
vcpu_spsr_und           #       4
vcpu_r13_abt            #       4
vcpu_r14_abt            #       4
vcpu_spsr_abt           #       4
vcpu_DFAR               #       4

 ENDIF
        END
